---
phase: 03-access-control-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/XXXXXX_access_point_enums.sql
  - supabase/migrations/XXXXXX_access_points_table.sql
  - supabase/migrations/XXXXXX_guards_tables.sql
autonomous: true

must_haves:
  truths:
    - "Access points can be created with type (vehicular_gate, pedestrian_gate, turnstile, barrier, door, elevator)"
    - "Access points have direction (entry, exit, bidirectional)"
    - "Guards can be created independent of residents (for non-resident security staff)"
    - "Guard shifts define time windows that can cross midnight"
    - "Shift assignments link guards to shifts at specific access points"
  artifacts:
    - path: "supabase/migrations/XXXXXX_access_point_enums.sql"
      provides: "access_point_type and access_point_direction enum types"
      contains: "CREATE TYPE access_point_type"
    - path: "supabase/migrations/XXXXXX_access_points_table.sql"
      provides: "access_points table with RLS"
      contains: "CREATE TABLE access_points"
    - path: "supabase/migrations/XXXXXX_guards_tables.sql"
      provides: "guards, guard_certifications, guard_shifts, shift_assignments tables"
      contains: "CREATE TABLE guards"
  key_links:
    - from: "access_points"
      to: "communities"
      via: "community_id FK"
      pattern: "REFERENCES communities\\(id\\)"
    - from: "guards"
      to: "auth.users"
      via: "optional user_id FK"
      pattern: "REFERENCES auth\\.users\\(id\\)"
    - from: "shift_assignments"
      to: "access_points"
      via: "access_point_id FK"
      pattern: "REFERENCES access_points\\(id\\)"
---

<objective>
Create access control infrastructure - access point types/tables and complete guard management system

Purpose: Establish the physical access point model and guard workforce management that all access logging, patrols, and emergency response depends on
Output: 2 enum types, 5 tables (access_points, guards, guard_certifications, guard_shifts, shift_assignments) with RLS
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-access-control-security/03-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create access point enum types</name>
  <files>supabase/migrations/XXXXXX_access_point_enums.sql</files>
  <action>
Create migration with timestamp prefix (use current timestamp format YYYYMMDDHHMMSS).

Create two enum types:

```sql
-- Access point types for physical entry/exit points
CREATE TYPE access_point_type AS ENUM (
  'vehicular_gate',    -- Car entry/exit gate
  'pedestrian_gate',   -- Walking entry gate
  'turnstile',         -- Single-person controlled entry
  'barrier',           -- Parking barrier arm
  'door',              -- Building door with access control
  'elevator'           -- Access-controlled elevator
);

-- Direction of access point
CREATE TYPE access_point_direction AS ENUM (
  'entry',             -- Entry only
  'exit',              -- Exit only
  'bidirectional'      -- Both entry and exit
);
```

Add comments explaining each enum value purpose.
  </action>
  <verify>
Query Supabase to verify enums exist:
```sql
SELECT typname FROM pg_type WHERE typname IN ('access_point_type', 'access_point_direction');
```
Should return 2 rows.
  </verify>
  <done>Both access_point_type and access_point_direction enums exist in database</done>
</task>

<task type="auto">
  <name>Task 2: Create access_points table with RLS</name>
  <files>supabase/migrations/XXXXXX_access_points_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create access_points table:

```sql
CREATE TABLE access_points (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Identification
  name TEXT NOT NULL,                       -- "Main Gate", "Tower A Entrance"
  code TEXT,                                -- Short code for guards: "MG", "T1"

  -- Type and direction
  access_point_type access_point_type NOT NULL,
  direction access_point_direction NOT NULL DEFAULT 'bidirectional',

  -- Location
  location_description TEXT,
  location_lat NUMERIC(10, 7),
  location_lng NUMERIC(10, 7),

  -- Capabilities (hardware features)
  has_lpr BOOLEAN NOT NULL DEFAULT FALSE,           -- License plate recognition
  has_intercom BOOLEAN NOT NULL DEFAULT FALSE,
  has_camera BOOLEAN NOT NULL DEFAULT TRUE,
  has_nfc_reader BOOLEAN NOT NULL DEFAULT FALSE,
  has_qr_scanner BOOLEAN NOT NULL DEFAULT TRUE,
  can_remote_open BOOLEAN NOT NULL DEFAULT FALSE,   -- Can be opened remotely

  -- Hardware identifiers (for future integrations)
  lpr_device_id TEXT,
  camera_device_id TEXT,
  barrier_controller_id TEXT,

  -- Operating hours (NULL = 24/7)
  operating_start_time TIME,
  operating_end_time TIME,

  -- Status
  status general_status NOT NULL DEFAULT 'active',
  is_emergency_exit BOOLEAN NOT NULL DEFAULT FALSE,

  -- Audit columns
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  -- Constraints
  CONSTRAINT access_points_name_unique UNIQUE (community_id, name)
);

-- Indexes
CREATE INDEX idx_access_points_community ON access_points(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_access_points_type ON access_points(community_id, access_point_type) WHERE deleted_at IS NULL;

-- Audit trigger
CREATE TRIGGER access_points_audit
  BEFORE INSERT OR UPDATE ON access_points
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- RLS
ALTER TABLE access_points ENABLE ROW LEVEL SECURITY;

-- Super admin can see all
CREATE POLICY "super_admin_all_access_points"
  ON access_points
  FOR ALL
  TO authenticated
  USING (is_super_admin())
  WITH CHECK (is_super_admin());

-- Users can view their community's access points
CREATE POLICY "users_view_own_community_access_points"
  ON access_points
  FOR SELECT
  TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND deleted_at IS NULL
  );

-- Admins can manage their community's access points
CREATE POLICY "admins_manage_access_points"
  ON access_points
  FOR ALL
  TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );
```

Add table and column comments.
  </action>
  <verify>
Query Supabase to verify table structure:
```sql
SELECT column_name, data_type FROM information_schema.columns
WHERE table_name = 'access_points' ORDER BY ordinal_position;
```
Verify RLS policies:
```sql
SELECT policyname FROM pg_policies WHERE tablename = 'access_points';
```
  </verify>
  <done>access_points table exists with 3 RLS policies (super_admin, users_view, admins_manage)</done>
</task>

<task type="auto">
  <name>Task 3: Create guards and shift management tables</name>
  <files>supabase/migrations/XXXXXX_guards_tables.sql</files>
  <action>
Create migration with timestamp prefix.

Create 4 tables for guard management:

```sql
-- Guards (separate from residents for non-resident security staff)
CREATE TABLE guards (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Optional link to auth if guard has app access
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  -- Personal info (Mexican name format)
  first_name TEXT NOT NULL,
  paternal_surname TEXT NOT NULL,
  maternal_surname TEXT,
  full_name TEXT GENERATED ALWAYS AS (
    first_name || ' ' || paternal_surname || COALESCE(' ' || maternal_surname, '')
  ) STORED,
  photo_url TEXT,

  -- Contact
  phone phone_number NOT NULL,
  phone_emergency phone_number,
  email TEXT,

  -- Employment
  employee_number TEXT,
  hired_at DATE,
  employment_status general_status NOT NULL DEFAULT 'active',

  -- Documents (Mexican IDs)
  ine_number TEXT,
  curp TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ
);

-- Guard certifications/training records
CREATE TABLE guard_certifications (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  guard_id UUID NOT NULL REFERENCES guards(id) ON DELETE CASCADE,

  certification_type TEXT NOT NULL,        -- 'security_license', 'first_aid', 'fire_safety'
  certificate_number TEXT,
  issuing_authority TEXT,
  issued_at DATE NOT NULL,
  expires_at DATE,
  document_url TEXT,                       -- Certificate scan in storage

  status general_status NOT NULL DEFAULT 'active',

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ
);

-- Shift definitions (templates)
CREATE TABLE guard_shifts (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  name TEXT NOT NULL,                      -- "Morning Shift", "Night Shift"

  -- Schedule times
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,

  -- Which days this shift applies (NULL = all days)
  -- Array of day-of-week: 0=Sun, 1=Mon, ..., 6=Sat
  applicable_days INTEGER[],

  -- Computed: whether shift crosses midnight (22:00-06:00)
  crosses_midnight BOOLEAN GENERATED ALWAYS AS (end_time < start_time) STORED,

  status general_status NOT NULL DEFAULT 'active',

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  CONSTRAINT guard_shifts_name_unique UNIQUE (community_id, name)
);

-- Shift assignments (guard + shift + access point + date range)
CREATE TABLE shift_assignments (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  guard_id UUID NOT NULL REFERENCES guards(id) ON DELETE CASCADE,
  shift_id UUID NOT NULL REFERENCES guard_shifts(id) ON DELETE CASCADE,
  access_point_id UUID NOT NULL REFERENCES access_points(id) ON DELETE CASCADE,

  -- Assignment period
  effective_from DATE NOT NULL,
  effective_until DATE,                    -- NULL for ongoing assignment

  -- Status
  status general_status NOT NULL DEFAULT 'active',

  -- Notes
  notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  -- Prevent double-booking same guard at same time/place
  CONSTRAINT assignments_guard_shift_unique
    UNIQUE (guard_id, shift_id, access_point_id, effective_from)
);

-- Indexes
CREATE INDEX idx_guards_community ON guards(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_guards_user ON guards(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_guards_status ON guards(community_id, employment_status) WHERE deleted_at IS NULL;

CREATE INDEX idx_guard_certs_guard ON guard_certifications(guard_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_guard_certs_expiry ON guard_certifications(expires_at) WHERE expires_at IS NOT NULL AND status = 'active';

CREATE INDEX idx_guard_shifts_community ON guard_shifts(community_id) WHERE deleted_at IS NULL;

CREATE INDEX idx_shift_assignments_guard ON shift_assignments(guard_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_shift_assignments_access_point ON shift_assignments(access_point_id, effective_from) WHERE deleted_at IS NULL;

-- Audit triggers
CREATE TRIGGER guards_audit BEFORE INSERT OR UPDATE ON guards FOR EACH ROW EXECUTE FUNCTION set_audit_fields();
CREATE TRIGGER guard_certifications_audit BEFORE INSERT OR UPDATE ON guard_certifications FOR EACH ROW EXECUTE FUNCTION set_audit_fields();
CREATE TRIGGER guard_shifts_audit BEFORE INSERT OR UPDATE ON guard_shifts FOR EACH ROW EXECUTE FUNCTION set_audit_fields();
CREATE TRIGGER shift_assignments_audit BEFORE INSERT OR UPDATE ON shift_assignments FOR EACH ROW EXECUTE FUNCTION set_audit_fields();

-- RLS for all guard tables
ALTER TABLE guards ENABLE ROW LEVEL SECURITY;
ALTER TABLE guard_certifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE guard_shifts ENABLE ROW LEVEL SECURITY;
ALTER TABLE shift_assignments ENABLE ROW LEVEL SECURITY;

-- Guards RLS
CREATE POLICY "super_admin_all_guards" ON guards FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_guards" ON guards FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND deleted_at IS NULL);

CREATE POLICY "admins_manage_guards" ON guards FOR ALL TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'))
  WITH CHECK (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'));

-- Guard certifications RLS (follows guard access)
CREATE POLICY "super_admin_all_guard_certs" ON guard_certifications FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_guard_certs" ON guard_certifications FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM guards g WHERE g.id = guard_certifications.guard_id
    AND g.community_id = (SELECT get_current_community_id()) AND g.deleted_at IS NULL
  ));

CREATE POLICY "admins_manage_guard_certs" ON guard_certifications FOR ALL TO authenticated
  USING (EXISTS (
    SELECT 1 FROM guards g WHERE g.id = guard_certifications.guard_id
    AND g.community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  ))
  WITH CHECK (EXISTS (
    SELECT 1 FROM guards g WHERE g.id = guard_certifications.guard_id
    AND g.community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  ));

-- Guard shifts RLS
CREATE POLICY "super_admin_all_shifts" ON guard_shifts FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_shifts" ON guard_shifts FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND deleted_at IS NULL);

CREATE POLICY "admins_manage_shifts" ON guard_shifts FOR ALL TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'))
  WITH CHECK (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'));

-- Shift assignments RLS
CREATE POLICY "super_admin_all_assignments" ON shift_assignments FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_assignments" ON shift_assignments FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND deleted_at IS NULL);

CREATE POLICY "admins_manage_assignments" ON shift_assignments FOR ALL TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'))
  WITH CHECK (community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'manager'));
```

Add helper function to get guards on duty:

```sql
-- Function to get guards currently on duty at an access point
CREATE OR REPLACE FUNCTION get_guards_on_duty(
  p_access_point_id UUID,
  p_check_time TIMESTAMPTZ DEFAULT now()
)
RETURNS SETOF guards
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT g.*
  FROM public.guards g
  JOIN public.shift_assignments sa ON sa.guard_id = g.id
  JOIN public.guard_shifts s ON s.id = sa.shift_id
  WHERE sa.access_point_id = p_access_point_id
    AND sa.status = 'active'
    AND sa.deleted_at IS NULL
    AND sa.effective_from <= p_check_time::DATE
    AND (sa.effective_until IS NULL OR sa.effective_until >= p_check_time::DATE)
    AND (s.applicable_days IS NULL OR EXTRACT(DOW FROM p_check_time)::INTEGER = ANY(s.applicable_days))
    AND (
      CASE WHEN s.crosses_midnight THEN
        p_check_time::TIME >= s.start_time OR p_check_time::TIME <= s.end_time
      ELSE
        p_check_time::TIME BETWEEN s.start_time AND s.end_time
      END
    )
    AND g.deleted_at IS NULL
    AND g.employment_status = 'active';
$$;
```

Add table and column comments for all tables.
  </action>
  <verify>
Query Supabase to verify all 4 tables exist:
```sql
SELECT table_name FROM information_schema.tables
WHERE table_name IN ('guards', 'guard_certifications', 'guard_shifts', 'shift_assignments');
```
Should return 4 rows.

Verify guard_shifts.crosses_midnight is generated:
```sql
SELECT column_name, is_generated FROM information_schema.columns
WHERE table_name = 'guard_shifts' AND column_name = 'crosses_midnight';
```

Verify function exists:
```sql
SELECT routine_name FROM information_schema.routines WHERE routine_name = 'get_guards_on_duty';
```
  </verify>
  <done>guards, guard_certifications, guard_shifts, shift_assignments tables exist with RLS and get_guards_on_duty() function</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify enum types (2):
```sql
SELECT typname, enumlabel FROM pg_enum e JOIN pg_type t ON e.enumtypid = t.oid
WHERE typname IN ('access_point_type', 'access_point_direction') ORDER BY typname, enumsortorder;
```

2. Verify all tables (5):
```sql
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('access_points', 'guards', 'guard_certifications', 'guard_shifts', 'shift_assignments');
```

3. Verify RLS enabled on all tables:
```sql
SELECT tablename, rowsecurity FROM pg_tables
WHERE tablename IN ('access_points', 'guards', 'guard_certifications', 'guard_shifts', 'shift_assignments');
```

4. Verify crosses_midnight generated column works:
```sql
INSERT INTO guard_shifts (community_id, name, start_time, end_time)
VALUES ('test-uuid', 'Night', '22:00', '06:00');
SELECT crosses_midnight FROM guard_shifts WHERE name = 'Night';
-- Should return TRUE
```
</verification>

<success_criteria>
- [ ] access_point_type enum has 6 values (vehicular_gate, pedestrian_gate, turnstile, barrier, door, elevator)
- [ ] access_point_direction enum has 3 values (entry, exit, bidirectional)
- [ ] access_points table exists with community_id FK, type, direction, capabilities columns
- [ ] guards table exists with Mexican name format and optional user_id link
- [ ] guard_certifications table exists with guard_id FK and expiry tracking
- [ ] guard_shifts table exists with crosses_midnight generated column
- [ ] shift_assignments table links guards to shifts at specific access_points
- [ ] All 5 tables have RLS enabled with super_admin, users_view, admins_manage policies
- [ ] get_guards_on_duty() function returns guards for a given access point and time
</success_criteria>

<output>
After completion, create `.planning/phases/03-access-control-security/03-01-SUMMARY.md`
</output>
