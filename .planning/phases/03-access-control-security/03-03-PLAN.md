---
phase: 03-access-control-security
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - supabase/migrations/XXXXXX_patrol_checkpoints_table.sql
  - supabase/migrations/XXXXXX_patrol_routes_table.sql
  - supabase/migrations/XXXXXX_patrol_logs_tables.sql
autonomous: true

must_haves:
  truths:
    - "Patrol checkpoints store NFC tag serial numbers (not UUIDs)"
    - "NFC serial is unique per community (same tag can exist in different communities)"
    - "Patrol routes define ordered checkpoint sequences"
    - "Patrol logs track guard patrol sessions with start/complete times"
    - "Patrol checkpoint logs record individual NFC scans with GPS validation"
    - "Checkpoint visit count auto-increments when scans are logged"
  artifacts:
    - path: "supabase/migrations/XXXXXX_patrol_checkpoints_table.sql"
      provides: "patrol_checkpoints table with NFC serial"
      contains: "nfc_serial TEXT NOT NULL"
    - path: "supabase/migrations/XXXXXX_patrol_routes_table.sql"
      provides: "patrol_routes table with checkpoint sequence array"
      contains: "checkpoint_sequence UUID[]"
    - path: "supabase/migrations/XXXXXX_patrol_logs_tables.sql"
      provides: "patrol_logs and patrol_checkpoint_logs tables"
      contains: "update_patrol_progress"
  key_links:
    - from: "patrol_checkpoints"
      to: "communities"
      via: "community_id FK with unique(community_id, nfc_serial)"
      pattern: "UNIQUE.*community_id.*nfc_serial"
    - from: "patrol_logs"
      to: "guards"
      via: "guard_id FK"
      pattern: "REFERENCES guards\\(id\\)"
    - from: "patrol_checkpoint_logs"
      to: "patrol_logs"
      via: "patrol_log_id FK with ON DELETE CASCADE"
      pattern: "ON DELETE CASCADE"
---

<objective>
Create patrol management system - NFC checkpoints, patrol routes, and patrol logging with progress tracking

Purpose: Enable guard patrol tracking and verification through NFC checkpoint scanning with GPS validation
Output: 3 tables (patrol_checkpoints, patrol_routes, patrol_logs) + 1 child table (patrol_checkpoint_logs) + progress trigger
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-access-control-security/03-RESEARCH.md
@.planning/phases/03-access-control-security/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create patrol_checkpoints table with NFC serial</name>
  <files>supabase/migrations/XXXXXX_patrol_checkpoints_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create patrol_checkpoints table using NFC factory serial numbers (NOT UUIDs):

```sql
CREATE TABLE patrol_checkpoints (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- NFC tag identification (factory serial number, not UUID)
  -- e.g., "04:A2:E5:1A:BC:34:80" or "0411223344556677"
  nfc_serial TEXT NOT NULL,

  -- Location identification
  name TEXT NOT NULL,                      -- "Building A Entrance", "Pool Gate", "Parking Lot B"
  description TEXT,

  -- GPS coordinates for validation
  location_lat NUMERIC(10, 7),
  location_lng NUMERIC(10, 7),
  location_tolerance_meters INTEGER DEFAULT 50,  -- GPS validation tolerance

  -- Physical location details
  building TEXT,
  floor INTEGER,
  area TEXT,

  -- Photo of checkpoint location for guard reference
  photo_url TEXT,

  -- Status
  status general_status NOT NULL DEFAULT 'active',

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  -- NFC serial must be unique within community (same physical tag can't be in two places)
  CONSTRAINT checkpoints_nfc_unique UNIQUE (community_id, nfc_serial),
  -- Name must also be unique within community
  CONSTRAINT checkpoints_name_unique UNIQUE (community_id, name)
);

-- Indexes
CREATE INDEX idx_patrol_checkpoints_community ON patrol_checkpoints(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_patrol_checkpoints_nfc ON patrol_checkpoints(community_id, nfc_serial) WHERE deleted_at IS NULL;

-- Audit trigger
CREATE TRIGGER patrol_checkpoints_audit
  BEFORE INSERT OR UPDATE ON patrol_checkpoints
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- RLS
ALTER TABLE patrol_checkpoints ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_checkpoints" ON patrol_checkpoints FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_checkpoints" ON patrol_checkpoints FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND deleted_at IS NULL);

CREATE POLICY "admins_manage_checkpoints" ON patrol_checkpoints FOR ALL TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

COMMENT ON TABLE patrol_checkpoints IS 'Physical NFC tag locations for guard patrol verification';
COMMENT ON COLUMN patrol_checkpoints.nfc_serial IS 'Factory-assigned NFC tag serial number (e.g., "04:A2:E5:1A:BC:34:80"). Use serial number, not UUID, because NFC readers return serial numbers directly and they are factory-immutable (tamper-evident).';
COMMENT ON COLUMN patrol_checkpoints.location_tolerance_meters IS 'Maximum distance in meters between GPS location and checkpoint for valid scan';
```
  </action>
  <verify>
Verify table exists:
```sql
SELECT column_name, data_type FROM information_schema.columns
WHERE table_name = 'patrol_checkpoints' ORDER BY ordinal_position;
```

Verify unique constraints:
```sql
SELECT conname FROM pg_constraint WHERE conrelid = 'patrol_checkpoints'::regclass AND contype = 'u';
```
Should show: checkpoints_nfc_unique, checkpoints_name_unique
  </verify>
  <done>patrol_checkpoints table exists with nfc_serial TEXT column and unique constraint per community</done>
</task>

<task type="auto">
  <name>Task 2: Create patrol_routes table with checkpoint sequence</name>
  <files>supabase/migrations/XXXXXX_patrol_routes_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create patrol_routes table:

```sql
CREATE TABLE patrol_routes (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  name TEXT NOT NULL,                       -- "Night Perimeter", "Pool Area Check", "Main Building"
  description TEXT,

  -- Expected duration
  estimated_duration_minutes INTEGER,

  -- Checkpoint sequence (ordered array of checkpoint IDs)
  -- Guards should visit these checkpoints in this order
  checkpoint_sequence UUID[] NOT NULL,

  -- Schedule configuration
  frequency_minutes INTEGER,                 -- How often route should be patrolled (e.g., 60 = hourly)
  applicable_shifts UUID[],                  -- Which shifts patrol this route (FK to guard_shifts)

  status general_status NOT NULL DEFAULT 'active',

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  -- Route name unique per community
  CONSTRAINT patrol_routes_name_unique UNIQUE (community_id, name)
);

-- Indexes
CREATE INDEX idx_patrol_routes_community ON patrol_routes(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_patrol_routes_active ON patrol_routes(community_id, status) WHERE deleted_at IS NULL AND status = 'active';

-- Audit trigger
CREATE TRIGGER patrol_routes_audit
  BEFORE INSERT OR UPDATE ON patrol_routes
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- RLS
ALTER TABLE patrol_routes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_routes" ON patrol_routes FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_routes" ON patrol_routes FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()) AND deleted_at IS NULL);

CREATE POLICY "admins_manage_routes" ON patrol_routes FOR ALL TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Function to validate checkpoint sequence (all checkpoints must exist and belong to same community)
CREATE OR REPLACE FUNCTION validate_patrol_route_checkpoints()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  checkpoint_count INTEGER;
  valid_count INTEGER;
BEGIN
  IF NEW.checkpoint_sequence IS NULL OR array_length(NEW.checkpoint_sequence, 1) = 0 THEN
    RAISE EXCEPTION 'Patrol route must have at least one checkpoint';
  END IF;

  checkpoint_count := array_length(NEW.checkpoint_sequence, 1);

  SELECT COUNT(*) INTO valid_count
  FROM patrol_checkpoints
  WHERE id = ANY(NEW.checkpoint_sequence)
    AND community_id = NEW.community_id
    AND deleted_at IS NULL;

  IF valid_count != checkpoint_count THEN
    RAISE EXCEPTION 'All checkpoints in route must exist and belong to the same community';
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER patrol_routes_validate_checkpoints
  BEFORE INSERT OR UPDATE ON patrol_routes
  FOR EACH ROW
  EXECUTE FUNCTION validate_patrol_route_checkpoints();

COMMENT ON TABLE patrol_routes IS 'Defined patrol paths with ordered checkpoint sequences';
COMMENT ON COLUMN patrol_routes.checkpoint_sequence IS 'Ordered array of checkpoint IDs. Guards should visit in this order.';
COMMENT ON COLUMN patrol_routes.frequency_minutes IS 'How often this route should be patrolled. NULL means no automatic scheduling.';
```
  </action>
  <verify>
Verify table exists:
```sql
SELECT column_name, data_type FROM information_schema.columns
WHERE table_name = 'patrol_routes' ORDER BY ordinal_position;
```

Verify validation trigger:
```sql
SELECT tgname FROM pg_trigger WHERE tgrelid = 'patrol_routes'::regclass;
```
Should include: patrol_routes_validate_checkpoints
  </verify>
  <done>patrol_routes table exists with checkpoint_sequence UUID[] and validation trigger</done>
</task>

<task type="auto">
  <name>Task 3: Create patrol_logs and patrol_checkpoint_logs tables</name>
  <files>supabase/migrations/XXXXXX_patrol_logs_tables.sql</files>
  <action>
Create migration with timestamp prefix.

Create patrol logging tables with progress tracking trigger:

```sql
-- Patrol sessions (one per guard per route attempt)
CREATE TABLE patrol_logs (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Which patrol
  route_id UUID NOT NULL REFERENCES patrol_routes(id) ON DELETE RESTRICT,
  guard_id UUID NOT NULL REFERENCES guards(id) ON DELETE RESTRICT,

  -- Patrol timing
  started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  completed_at TIMESTAMPTZ,

  -- Status
  status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),

  -- Completion stats (updated by trigger)
  checkpoints_total INTEGER NOT NULL,
  checkpoints_visited INTEGER NOT NULL DEFAULT 0,

  -- If abandoned
  abandon_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
  -- No deleted_at - patrol logs are audit records
);

-- Individual checkpoint scans within a patrol
CREATE TABLE patrol_checkpoint_logs (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  patrol_log_id UUID NOT NULL REFERENCES patrol_logs(id) ON DELETE CASCADE,
  checkpoint_id UUID NOT NULL REFERENCES patrol_checkpoints(id) ON DELETE RESTRICT,

  -- Scan details
  scanned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  nfc_serial_scanned TEXT NOT NULL,         -- What was actually scanned (verification against checkpoint.nfc_serial)

  -- GPS at time of scan
  gps_lat NUMERIC(10, 7),
  gps_lng NUMERIC(10, 7),
  gps_accuracy_meters NUMERIC(6, 2),

  -- GPS validation result
  gps_within_tolerance BOOLEAN,

  -- Evidence
  photo_url TEXT,
  notes TEXT,

  -- Sequence position in the route
  sequence_order INTEGER NOT NULL,          -- 1, 2, 3... position in route

  -- Prevent duplicate scans of same checkpoint in same patrol
  CONSTRAINT checkpoint_scan_unique UNIQUE (patrol_log_id, checkpoint_id)
);

-- Indexes
CREATE INDEX idx_patrol_logs_community ON patrol_logs(community_id);
CREATE INDEX idx_patrol_logs_guard ON patrol_logs(guard_id, started_at DESC);
CREATE INDEX idx_patrol_logs_route ON patrol_logs(route_id, started_at DESC);
CREATE INDEX idx_patrol_logs_status ON patrol_logs(community_id, status) WHERE status = 'in_progress';

CREATE INDEX idx_patrol_checkpoint_logs_patrol ON patrol_checkpoint_logs(patrol_log_id);
CREATE INDEX idx_patrol_checkpoint_logs_checkpoint ON patrol_checkpoint_logs(checkpoint_id);

-- Audit trigger for patrol_logs only (checkpoint_logs are append-only)
CREATE TRIGGER patrol_logs_audit
  BEFORE INSERT OR UPDATE ON patrol_logs
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Trigger to auto-update patrol progress when checkpoint is scanned
CREATE OR REPLACE FUNCTION update_patrol_progress()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Increment visited count
  UPDATE patrol_logs
  SET checkpoints_visited = checkpoints_visited + 1,
      updated_at = now()
  WHERE id = NEW.patrol_log_id;

  -- Check if patrol is now complete
  UPDATE patrol_logs
  SET status = 'completed',
      completed_at = now()
  WHERE id = NEW.patrol_log_id
    AND checkpoints_visited >= checkpoints_total
    AND status = 'in_progress';

  RETURN NEW;
END;
$$;

CREATE TRIGGER patrol_checkpoint_logged
  AFTER INSERT ON patrol_checkpoint_logs
  FOR EACH ROW
  EXECUTE FUNCTION update_patrol_progress();

-- Function to calculate GPS distance for validation
CREATE OR REPLACE FUNCTION calculate_gps_distance_meters(
  lat1 NUMERIC,
  lng1 NUMERIC,
  lat2 NUMERIC,
  lng2 NUMERIC
)
RETURNS NUMERIC
LANGUAGE sql
IMMUTABLE
AS $$
  -- Haversine formula approximation (good enough for short distances)
  SELECT 6371000 * 2 * ASIN(
    SQRT(
      POWER(SIN(RADIANS(lat2 - lat1) / 2), 2) +
      COS(RADIANS(lat1)) * COS(RADIANS(lat2)) *
      POWER(SIN(RADIANS(lng2 - lng1) / 2), 2)
    )
  );
$$;

-- Trigger to auto-validate GPS within tolerance
CREATE OR REPLACE FUNCTION validate_checkpoint_gps()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  checkpoint_lat NUMERIC;
  checkpoint_lng NUMERIC;
  tolerance INTEGER;
  distance NUMERIC;
BEGIN
  -- Get checkpoint location
  SELECT location_lat, location_lng, location_tolerance_meters
  INTO checkpoint_lat, checkpoint_lng, tolerance
  FROM patrol_checkpoints
  WHERE id = NEW.checkpoint_id;

  -- Calculate if GPS is provided and checkpoint has coordinates
  IF NEW.gps_lat IS NOT NULL AND NEW.gps_lng IS NOT NULL
     AND checkpoint_lat IS NOT NULL AND checkpoint_lng IS NOT NULL THEN
    distance := calculate_gps_distance_meters(checkpoint_lat, checkpoint_lng, NEW.gps_lat, NEW.gps_lng);
    NEW.gps_within_tolerance := distance <= COALESCE(tolerance, 50);
  ELSE
    NEW.gps_within_tolerance := NULL;  -- Cannot validate
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER patrol_checkpoint_validate_gps
  BEFORE INSERT ON patrol_checkpoint_logs
  FOR EACH ROW
  EXECUTE FUNCTION validate_checkpoint_gps();

-- RLS
ALTER TABLE patrol_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE patrol_checkpoint_logs ENABLE ROW LEVEL SECURITY;

-- Patrol logs RLS
CREATE POLICY "super_admin_all_patrol_logs" ON patrol_logs FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_patrol_logs" ON patrol_logs FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()));

CREATE POLICY "guards_manage_own_patrol_logs" ON patrol_logs FOR ALL TO authenticated
  USING (
    guard_id IN (SELECT id FROM guards WHERE user_id = auth.uid())
    OR (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    guard_id IN (SELECT id FROM guards WHERE user_id = auth.uid())
    OR (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Patrol checkpoint logs RLS (follows patrol_logs access)
CREATE POLICY "super_admin_all_checkpoint_logs" ON patrol_checkpoint_logs FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_checkpoint_logs" ON patrol_checkpoint_logs FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM patrol_logs pl
    WHERE pl.id = patrol_checkpoint_logs.patrol_log_id
    AND pl.community_id = (SELECT get_current_community_id())
  ));

CREATE POLICY "guards_insert_checkpoint_logs" ON patrol_checkpoint_logs FOR INSERT TO authenticated
  WITH CHECK (EXISTS (
    SELECT 1 FROM patrol_logs pl
    JOIN guards g ON g.id = pl.guard_id
    WHERE pl.id = patrol_checkpoint_logs.patrol_log_id
    AND (g.user_id = auth.uid() OR (SELECT get_current_user_role()) IN ('admin', 'manager'))
  ));

COMMENT ON TABLE patrol_logs IS 'Guard patrol sessions tracking route completion';
COMMENT ON TABLE patrol_checkpoint_logs IS 'Individual NFC checkpoint scans within a patrol';
COMMENT ON COLUMN patrol_checkpoint_logs.nfc_serial_scanned IS 'Actual NFC serial scanned by device - should match checkpoint.nfc_serial';
COMMENT ON COLUMN patrol_checkpoint_logs.gps_within_tolerance IS 'TRUE if guard GPS was within checkpoint tolerance at scan time';
```
  </action>
  <verify>
Verify tables exist:
```sql
SELECT table_name FROM information_schema.tables
WHERE table_name IN ('patrol_logs', 'patrol_checkpoint_logs');
```

Verify progress trigger:
```sql
SELECT tgname FROM pg_trigger WHERE tgrelid = 'patrol_checkpoint_logs'::regclass;
```
Should include: patrol_checkpoint_logged, patrol_checkpoint_validate_gps

Verify functions:
```sql
SELECT routine_name FROM information_schema.routines
WHERE routine_name IN ('update_patrol_progress', 'calculate_gps_distance_meters', 'validate_checkpoint_gps');
```
  </verify>
  <done>patrol_logs and patrol_checkpoint_logs tables exist with progress trigger and GPS validation</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all tables (4):
```sql
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('patrol_checkpoints', 'patrol_routes', 'patrol_logs', 'patrol_checkpoint_logs');
```

2. Verify NFC serial constraint:
```sql
-- Should fail: duplicate NFC serial in same community
INSERT INTO patrol_checkpoints (community_id, nfc_serial, name) VALUES ('test-uuid', '04:A2:E5:1A', 'Test 1');
INSERT INTO patrol_checkpoints (community_id, nfc_serial, name) VALUES ('test-uuid', '04:A2:E5:1A', 'Test 2');
```

3. Verify checkpoint sequence validation trigger works:
```sql
-- Should fail: empty checkpoint sequence
INSERT INTO patrol_routes (community_id, name, checkpoint_sequence)
VALUES ('test-uuid', 'Invalid Route', '{}');
```

4. Verify GPS distance function:
```sql
-- Distance from Mexico City to Guadalajara (~450km)
SELECT calculate_gps_distance_meters(19.4326, -99.1332, 20.6597, -103.3496);
-- Should return approximately 450000 meters
```

5. Verify all RLS policies:
```sql
SELECT tablename, policyname FROM pg_policies
WHERE tablename IN ('patrol_checkpoints', 'patrol_routes', 'patrol_logs', 'patrol_checkpoint_logs')
ORDER BY tablename;
```
</verification>

<success_criteria>
- [ ] patrol_checkpoints table has nfc_serial TEXT (not UUID) column
- [ ] patrol_checkpoints has UNIQUE (community_id, nfc_serial) constraint
- [ ] patrol_routes table has checkpoint_sequence UUID[] column
- [ ] patrol_routes has validation trigger ensuring all checkpoints exist in community
- [ ] patrol_logs tracks checkpoints_total and checkpoints_visited
- [ ] patrol_checkpoint_logs has ON DELETE CASCADE from patrol_logs
- [ ] update_patrol_progress() trigger auto-increments visited count
- [ ] calculate_gps_distance_meters() function exists for GPS validation
- [ ] gps_within_tolerance is auto-calculated on checkpoint scan
- [ ] All 4 tables have RLS enabled with appropriate policies
</success_criteria>

<output>
After completion, create `.planning/phases/03-access-control-security/03-03-SUMMARY.md`
</output>
