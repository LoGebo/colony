---
phase: 03-access-control-security
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - supabase/migrations/XXXXXX_qr_status_enum.sql
  - supabase/migrations/XXXXXX_qr_codes_table.sql
  - supabase/migrations/XXXXXX_emergency_alerts_tables.sql
autonomous: true

must_haves:
  truths:
    - "QR codes have status (active, used, expired, revoked)"
    - "QR codes contain HMAC-SHA256 signatures for offline verification"
    - "generate_qr_payload() creates signed payloads with expiry"
    - "verify_qr_payload() validates signatures and expiry offline"
    - "Emergency alerts track state transitions (triggered -> acknowledged -> responding -> on_scene -> resolved)"
    - "Emergency responders junction table tracks individual guard assignments and arrival times"
    - "Emergency priority auto-sets based on emergency_type"
  artifacts:
    - path: "supabase/migrations/XXXXXX_qr_status_enum.sql"
      provides: "qr_status and emergency_status enum types"
      contains: "CREATE TYPE qr_status"
    - path: "supabase/migrations/XXXXXX_qr_codes_table.sql"
      provides: "qr_codes table with signature functions"
      contains: "generate_qr_payload"
    - path: "supabase/migrations/XXXXXX_emergency_alerts_tables.sql"
      provides: "emergency_alerts and emergency_responders tables"
      contains: "set_emergency_priority"
  key_links:
    - from: "qr_codes"
      to: "invitations"
      via: "invitation_id FK"
      pattern: "REFERENCES invitations\\(id\\)"
    - from: "emergency_alerts"
      to: "access_points"
      via: "access_point_id FK (optional)"
      pattern: "REFERENCES access_points\\(id\\)"
    - from: "emergency_responders"
      to: "guards"
      via: "guard_id FK"
      pattern: "REFERENCES guards\\(id\\)"
---

<objective>
Create QR code system with cryptographic signatures and emergency alert management with dispatch workflow

Purpose: Enable offline QR verification for visitor access and coordinate emergency response with SLA tracking
Output: 2 enum types, 3 tables (qr_codes, emergency_alerts, emergency_responders), 3 functions
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-access-control-security/03-RESEARCH.md
@.planning/phases/03-access-control-security/03-01-SUMMARY.md
@.planning/phases/03-access-control-security/03-02-SUMMARY.md
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QR and emergency status enum types</name>
  <files>supabase/migrations/XXXXXX_qr_status_enum.sql</files>
  <action>
Create migration with timestamp prefix.

Create enum types for QR codes and emergency alerts:

```sql
-- Enable pgcrypto extension for HMAC signatures (if not already enabled)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- QR code lifecycle status
CREATE TYPE qr_status AS ENUM (
  'active',      -- QR code is valid and can be used
  'used',        -- Single-use QR has been scanned (burned)
  'expired',     -- QR code validity period has passed
  'revoked'      -- QR code manually cancelled
);

-- Emergency dispatch lifecycle status
CREATE TYPE emergency_status AS ENUM (
  'triggered',     -- Alert activated (panic button, smoke detector, etc.)
  'acknowledged',  -- Guard/dispatcher has seen the alert
  'responding',    -- Responders are en route
  'on_scene',      -- Responders have arrived
  'resolved',      -- Incident has been handled
  'false_alarm',   -- Determined to be a false alarm
  'escalated'      -- Escalated to external services (police, fire, ambulance)
);

COMMENT ON TYPE qr_status IS 'Lifecycle states for QR codes used in access control';
COMMENT ON TYPE emergency_status IS 'State machine for emergency alert dispatch workflow';
```

Note: emergency_type enum already exists from Phase 1 (01-02-SUMMARY.md) with values: panic, medical, fire, intrusion, natural_disaster
  </action>
  <verify>
Verify enums exist:
```sql
SELECT typname FROM pg_type WHERE typname IN ('qr_status', 'emergency_status');
```
Should return 2 rows.

Verify pgcrypto extension:
```sql
SELECT extname FROM pg_extension WHERE extname = 'pgcrypto';
```
  </verify>
  <done>qr_status and emergency_status enums exist, pgcrypto extension enabled</done>
</task>

<task type="auto">
  <name>Task 2: Create qr_codes table with signature functions</name>
  <files>supabase/migrations/XXXXXX_qr_codes_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create qr_codes table and HMAC signature functions:

```sql
CREATE TABLE qr_codes (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Link to invitation or direct resident access
  invitation_id UUID REFERENCES invitations(id) ON DELETE CASCADE,
  resident_id UUID REFERENCES residents(id) ON DELETE CASCADE,

  -- Payload that gets encoded in QR (format: id|community_id|expiry_epoch|signature)
  payload TEXT NOT NULL,

  -- Cryptographic signature (HMAC-SHA256)
  signature TEXT NOT NULL,

  -- Validity period
  valid_from TIMESTAMPTZ NOT NULL DEFAULT now(),
  valid_until TIMESTAMPTZ NOT NULL,

  -- Status tracking
  status qr_status NOT NULL DEFAULT 'active',
  scanned_at TIMESTAMPTZ,
  scanned_by UUID REFERENCES guards(id) ON DELETE SET NULL,
  scanned_at_access_point UUID REFERENCES access_points(id) ON DELETE SET NULL,

  -- Single-use tracking
  is_single_use BOOLEAN NOT NULL DEFAULT true,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),

  -- At least one of invitation_id or resident_id required
  CONSTRAINT qr_must_have_owner CHECK (
    invitation_id IS NOT NULL OR resident_id IS NOT NULL
  )
);

-- Indexes
CREATE INDEX idx_qr_codes_community ON qr_codes(community_id);
CREATE INDEX idx_qr_codes_invitation ON qr_codes(invitation_id) WHERE status = 'active';
CREATE INDEX idx_qr_codes_resident ON qr_codes(resident_id) WHERE status = 'active';
CREATE INDEX idx_qr_codes_status ON qr_codes(community_id, status, valid_until);

-- Function to generate signed QR payload
-- IMPORTANT: secret_key should come from Supabase Vault or environment, never from regular tables
CREATE OR REPLACE FUNCTION generate_qr_payload(
  qr_id UUID,
  comm_id UUID,
  expires_at TIMESTAMPTZ,
  secret_key TEXT
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  data_to_sign TEXT;
  signature TEXT;
BEGIN
  -- Data format: id|community_id|expiry_epoch
  data_to_sign := qr_id::TEXT || '|' || comm_id::TEXT || '|' || EXTRACT(EPOCH FROM expires_at)::BIGINT::TEXT;

  -- HMAC-SHA256 signature (base64 encoded)
  signature := encode(
    hmac(data_to_sign::bytea, secret_key::bytea, 'sha256'),
    'base64'
  );

  -- Return payload with signature appended: id|community_id|expiry|signature
  RETURN data_to_sign || '|' || signature;
END;
$$;

-- Function to verify QR payload (used offline on guard devices via PowerSync)
CREATE OR REPLACE FUNCTION verify_qr_payload(
  payload TEXT,
  secret_key TEXT
)
RETURNS TABLE (
  is_valid BOOLEAN,
  qr_id UUID,
  community_id UUID,
  expires_at TIMESTAMPTZ,
  error_message TEXT
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  parts TEXT[];
  data_to_verify TEXT;
  expected_sig TEXT;
  provided_sig TEXT;
  expiry_epoch BIGINT;
  v_qr_id UUID;
  v_community_id UUID;
  v_expires_at TIMESTAMPTZ;
BEGIN
  -- Parse payload: id|community_id|expiry|signature
  parts := string_to_array(payload, '|');

  IF array_length(parts, 1) != 4 THEN
    RETURN QUERY SELECT FALSE, NULL::UUID, NULL::UUID, NULL::TIMESTAMPTZ, 'Invalid payload format: expected 4 parts';
    RETURN;
  END IF;

  -- Extract components
  BEGIN
    v_qr_id := parts[1]::UUID;
    v_community_id := parts[2]::UUID;
    expiry_epoch := parts[3]::BIGINT;
    provided_sig := parts[4];
  EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT FALSE, NULL::UUID, NULL::UUID, NULL::TIMESTAMPTZ, 'Invalid payload format: parse error';
    RETURN;
  END;

  -- Reconstruct data and compute expected signature
  data_to_verify := parts[1] || '|' || parts[2] || '|' || parts[3];
  expected_sig := encode(hmac(data_to_verify::bytea, secret_key::bytea, 'sha256'), 'base64');

  -- Verify signature (constant-time comparison would be better but not critical for this use case)
  IF expected_sig != provided_sig THEN
    RETURN QUERY SELECT FALSE, v_qr_id, v_community_id, NULL::TIMESTAMPTZ, 'Invalid signature';
    RETURN;
  END IF;

  -- Check expiry
  v_expires_at := to_timestamp(expiry_epoch);
  IF v_expires_at < now() THEN
    RETURN QUERY SELECT FALSE, v_qr_id, v_community_id, v_expires_at, 'QR code expired';
    RETURN;
  END IF;

  -- Valid!
  RETURN QUERY SELECT TRUE, v_qr_id, v_community_id, v_expires_at, NULL::TEXT;
END;
$$;

-- Function to burn (use) a single-use QR code
CREATE OR REPLACE FUNCTION burn_qr_code(
  p_qr_id UUID,
  p_guard_id UUID DEFAULT NULL,
  p_access_point_id UUID DEFAULT NULL
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_is_single_use BOOLEAN;
  v_status public.qr_status;
BEGIN
  -- Get QR code details
  SELECT is_single_use, status INTO v_is_single_use, v_status
  FROM public.qr_codes WHERE id = p_qr_id;

  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;

  IF v_status != 'active' THEN
    RETURN FALSE;
  END IF;

  -- Update QR code
  UPDATE public.qr_codes
  SET status = CASE WHEN v_is_single_use THEN 'used'::public.qr_status ELSE status END,
      scanned_at = now(),
      scanned_by = p_guard_id,
      scanned_at_access_point = p_access_point_id
  WHERE id = p_qr_id;

  RETURN TRUE;
END;
$$;

-- RLS
ALTER TABLE qr_codes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_qr_codes" ON qr_codes FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

-- Residents can view QR codes for their invitations
CREATE POLICY "residents_view_own_qr_codes" ON qr_codes FOR SELECT TO authenticated
  USING (
    resident_id = auth.uid()
    OR invitation_id IN (SELECT id FROM invitations WHERE created_by_resident_id = auth.uid())
  );

-- Guards can view active QR codes for validation
CREATE POLICY "guards_view_qr_codes" ON qr_codes FOR SELECT TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
  );

-- Admins can manage QR codes
CREATE POLICY "admins_manage_qr_codes" ON qr_codes FOR ALL TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Add FK from access_logs to qr_codes (was forward reference in 03-02)
ALTER TABLE access_logs
  ADD CONSTRAINT access_logs_qr_code_fk
  FOREIGN KEY (qr_code_id) REFERENCES qr_codes(id) ON DELETE SET NULL;

COMMENT ON TABLE qr_codes IS 'QR codes with HMAC-SHA256 signatures for offline verification';
COMMENT ON COLUMN qr_codes.payload IS 'Encoded payload format: qr_id|community_id|expiry_epoch|hmac_signature';
COMMENT ON FUNCTION generate_qr_payload IS 'Generates HMAC-signed QR payload. secret_key must come from Vault, not regular tables.';
COMMENT ON FUNCTION verify_qr_payload IS 'Verifies QR signature and expiry. Can run offline via PowerSync with cached key.';
```
  </action>
  <verify>
Verify table exists:
```sql
SELECT column_name FROM information_schema.columns WHERE table_name = 'qr_codes';
```

Verify functions:
```sql
SELECT routine_name FROM information_schema.routines
WHERE routine_name IN ('generate_qr_payload', 'verify_qr_payload', 'burn_qr_code');
```
Should return 3 rows.

Test signature generation and verification:
```sql
-- Generate a payload
SELECT generate_qr_payload(
  'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::UUID,
  'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::UUID,
  now() + interval '1 hour',
  'test-secret-key-minimum-32-chars!'
);

-- Verify a payload
SELECT * FROM verify_qr_payload(
  'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11|b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11|' || EXTRACT(EPOCH FROM now() + interval '1 hour')::BIGINT || '|SIGNATURE_HERE',
  'test-secret-key-minimum-32-chars!'
);
```
  </verify>
  <done>qr_codes table exists with generate_qr_payload(), verify_qr_payload(), and burn_qr_code() functions</done>
</task>

<task type="auto">
  <name>Task 3: Create emergency_alerts and emergency_responders tables</name>
  <files>supabase/migrations/XXXXXX_emergency_alerts_tables.sql</files>
  <action>
Create migration with timestamp prefix.

Create emergency alert system with dispatch tracking:

```sql
CREATE TABLE emergency_alerts (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Alert type (uses emergency_type enum from Phase 1: panic, medical, fire, intrusion, natural_disaster)
  emergency_type emergency_type NOT NULL,
  priority priority_level NOT NULL DEFAULT 'critical',

  -- Who triggered the alert
  triggered_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  triggered_by_name TEXT,                  -- Denormalized for reports
  triggered_by_unit_id UUID REFERENCES units(id) ON DELETE SET NULL,

  -- Location information
  location_description TEXT,
  location_lat NUMERIC(10, 7),
  location_lng NUMERIC(10, 7),
  access_point_id UUID REFERENCES access_points(id) ON DELETE SET NULL,

  -- Current status (state machine)
  status emergency_status NOT NULL DEFAULT 'triggered',

  -- Timestamps for SLA tracking
  triggered_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  acknowledged_at TIMESTAMPTZ,
  acknowledged_by UUID REFERENCES guards(id) ON DELETE SET NULL,
  response_started_at TIMESTAMPTZ,         -- When first responder departed
  on_scene_at TIMESTAMPTZ,                 -- When first responder arrived
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  -- Resolution details
  resolution_type TEXT CHECK (resolution_type IS NULL OR resolution_type IN ('handled', 'false_alarm', 'escalated_911', 'escalated_other')),
  resolution_notes TEXT,

  -- External escalation
  escalated_to_911 BOOLEAN NOT NULL DEFAULT FALSE,
  escalated_at TIMESTAMPTZ,
  external_reference TEXT,                 -- Police report number, incident number, etc.

  -- Evidence
  photos TEXT[],                           -- Array of Storage URLs
  audio_recording_url TEXT,                -- If panic button records audio

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
  -- No deleted_at - emergency records are permanent audit trail
);

-- Responders assigned to an emergency (junction table for many-to-many)
CREATE TABLE emergency_responders (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  emergency_alert_id UUID NOT NULL REFERENCES emergency_alerts(id) ON DELETE CASCADE,

  guard_id UUID NOT NULL REFERENCES guards(id) ON DELETE RESTRICT,

  -- Assignment details
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  assigned_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  -- Response tracking (individual guard times)
  acknowledged_at TIMESTAMPTZ,             -- When this guard acknowledged
  departed_at TIMESTAMPTZ,                 -- When this guard started moving
  arrived_at TIMESTAMPTZ,                  -- When this guard arrived on scene

  -- Status of this responder
  status TEXT NOT NULL DEFAULT 'assigned' CHECK (status IN ('assigned', 'en_route', 'on_scene', 'completed')),

  notes TEXT,

  -- Prevent same guard assigned twice to same emergency
  CONSTRAINT responder_unique UNIQUE (emergency_alert_id, guard_id)
);

-- Indexes
CREATE INDEX idx_emergencies_community ON emergency_alerts(community_id);
CREATE INDEX idx_emergencies_active ON emergency_alerts(community_id, status, triggered_at DESC)
  WHERE status NOT IN ('resolved', 'false_alarm');
CREATE INDEX idx_emergencies_status ON emergency_alerts(status, triggered_at DESC);
CREATE INDEX idx_emergencies_type ON emergency_alerts(community_id, emergency_type, triggered_at DESC);

CREATE INDEX idx_emergency_responders_alert ON emergency_responders(emergency_alert_id);
CREATE INDEX idx_emergency_responders_guard ON emergency_responders(guard_id);

-- Audit trigger for emergency_alerts
CREATE TRIGGER emergency_alerts_audit
  BEFORE INSERT OR UPDATE ON emergency_alerts
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Trigger to auto-set priority based on emergency type
CREATE OR REPLACE FUNCTION set_emergency_priority()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Only set if not explicitly provided
  IF NEW.priority IS NULL OR TG_OP = 'INSERT' THEN
    NEW.priority := CASE NEW.emergency_type
      WHEN 'panic' THEN 'critical'::priority_level
      WHEN 'fire' THEN 'critical'::priority_level
      WHEN 'natural_disaster' THEN 'critical'::priority_level
      WHEN 'medical' THEN 'urgent'::priority_level
      WHEN 'intrusion' THEN 'high'::priority_level
      ELSE 'high'::priority_level
    END;
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER emergency_set_priority
  BEFORE INSERT ON emergency_alerts
  FOR EACH ROW
  EXECUTE FUNCTION set_emergency_priority();

-- Trigger to update emergency_alerts timestamps based on responder status changes
CREATE OR REPLACE FUNCTION update_emergency_timeline()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Update response_started_at when first responder departs
  IF NEW.departed_at IS NOT NULL AND OLD.departed_at IS NULL THEN
    UPDATE emergency_alerts
    SET response_started_at = COALESCE(response_started_at, NEW.departed_at)
    WHERE id = NEW.emergency_alert_id;
  END IF;

  -- Update on_scene_at when first responder arrives
  IF NEW.arrived_at IS NOT NULL AND OLD.arrived_at IS NULL THEN
    UPDATE emergency_alerts
    SET on_scene_at = COALESCE(on_scene_at, NEW.arrived_at),
        status = CASE WHEN status = 'responding' THEN 'on_scene'::emergency_status ELSE status END
    WHERE id = NEW.emergency_alert_id;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER emergency_responder_timeline
  AFTER UPDATE ON emergency_responders
  FOR EACH ROW
  EXECUTE FUNCTION update_emergency_timeline();

-- Function to calculate SLA metrics for an emergency
CREATE OR REPLACE FUNCTION get_emergency_sla_metrics(p_emergency_id UUID)
RETURNS TABLE (
  time_to_acknowledge INTERVAL,
  time_to_respond INTERVAL,
  time_to_arrive INTERVAL,
  time_to_resolve INTERVAL
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT
    acknowledged_at - triggered_at AS time_to_acknowledge,
    response_started_at - triggered_at AS time_to_respond,
    on_scene_at - triggered_at AS time_to_arrive,
    resolved_at - triggered_at AS time_to_resolve
  FROM public.emergency_alerts
  WHERE id = p_emergency_id;
$$;

-- RLS
ALTER TABLE emergency_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE emergency_responders ENABLE ROW LEVEL SECURITY;

-- Emergency alerts RLS
CREATE POLICY "super_admin_all_emergencies" ON emergency_alerts FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_own_community_emergencies" ON emergency_alerts FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()));

-- Any authenticated user can trigger emergency (panic button)
CREATE POLICY "users_trigger_emergencies" ON emergency_alerts FOR INSERT TO authenticated
  WITH CHECK (community_id = (SELECT get_current_community_id()));

-- Guards and admins can update emergency status
CREATE POLICY "staff_update_emergencies" ON emergency_alerts FOR UPDATE TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
  );

-- Emergency responders RLS
CREATE POLICY "super_admin_all_responders" ON emergency_responders FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

CREATE POLICY "users_view_responders" ON emergency_responders FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM emergency_alerts ea
    WHERE ea.id = emergency_responders.emergency_alert_id
    AND ea.community_id = (SELECT get_current_community_id())
  ));

CREATE POLICY "staff_manage_responders" ON emergency_responders FOR ALL TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM emergency_alerts ea
      WHERE ea.id = emergency_responders.emergency_alert_id
      AND ea.community_id = (SELECT get_current_community_id())
      AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM emergency_alerts ea
      WHERE ea.id = emergency_responders.emergency_alert_id
      AND ea.community_id = (SELECT get_current_community_id())
      AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
    )
  );

COMMENT ON TABLE emergency_alerts IS 'Emergency incidents with state machine workflow and SLA tracking';
COMMENT ON TABLE emergency_responders IS 'Guards assigned to respond to emergencies with individual timing';
COMMENT ON COLUMN emergency_alerts.status IS 'State machine: triggered -> acknowledged -> responding -> on_scene -> resolved/false_alarm/escalated';
COMMENT ON FUNCTION get_emergency_sla_metrics IS 'Returns SLA intervals for reporting (time to acknowledge, respond, arrive, resolve)';
```
  </action>
  <verify>
Verify tables exist:
```sql
SELECT table_name FROM information_schema.tables
WHERE table_name IN ('emergency_alerts', 'emergency_responders');
```

Verify triggers:
```sql
SELECT tgname, tgrelid::regclass FROM pg_trigger
WHERE tgname IN ('emergency_set_priority', 'emergency_responder_timeline');
```

Verify functions:
```sql
SELECT routine_name FROM information_schema.routines
WHERE routine_name IN ('set_emergency_priority', 'update_emergency_timeline', 'get_emergency_sla_metrics');
```

Test priority auto-set:
```sql
-- Insert without priority, should get 'critical' for panic
INSERT INTO emergency_alerts (community_id, emergency_type, triggered_by_name, location_description)
VALUES ('test-uuid', 'panic', 'Test User', 'Main Lobby');
SELECT priority FROM emergency_alerts WHERE triggered_by_name = 'Test User';
-- Should return 'critical'
```
  </verify>
  <done>emergency_alerts and emergency_responders tables exist with priority trigger, timeline updates, and SLA metrics function</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all new tables (3):
```sql
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('qr_codes', 'emergency_alerts', 'emergency_responders');
```

2. Verify enum types:
```sql
SELECT typname, enumlabel FROM pg_enum e JOIN pg_type t ON e.enumtypid = t.oid
WHERE typname IN ('qr_status', 'emergency_status') ORDER BY typname, enumsortorder;
```

3. Test QR signature round-trip:
```sql
-- Generate and immediately verify
WITH gen AS (
  SELECT generate_qr_payload(
    'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::UUID,
    'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'::UUID,
    now() + interval '1 hour',
    'test-secret-key-minimum-32-chars!'
  ) as payload
)
SELECT * FROM verify_qr_payload((SELECT payload FROM gen), 'test-secret-key-minimum-32-chars!');
-- is_valid should be TRUE
```

4. Verify emergency priority auto-assignment works for all types:
```sql
SELECT emergency_type, priority FROM (
  VALUES ('panic'), ('fire'), ('medical'), ('intrusion'), ('natural_disaster')
) AS types(emergency_type)
CROSS JOIN LATERAL (
  SELECT CASE types.emergency_type::emergency_type
    WHEN 'panic' THEN 'critical'
    WHEN 'fire' THEN 'critical'
    WHEN 'natural_disaster' THEN 'critical'
    WHEN 'medical' THEN 'urgent'
    WHEN 'intrusion' THEN 'high'
  END AS priority
) p;
```

5. Verify FK from access_logs to qr_codes:
```sql
SELECT conname FROM pg_constraint
WHERE conrelid = 'access_logs'::regclass AND conname = 'access_logs_qr_code_fk';
```
</verification>

<success_criteria>
- [ ] qr_status enum has 4 values (active, used, expired, revoked)
- [ ] emergency_status enum has 7 values (triggered, acknowledged, responding, on_scene, resolved, false_alarm, escalated)
- [ ] qr_codes table exists with payload, signature, and status columns
- [ ] generate_qr_payload() creates HMAC-SHA256 signed payloads
- [ ] verify_qr_payload() returns validation result with error messages
- [ ] burn_qr_code() marks single-use codes as 'used'
- [ ] access_logs.qr_code_id FK to qr_codes established
- [ ] emergency_alerts has SLA timestamp columns (triggered_at through resolved_at)
- [ ] emergency_responders tracks individual guard response times
- [ ] set_emergency_priority() trigger auto-sets priority based on type
- [ ] update_emergency_timeline() trigger updates alert timestamps from responder changes
- [ ] get_emergency_sla_metrics() function returns response time intervals
- [ ] All 3 tables have RLS enabled with appropriate policies
</success_criteria>

<output>
After completion, create `.planning/phases/03-access-control-security/03-04-SUMMARY.md`
</output>
