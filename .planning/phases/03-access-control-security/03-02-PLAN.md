---
phase: 03-access-control-security
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - supabase/migrations/XXXXXX_invitation_type_enum.sql
  - supabase/migrations/XXXXXX_invitations_table.sql
  - supabase/migrations/XXXXXX_access_logs_table.sql
  - supabase/migrations/XXXXXX_blacklist_table.sql
autonomous: true

must_haves:
  truths:
    - "Invitations can be created with type (single_use, event, recurring, vehicle_preauth)"
    - "Single-use invitations have max_uses = 1 enforced by CHECK constraint"
    - "Event invitations require valid_from and valid_until dates"
    - "Recurring invitations have day-of-week pattern and time windows"
    - "Vehicle pre-auth invitations require plate number"
    - "is_invitation_valid() function validates invitations at access time"
    - "Access logs cannot be updated or deleted (trigger-enforced immutability)"
    - "Blacklist entries support deny_entry, alert_only, call_police protocols"
    - "is_blacklisted() function checks name, document, and plate"
  artifacts:
    - path: "supabase/migrations/XXXXXX_invitation_type_enum.sql"
      provides: "invitation_type enum"
      contains: "CREATE TYPE invitation_type"
    - path: "supabase/migrations/XXXXXX_invitations_table.sql"
      provides: "invitations table with polymorphic validation"
      contains: "is_invitation_valid"
    - path: "supabase/migrations/XXXXXX_access_logs_table.sql"
      provides: "immutable access_logs table with BRIN index"
      contains: "prevent_access_log_modification"
    - path: "supabase/migrations/XXXXXX_blacklist_table.sql"
      provides: "blacklist_entries table with is_blacklisted function"
      contains: "is_blacklisted"
  key_links:
    - from: "invitations"
      to: "residents"
      via: "created_by_resident_id FK"
      pattern: "REFERENCES residents\\(id\\)"
    - from: "access_logs"
      to: "access_points"
      via: "access_point_id FK"
      pattern: "REFERENCES access_points\\(id\\)"
    - from: "access_logs"
      to: "invitations"
      via: "invitation_id FK"
      pattern: "REFERENCES invitations\\(id\\)"
---

<objective>
Create visitor management and access logging - invitations with polymorphic types, immutable access logs, and blacklist management

Purpose: Enable visitor authorization workflow and create tamper-proof audit trail of all access events
Output: 1 enum type, 3 tables (invitations, access_logs, blacklist_entries), 2 validation functions
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-access-control-security/03-RESEARCH.md
@.planning/phases/03-access-control-security/03-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invitation_type enum and invitations table</name>
  <files>supabase/migrations/XXXXXX_invitation_type_enum.sql, supabase/migrations/XXXXXX_invitations_table.sql</files>
  <action>
Create two migrations with timestamp prefixes.

**Migration 1: Enum type**

```sql
-- Invitation types for visitor access
CREATE TYPE invitation_type AS ENUM (
  'single_use',     -- One-time entry, burns after use
  'event',          -- Valid for specific date/time window (party, meeting)
  'recurring',      -- Regular visits (housekeeper, trainer, nurse)
  'vehicle_preauth' -- Pre-authorized vehicle by plate (delivery, Uber)
);

COMMENT ON TYPE invitation_type IS 'Types of visitor invitations with different validation rules';
```

**Migration 2: Invitations table with polymorphic validation**

```sql
CREATE TABLE invitations (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Who created the invitation (resident authorizing visitor)
  created_by_resident_id UUID NOT NULL REFERENCES residents(id) ON DELETE RESTRICT,
  unit_id UUID REFERENCES units(id) ON DELETE SET NULL,

  -- Invitation type determines validation rules
  invitation_type invitation_type NOT NULL,

  -- Visitor identification
  visitor_name TEXT NOT NULL,
  visitor_document TEXT,                   -- ID number if known in advance
  visitor_phone phone_number,
  visitor_email TEXT,
  visitor_company TEXT,                    -- Company/organization name

  -- Vehicle pre-authorization (for vehicle_preauth type)
  vehicle_plate TEXT,
  vehicle_plate_normalized TEXT GENERATED ALWAYS AS (
    UPPER(REGEXP_REPLACE(vehicle_plate, '[^A-Z0-9]', '', 'g'))
  ) STORED,
  vehicle_make TEXT,
  vehicle_model TEXT,
  vehicle_color TEXT,

  -- Validity window
  valid_from TIMESTAMPTZ NOT NULL DEFAULT now(),
  valid_until TIMESTAMPTZ,                 -- NULL for recurring with no end date

  -- Recurring pattern (for recurring type)
  -- Array of day-of-week: 0=Sun, 1=Mon, ..., 6=Sat
  recurring_days INTEGER[],
  recurring_start_time TIME,               -- e.g., 08:00
  recurring_end_time TIME,                 -- e.g., 18:00

  -- Event details (for event type)
  event_name TEXT,
  event_max_guests INTEGER,
  event_guests_checked_in INTEGER NOT NULL DEFAULT 0,

  -- Usage tracking
  max_uses INTEGER DEFAULT 1,              -- NULL for unlimited
  times_used INTEGER NOT NULL DEFAULT 0,
  last_used_at TIMESTAMPTZ,

  -- Status (invitations auto-approved by resident, admin can override)
  status approval_status NOT NULL DEFAULT 'approved',
  cancelled_at TIMESTAMPTZ,
  cancelled_by UUID REFERENCES auth.users(id),
  cancellation_reason TEXT,

  -- Access restrictions
  allowed_access_points UUID[],            -- NULL means all points allowed
  requires_photo BOOLEAN NOT NULL DEFAULT false,
  requires_document BOOLEAN NOT NULL DEFAULT false,

  -- Notes for guards
  special_instructions TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  -- Type-specific constraints (polymorphic validation)
  CONSTRAINT single_use_has_max_1 CHECK (
    invitation_type != 'single_use' OR max_uses = 1
  ),
  CONSTRAINT event_has_dates CHECK (
    invitation_type != 'event' OR (valid_from IS NOT NULL AND valid_until IS NOT NULL)
  ),
  CONSTRAINT recurring_has_pattern CHECK (
    invitation_type != 'recurring' OR recurring_days IS NOT NULL
  ),
  CONSTRAINT vehicle_has_plate CHECK (
    invitation_type != 'vehicle_preauth' OR vehicle_plate IS NOT NULL
  ),
  CONSTRAINT recurring_days_valid CHECK (
    recurring_days IS NULL OR (
      array_length(recurring_days, 1) > 0 AND
      recurring_days <@ ARRAY[0,1,2,3,4,5,6]
    )
  )
);

-- Indexes
CREATE INDEX idx_invitations_community ON invitations(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_invitations_resident ON invitations(created_by_resident_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_invitations_valid ON invitations(community_id, valid_from, valid_until)
  WHERE status = 'approved' AND deleted_at IS NULL AND cancelled_at IS NULL;
CREATE INDEX idx_invitations_plate ON invitations(vehicle_plate_normalized)
  WHERE vehicle_plate_normalized IS NOT NULL AND status = 'approved' AND deleted_at IS NULL;

-- Audit trigger
CREATE TRIGGER invitations_audit
  BEFORE INSERT OR UPDATE ON invitations
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Validation function for invitation use at access time
CREATE OR REPLACE FUNCTION is_invitation_valid(
  inv_id UUID,
  check_time TIMESTAMPTZ DEFAULT now()
)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  inv RECORD;
  day_of_week INTEGER;
BEGIN
  SELECT * INTO inv FROM public.invitations WHERE id = inv_id AND deleted_at IS NULL;

  IF NOT FOUND THEN RETURN FALSE; END IF;
  IF inv.status != 'approved' THEN RETURN FALSE; END IF;
  IF inv.cancelled_at IS NOT NULL THEN RETURN FALSE; END IF;

  -- Check time window
  IF inv.valid_from > check_time THEN RETURN FALSE; END IF;
  IF inv.valid_until IS NOT NULL AND inv.valid_until < check_time THEN RETURN FALSE; END IF;

  -- Check max uses
  IF inv.max_uses IS NOT NULL AND inv.times_used >= inv.max_uses THEN RETURN FALSE; END IF;

  -- Type-specific validation
  CASE inv.invitation_type
    WHEN 'recurring' THEN
      day_of_week := EXTRACT(DOW FROM check_time)::INTEGER;
      IF NOT (day_of_week = ANY(inv.recurring_days)) THEN RETURN FALSE; END IF;
      IF inv.recurring_start_time IS NOT NULL AND check_time::TIME < inv.recurring_start_time THEN RETURN FALSE; END IF;
      IF inv.recurring_end_time IS NOT NULL AND check_time::TIME > inv.recurring_end_time THEN RETURN FALSE; END IF;
    WHEN 'event' THEN
      IF inv.event_max_guests IS NOT NULL AND inv.event_guests_checked_in >= inv.event_max_guests THEN RETURN FALSE; END IF;
    ELSE
      -- single_use and vehicle_preauth: basic checks already done
      NULL;
  END CASE;

  RETURN TRUE;
END;
$$;

-- RLS
ALTER TABLE invitations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_invitations" ON invitations FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

-- Residents can view/manage their own invitations
CREATE POLICY "residents_own_invitations" ON invitations FOR ALL TO authenticated
  USING (
    created_by_resident_id = auth.uid()
    OR community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
  )
  WITH CHECK (
    created_by_resident_id = auth.uid()
    OR (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Guards can view invitations for access validation
CREATE POLICY "guards_view_invitations" ON invitations FOR SELECT TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) = 'guard'
    AND deleted_at IS NULL
  );
```

Add comments for table and columns explaining polymorphic invitation pattern.
  </action>
  <verify>
Verify enum exists:
```sql
SELECT enumlabel FROM pg_enum e JOIN pg_type t ON e.enumtypid = t.oid
WHERE typname = 'invitation_type' ORDER BY enumsortorder;
```

Verify table and constraints:
```sql
SELECT conname FROM pg_constraint WHERE conrelid = 'invitations'::regclass AND contype = 'c';
```
Should show: single_use_has_max_1, event_has_dates, recurring_has_pattern, vehicle_has_plate, recurring_days_valid

Verify function:
```sql
SELECT routine_name FROM information_schema.routines WHERE routine_name = 'is_invitation_valid';
```
  </verify>
  <done>invitation_type enum, invitations table with CHECK constraints, and is_invitation_valid() function exist</done>
</task>

<task type="auto">
  <name>Task 2: Create immutable access_logs table</name>
  <files>supabase/migrations/XXXXXX_access_logs_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create access_logs table with trigger-enforced immutability:

```sql
CREATE TABLE access_logs (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,
  access_point_id UUID NOT NULL REFERENCES access_points(id) ON DELETE RESTRICT,

  -- Who/what is accessing (denormalized for historical accuracy)
  person_type TEXT NOT NULL CHECK (person_type IN ('resident', 'visitor', 'guard', 'provider', 'vehicle_only')),
  person_id UUID,                          -- Reference to residents/guards/etc (may be null for unknown visitors)
  person_name TEXT NOT NULL,               -- Denormalized - name at time of access
  person_document TEXT,                    -- ID number shown at access

  -- Vehicle if applicable
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE SET NULL,
  plate_number TEXT,                       -- Plate as registered
  plate_detected TEXT,                     -- LPR detected plate (may differ)

  -- Authorization
  invitation_id UUID REFERENCES invitations(id) ON DELETE SET NULL,
  qr_code_id UUID,                         -- Will reference qr_codes (created in 03-04)

  -- Access details
  direction TEXT NOT NULL CHECK (direction IN ('entry', 'exit')),
  method TEXT NOT NULL CHECK (method IN ('qr_code', 'nfc_tag', 'lpr', 'facial', 'manual', 'intercom', 'remote', 'emergency')),
  decision access_decision NOT NULL,       -- allowed, denied, blocked (from Phase 1 enum)
  denial_reason TEXT,                      -- If denied/blocked, why

  -- Evidence
  photo_url TEXT,                          -- Person photo from camera
  photo_vehicle_url TEXT,                  -- Vehicle photo

  -- Guard who processed (if manual access)
  processed_by UUID REFERENCES guards(id) ON DELETE SET NULL,
  guard_notes TEXT,

  -- Timing (NOT using updated_at - this is immutable)
  logged_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Hash chain for tamper detection
  previous_hash TEXT,
  entry_hash TEXT GENERATED ALWAYS AS (
    encode(sha256(
      (id::TEXT || logged_at::TEXT || person_name || direction || decision::TEXT)::bytea
    ), 'hex')
  ) STORED

  -- NO deleted_at column - access logs are never deleted
  -- NO updated_at column - access logs are never updated
);

-- CRITICAL: Enforce immutability via triggers
CREATE OR REPLACE FUNCTION prevent_access_log_modification()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  RAISE EXCEPTION 'access_logs is append-only: % operations are not allowed', TG_OP;
END;
$$;

CREATE TRIGGER access_logs_immutable_update
  BEFORE UPDATE ON access_logs
  FOR EACH ROW
  EXECUTE FUNCTION prevent_access_log_modification();

CREATE TRIGGER access_logs_immutable_delete
  BEFORE DELETE ON access_logs
  FOR EACH ROW
  EXECUTE FUNCTION prevent_access_log_modification();

-- BRIN index for timestamp queries (1000x smaller than B-tree for time-series)
CREATE INDEX idx_access_logs_timestamp_brin
  ON access_logs USING BRIN (logged_at)
  WITH (pages_per_range = 32);

-- B-tree indexes for specific lookups
CREATE INDEX idx_access_logs_access_point ON access_logs(access_point_id, logged_at DESC);
CREATE INDEX idx_access_logs_person ON access_logs(person_id) WHERE person_id IS NOT NULL;
CREATE INDEX idx_access_logs_community_date ON access_logs(community_id, logged_at DESC);
CREATE INDEX idx_access_logs_invitation ON access_logs(invitation_id) WHERE invitation_id IS NOT NULL;
CREATE INDEX idx_access_logs_plate ON access_logs(plate_detected) WHERE plate_detected IS NOT NULL;

-- RLS (read-only for most users, insert for guards/system)
ALTER TABLE access_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_access_logs" ON access_logs FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

-- Users can view their community's access logs
CREATE POLICY "users_view_own_community_logs" ON access_logs FOR SELECT TO authenticated
  USING (community_id = (SELECT get_current_community_id()));

-- Guards and admins can insert new logs
CREATE POLICY "guards_insert_logs" ON access_logs FOR INSERT TO authenticated
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
  );

-- Residents can see logs related to their visitors
CREATE POLICY "residents_view_visitor_logs" ON access_logs FOR SELECT TO authenticated
  USING (
    invitation_id IN (
      SELECT id FROM invitations WHERE created_by_resident_id = auth.uid()
    )
  );

COMMENT ON TABLE access_logs IS 'Immutable audit trail of all access events. UPDATE and DELETE are blocked by triggers.';
COMMENT ON COLUMN access_logs.entry_hash IS 'SHA-256 hash of key fields for tamper detection';
COMMENT ON COLUMN access_logs.previous_hash IS 'Hash of previous entry for chain verification (optional)';
```

Note: Do NOT attach set_audit_fields() trigger - this table is append-only and has no updated_at.
  </action>
  <verify>
Verify table exists:
```sql
SELECT column_name FROM information_schema.columns WHERE table_name = 'access_logs';
```

Verify immutability triggers:
```sql
SELECT tgname FROM pg_trigger WHERE tgrelid = 'access_logs'::regclass AND tgname LIKE 'access_logs_immutable%';
```
Should return 2 triggers.

Verify BRIN index:
```sql
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'access_logs' AND indexname LIKE '%brin%';
```

Test immutability (should fail):
```sql
-- This should raise an exception
UPDATE access_logs SET person_name = 'Test' WHERE id = '00000000-0000-0000-0000-000000000000';
```
  </verify>
  <done>access_logs table exists with immutability triggers, BRIN index, and hash chain column</done>
</task>

<task type="auto">
  <name>Task 3: Create blacklist_entries table with validation function</name>
  <files>supabase/migrations/XXXXXX_blacklist_table.sql</files>
  <action>
Create migration with timestamp prefix.

Create blacklist_entries table:

```sql
CREATE TABLE blacklist_entries (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,

  -- Who is blacklisted (at least one identifier required)
  person_name TEXT NOT NULL,
  person_document TEXT,                    -- ID number if known
  person_photo_url TEXT,

  -- Vehicle if applicable
  vehicle_plate TEXT,
  vehicle_plate_normalized TEXT GENERATED ALWAYS AS (
    UPPER(REGEXP_REPLACE(vehicle_plate, '[^A-Z0-9]', '', 'g'))
  ) STORED,
  vehicle_description TEXT,

  -- Reason and evidence (Mexican law requires documentation)
  reason TEXT NOT NULL,
  incident_date DATE,
  evidence_photos TEXT[],                  -- Storage URLs
  evidence_documents TEXT[],               -- Police reports, etc.
  incident_description TEXT,

  -- Related records
  related_incident_id UUID,                -- Future: incidents table in Phase 8
  related_access_log_id UUID REFERENCES access_logs(id) ON DELETE SET NULL,

  -- Validity period
  effective_from DATE NOT NULL DEFAULT CURRENT_DATE,
  expires_at DATE,                         -- NULL for permanent ban

  -- Protocol when encountered
  protocol TEXT NOT NULL DEFAULT 'deny_entry' CHECK (protocol IN ('deny_entry', 'alert_only', 'call_police')),
  alert_guards BOOLEAN NOT NULL DEFAULT TRUE,
  notify_admin BOOLEAN NOT NULL DEFAULT TRUE,

  -- Status
  status general_status NOT NULL DEFAULT 'active',

  -- Who added/approved
  created_by UUID NOT NULL REFERENCES auth.users(id),
  approved_by UUID REFERENCES auth.users(id),
  approved_at TIMESTAMPTZ,

  -- If lifted early
  lifted_at TIMESTAMPTZ,
  lifted_by UUID REFERENCES auth.users(id),
  lifted_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_blacklist_active ON blacklist_entries(community_id)
  WHERE status = 'active' AND deleted_at IS NULL AND lifted_at IS NULL;
CREATE INDEX idx_blacklist_plate ON blacklist_entries(vehicle_plate_normalized)
  WHERE vehicle_plate_normalized IS NOT NULL AND status = 'active' AND lifted_at IS NULL;
CREATE INDEX idx_blacklist_document ON blacklist_entries(person_document)
  WHERE person_document IS NOT NULL AND status = 'active' AND lifted_at IS NULL;
CREATE INDEX idx_blacklist_expires ON blacklist_entries(expires_at)
  WHERE expires_at IS NOT NULL AND status = 'active' AND lifted_at IS NULL;

-- Audit trigger
CREATE TRIGGER blacklist_entries_audit
  BEFORE INSERT OR UPDATE ON blacklist_entries
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Function to check if person/vehicle is blacklisted
CREATE OR REPLACE FUNCTION is_blacklisted(
  p_community_id UUID,
  p_person_name TEXT DEFAULT NULL,
  p_person_document TEXT DEFAULT NULL,
  p_plate_normalized TEXT DEFAULT NULL
)
RETURNS TABLE (
  is_blocked BOOLEAN,
  blacklist_id UUID,
  reason TEXT,
  protocol TEXT
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT
    TRUE,
    b.id,
    b.reason,
    b.protocol
  FROM public.blacklist_entries b
  WHERE b.community_id = p_community_id
    AND b.status = 'active'
    AND b.deleted_at IS NULL
    AND b.effective_from <= CURRENT_DATE
    AND (b.expires_at IS NULL OR b.expires_at >= CURRENT_DATE)
    AND b.lifted_at IS NULL
    AND (
      -- Match by name (fuzzy using ILIKE)
      (p_person_name IS NOT NULL AND b.person_name ILIKE '%' || p_person_name || '%')
      -- Match by document (exact)
      OR (p_person_document IS NOT NULL AND b.person_document = p_person_document)
      -- Match by normalized plate (exact)
      OR (p_plate_normalized IS NOT NULL AND b.vehicle_plate_normalized = p_plate_normalized)
    )
  LIMIT 1;
$$;

-- RLS
ALTER TABLE blacklist_entries ENABLE ROW LEVEL SECURITY;

CREATE POLICY "super_admin_all_blacklist" ON blacklist_entries FOR ALL TO authenticated
  USING (is_super_admin()) WITH CHECK (is_super_admin());

-- Guards can view active blacklist entries
CREATE POLICY "staff_view_blacklist" ON blacklist_entries FOR SELECT TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager', 'guard')
    AND deleted_at IS NULL
  );

-- Admins can manage blacklist
CREATE POLICY "admins_manage_blacklist" ON blacklist_entries FOR ALL TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

COMMENT ON TABLE blacklist_entries IS 'Banned persons/vehicles with evidence and configurable response protocols';
COMMENT ON COLUMN blacklist_entries.protocol IS 'Action when encountered: deny_entry (block), alert_only (allow but notify), call_police (block and alert authorities)';
```
  </action>
  <verify>
Verify table exists:
```sql
SELECT column_name FROM information_schema.columns WHERE table_name = 'blacklist_entries';
```

Verify function:
```sql
SELECT routine_name FROM information_schema.routines WHERE routine_name = 'is_blacklisted';
```

Verify protocol constraint:
```sql
SELECT conname, consrc FROM pg_constraint
WHERE conrelid = 'blacklist_entries'::regclass AND contype = 'c' AND conname LIKE '%protocol%';
```
  </verify>
  <done>blacklist_entries table exists with is_blacklisted() function and protocol check constraint</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all tables (3):
```sql
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
AND table_name IN ('invitations', 'access_logs', 'blacklist_entries');
```

2. Verify invitation type constraints work:
```sql
-- Should fail: single_use with max_uses != 1
INSERT INTO invitations (community_id, created_by_resident_id, invitation_type, visitor_name, max_uses)
VALUES ('test-uuid', 'test-uuid', 'single_use', 'Test', 5);

-- Should fail: event without valid_until
INSERT INTO invitations (community_id, created_by_resident_id, invitation_type, visitor_name, valid_from)
VALUES ('test-uuid', 'test-uuid', 'event', 'Test', now());
```

3. Verify access_logs immutability:
```sql
-- Should raise exception
UPDATE access_logs SET person_name = 'Hacked' WHERE TRUE;
DELETE FROM access_logs WHERE TRUE;
```

4. Verify is_invitation_valid function handles recurring:
```sql
-- Test function signature
SELECT is_invitation_valid('00000000-0000-0000-0000-000000000000'::UUID);
```

5. Verify is_blacklisted function returns correct structure:
```sql
SELECT * FROM is_blacklisted('00000000-0000-0000-0000-000000000000'::UUID, 'Test Name');
```
</verification>

<success_criteria>
- [ ] invitation_type enum has 4 values (single_use, event, recurring, vehicle_preauth)
- [ ] invitations table has 5 CHECK constraints for polymorphic validation
- [ ] invitations.vehicle_plate_normalized is generated column
- [ ] is_invitation_valid() function exists and handles all invitation types
- [ ] access_logs table has NO deleted_at or updated_at columns
- [ ] access_logs has prevent_access_log_modification() trigger blocking UPDATE/DELETE
- [ ] access_logs has BRIN index on logged_at
- [ ] access_logs.entry_hash is generated column for tamper detection
- [ ] blacklist_entries has protocol CHECK constraint (deny_entry, alert_only, call_police)
- [ ] is_blacklisted() function checks name, document, and plate
- [ ] All 3 tables have RLS enabled with appropriate policies
</success_criteria>

<output>
After completion, create `.planning/phases/03-access-control-security/03-02-SUMMARY.md`
</output>
