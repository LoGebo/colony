---
phase: 06-maintenance-chat-documents-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_ticket_enums.sql
  - supabase/migrations/TIMESTAMP_ticket_categories.sql
  - supabase/migrations/TIMESTAMP_tickets_sla.sql
autonomous: true

must_haves:
  truths:
    - "Ticket statuses follow state machine with valid transitions only"
    - "SLA definitions vary by category and priority combination"
    - "Response and resolution due dates are auto-computed on ticket creation"
    - "SLA breach flags are set when due dates are exceeded"
    - "Ticket assignments track current and historical assignees"
  artifacts:
    - path: "supabase/migrations/*_ticket_enums.sql"
      provides: "ticket_status, ticket_priority enums"
      contains: "CREATE TYPE ticket_status"
    - path: "supabase/migrations/*_ticket_categories.sql"
      provides: "ticket_categories table with community-specific categories"
      contains: "CREATE TABLE ticket_categories"
    - path: "supabase/migrations/*_tickets_sla.sql"
      provides: "tickets, sla_definitions, ticket_assignments, ticket_comments tables with triggers"
      contains: "CREATE FUNCTION validate_ticket_transition"
  key_links:
    - from: "tickets"
      to: "ticket_categories"
      via: "category_id FK"
    - from: "sla_definitions"
      to: "ticket_categories"
      via: "category_id FK (nullable for catch-all)"
    - from: "set_ticket_sla_dates trigger"
      to: "compute_sla_due_dates function"
      via: "BEFORE INSERT trigger calls function"
---

<objective>
Create ticket categories, tickets with state machine validation, SLA definitions, and assignment workflow for UPOE maintenance system.

Purpose: Establish the core maintenance ticketing system where residents can report issues, tickets flow through controlled status transitions, and SLA tracking ensures timely response and resolution. The state machine prevents invalid transitions (e.g., jumping from 'open' to 'closed'), while SLA definitions per category/priority enable breach detection and escalation.

Output:
- ticket_status (8 states) and ticket_priority (4 levels) enums
- ticket_categories table with community-specific maintenance categories
- sla_definitions table with response/resolution times per category+priority matrix
- tickets table with state machine trigger, SLA tracking, and breach flags
- ticket_assignments table for current and historical assignment tracking
- ticket_comments table for updates, photos, and status change tracking
- validate_ticket_transition() function enforcing valid state transitions
- compute_sla_due_dates() function for SLA calculation
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md
@.planning/phases/02-identity-crm/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ticket enums and categories</name>
  <files>
    supabase/migrations/TIMESTAMP_ticket_enums.sql
    supabase/migrations/TIMESTAMP_ticket_categories.sql
  </files>
  <action>
Create ticket_status enum with 8 states (state machine order):
- open (initial state: ticket created)
- assigned (assigned to staff/provider)
- in_progress (work started)
- pending_parts (waiting for materials)
- pending_resident (waiting for resident action)
- resolved (work completed)
- closed (confirmed by resident/admin - terminal)
- cancelled (cancelled before completion - terminal)

Create ticket_priority enum with 4 levels:
- low (72h response, 7 days resolution)
- medium (24h response, 3 days resolution)
- high (4h response, 24h resolution)
- urgent (1h response, 4h resolution)

Add comments documenting the state machine transitions and typical SLA times.

Create ticket_categories table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL (e.g., 'Plomeria', 'Electricidad', 'Jardineria')
- description TEXT
- icon TEXT (icon name or emoji)
- color TEXT (hex color for UI)
- parent_category_id UUID FK REFERENCES ticket_categories(id) for hierarchy
- default_assignee_id UUID FK REFERENCES auth.users(id)
- escalation_contact_id UUID FK REFERENCES auth.users(id)
- default_response_hours INTEGER (can be overridden in sla_definitions)
- default_resolution_hours INTEGER
- is_active BOOLEAN DEFAULT TRUE
- sort_order INTEGER DEFAULT 0
- Standard audit columns (created_at, updated_at, deleted_at, created_by)
- UNIQUE (community_id, name)

Add RLS policies:
- super_admin_all_ticket_categories
- users_view_ticket_categories (community members can view)
- admins_manage_ticket_categories (admins can INSERT/UPDATE/DELETE)

Attach set_audit_fields trigger.

Add index on community_id + is_active for category list queries.
  </action>
  <verify>
Run migrations via Supabase MCP. Query pg_type for ticket_status and ticket_priority enums. Insert a test category. Verify RLS policies exist.
  </verify>
  <done>
ticket_status (8 values), ticket_priority (4 values) enums exist. ticket_categories table with hierarchy support and RLS policies active.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SLA definitions and tickets table</name>
  <files>
    supabase/migrations/TIMESTAMP_tickets_sla.sql
  </files>
  <action>
Create sla_definitions table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- category_id UUID FK REFERENCES ticket_categories(id) (NULL = applies to all categories)
- priority ticket_priority NOT NULL
- response_minutes INTEGER NOT NULL (time to first response)
- resolution_minutes INTEGER NOT NULL (time to resolution)
- business_hours_only BOOLEAN DEFAULT TRUE (skip nights/weekends)
- escalate_on_breach BOOLEAN DEFAULT TRUE
- escalate_to UUID REFERENCES auth.users(id)
- is_active BOOLEAN DEFAULT TRUE
- Standard audit columns
- UNIQUE (community_id, category_id, priority)

Create compute_sla_due_dates() function:
- Parameters: p_community_id UUID, p_category_id UUID, p_priority ticket_priority, p_created_at TIMESTAMPTZ DEFAULT now()
- RETURNS TABLE(response_due TIMESTAMPTZ, resolution_due TIMESTAMPTZ)
- LANGUAGE plpgsql, STABLE
- Finds matching SLA (specific category first, then NULL category fallback)
- Returns created_at + response_minutes and + resolution_minutes as intervals
- Default fallback if no SLA defined: 24h response, 7d resolution

Create tickets table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- reported_by UUID FK to residents(id) NOT NULL
- unit_id UUID FK to units(id) (nullable)
- category_id UUID FK to ticket_categories(id) NOT NULL
- priority ticket_priority NOT NULL DEFAULT 'medium'
- title TEXT NOT NULL
- description TEXT NOT NULL
- location TEXT (specific location within community)
- status ticket_status NOT NULL DEFAULT 'open'
- status_changed_at TIMESTAMPTZ NOT NULL DEFAULT now()
- response_due_at TIMESTAMPTZ (computed on insert)
- resolution_due_at TIMESTAMPTZ (computed on insert)
- first_responded_at TIMESTAMPTZ (when status first changed from 'open')
- resolved_at TIMESTAMPTZ (when status became 'resolved')
- response_breached BOOLEAN DEFAULT FALSE
- resolution_breached BOOLEAN DEFAULT FALSE
- assigned_to UUID REFERENCES auth.users(id)
- assigned_at TIMESTAMPTZ
- asset_id UUID (FK added in plan 06-02 for assets)
- preventive_schedule_id UUID (FK added in plan 06-02)
- tags TEXT[]
- custom_fields JSONB DEFAULT '{}'
- Standard audit columns

Create validate_ticket_transition() trigger function:
- LANGUAGE plpgsql, SECURITY DEFINER, SET search_path = ''
- Define valid transitions per state using CASE:
  - open -> assigned, cancelled
  - assigned -> in_progress, open, cancelled
  - in_progress -> pending_parts, pending_resident, resolved, assigned
  - pending_parts -> in_progress, cancelled
  - pending_resident -> in_progress, resolved, cancelled
  - resolved -> closed, in_progress (reopen)
  - closed -> (terminal, no transitions)
  - cancelled -> (terminal, no transitions)
- RAISE EXCEPTION on invalid transition
- Update status_changed_at on any status change
- Set first_responded_at when leaving 'open' for first time
- Set resolved_at when entering 'resolved'

Create ticket_transition_trigger BEFORE UPDATE ON tickets.

Create set_ticket_sla_dates() trigger function:
- Calls compute_sla_due_dates() and sets response_due_at and resolution_due_at
- BEFORE INSERT trigger

Create recompute_sla_on_priority_change() trigger function:
- If priority changed, recompute SLA due dates
- BEFORE UPDATE trigger

Create check_sla_breaches() function (for periodic execution):
- Updates response_breached = true where status = 'open' AND response_due_at < now()
- Updates resolution_breached = true where status NOT IN ('resolved','closed','cancelled') AND resolution_due_at < now()
- Calls pg_notify('sla_breach', payload) for each breach

Create notify_sla_breach() trigger:
- AFTER UPDATE on tickets
- When response_breached or resolution_breached changes to true
- Calls pg_notify for real-time alerting

Add RLS policies for tickets and sla_definitions:
- Users can view their community's tickets
- Residents can INSERT tickets (report issues)
- Admins can manage all aspects
- Assigned staff can UPDATE their tickets

Add indexes:
- tickets: community_id + status (open ticket list)
- tickets: assigned_to + status (my assigned tickets)
- tickets: response_due_at WHERE response_breached = false (breach monitoring)
- sla_definitions: community_id + category_id + priority (SLA lookup)

Attach audit triggers.
  </action>
  <verify>
Run migration. Insert test category and SLA definition. Create a ticket and verify SLA due dates are auto-computed. Attempt invalid transition (open -> closed) and verify exception is raised. Attempt valid transition (open -> assigned) and verify it succeeds.
  </verify>
  <done>
sla_definitions table with category/priority matrix. tickets table with state machine trigger blocking invalid transitions. SLA due dates auto-computed on insert. Breach flags and pg_notify for alerts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ticket assignments and comments</name>
  <files>
    supabase/migrations/TIMESTAMP_ticket_assignments_comments.sql
  </files>
  <action>
Create ticket_assignments table (historical assignment tracking):
- id UUID PK (generate_uuid_v7)
- ticket_id UUID FK to tickets(id) ON DELETE CASCADE
- assigned_to UUID FK to auth.users(id) NOT NULL
- assigned_by UUID FK to auth.users(id) NOT NULL
- assigned_at TIMESTAMPTZ DEFAULT now()
- unassigned_at TIMESTAMPTZ (NULL if current assignee)
- notes TEXT (reason for assignment)

Create update_ticket_assigned_to() trigger function:
- When assignment is INSERTed, update tickets.assigned_to and tickets.assigned_at
- If previous assignment exists (current), set its unassigned_at

Create ticket_comments table:
- id UUID PK (generate_uuid_v7)
- ticket_id UUID FK to tickets(id) ON DELETE CASCADE
- author_id UUID FK to auth.users(id) NOT NULL
- author_role TEXT NOT NULL ('reporter', 'assignee', 'admin', 'system')
- content TEXT
- photo_urls TEXT[]
- status_from ticket_status (for status change tracking)
- status_to ticket_status
- is_internal BOOLEAN DEFAULT FALSE (only visible to staff)
- is_system BOOLEAN DEFAULT FALSE (auto-generated)
- system_action TEXT ('status_changed', 'assigned', 'priority_changed')
- system_data JSONB
- created_at TIMESTAMPTZ DEFAULT now()

Create auto_comment_on_status_change() trigger function:
- AFTER UPDATE on tickets when status changes
- Inserts a system comment with status_from, status_to, is_system=true

Create auto_comment_on_assignment() trigger function:
- AFTER UPDATE on tickets when assigned_to changes
- Inserts a system comment with assignment details

Add RLS policies:
- ticket_assignments: admins can manage, users can view their community's
- ticket_comments: users can view (except is_internal unless staff), reporters can INSERT comments, staff can INSERT any

Add indexes:
- ticket_comments: ticket_id + created_at (timeline)
- ticket_assignments: ticket_id + assigned_at (assignment history)

Add comments documenting the auto-comment system.
  </action>
  <verify>
Run migration. Create ticket, assign it via INSERT into ticket_assignments. Verify tickets.assigned_to is updated. Change ticket status and verify system comment is auto-created. Add manual comment and verify it appears in timeline.
  </verify>
  <done>
ticket_assignments table tracks assignment history with auto-sync to tickets table. ticket_comments table captures updates, photos, and auto-generated system comments for status/assignment changes.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('ticket_status', 'ticket_priority')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('ticket_categories', 'sla_definitions', 'tickets', 'ticket_assignments', 'ticket_comments')
3. Test: Create category -> Create SLA -> Create ticket -> Verify SLA dates computed
4. Test: Attempt open->closed transition -> Verify exception raised
5. Test: open->assigned transition -> Verify success, first_responded_at NULL (only set when leaving open to non-cancelled)
6. Test: assigned->in_progress -> Verify first_responded_at set
7. Test: Insert assignment -> Verify tickets.assigned_to updated
8. Test: Change status -> Verify auto system comment created
9. Test: RLS isolates tickets by community
</verification>

<success_criteria>
- ticket_status (8 states) and ticket_priority (4 levels) enums created
- ticket_categories table with hierarchy and community isolation
- sla_definitions with category/priority matrix lookup
- tickets table with state machine validation via trigger
- SLA due dates auto-computed on ticket creation
- Breach detection via check_sla_breaches() with pg_notify
- ticket_assignments with historical tracking and auto-sync
- ticket_comments with system-generated entries for status/assignment changes
- All tables have RLS with community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/06-maintenance-chat-documents-notifications/06-01-SUMMARY.md`
</output>
