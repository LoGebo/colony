---
phase: 06-maintenance-chat-documents-notifications
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_document_enums.sql
  - supabase/migrations/TIMESTAMP_documents.sql
  - supabase/migrations/TIMESTAMP_signatures.sql
autonomous: true

must_haves:
  truths:
    - "Document categories organize legal, assembly, financial, operational files"
    - "Documents use copy-on-write versioning with current_version_id pointer"
    - "Document permissions grant access by user, unit, or role"
    - "Regulation signatures capture timestamp, IP, device fingerprint"
    - "Signatures are immutable with trigger-enforced protection"
    - "SHA-256 hash enables signature tamper detection"
  artifacts:
    - path: "supabase/migrations/*_document_enums.sql"
      provides: "document_category enum"
      contains: "CREATE TYPE document_category"
    - path: "supabase/migrations/*_documents.sql"
      provides: "documents, document_versions, document_permissions tables"
      contains: "CREATE TABLE documents"
    - path: "supabase/migrations/*_signatures.sql"
      provides: "regulation_signatures table with immutability trigger"
      contains: "CREATE FUNCTION prevent_signature_modification"
  key_links:
    - from: "documents"
      to: "document_versions"
      via: "current_version_id FK"
    - from: "document_versions"
      to: "documents"
      via: "document_id FK"
    - from: "regulation_signatures"
      to: "document_versions"
      via: "document_version_id FK (specific version signed)"
---

<objective>
Create document management with versioning, access permissions, and legally-compliant digital signatures for UPOE document repository.

Purpose: Enable administrators to publish community documents (reglamentos, actas de asamblea, estados financieros), track versions over time with audit trail, control access by user/unit/role, and capture legally-valid signatures with ESIGN/UETA-compliant metadata (timestamp, IP, device).

Output:
- document_category enum (5 categories)
- documents table with current_version_id pointer for O(1) latest access
- document_versions table with copy-on-write versioning and checksums
- document_permissions table for granular access control
- regulation_signatures table with immutability enforcement
- verify_signature_hash() function for tamper detection
- Storage bucket configuration for document files
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document enums and base tables</name>
  <files>
    supabase/migrations/TIMESTAMP_document_enums.sql
    supabase/migrations/TIMESTAMP_documents.sql
  </files>
  <action>
Create document_category enum with 5 values:
- legal (reglamento, acta constitutiva, escrituras)
- assembly (actas de asamblea, minutas, acuerdos)
- financial (estados financieros, presupuestos, auditorias)
- operational (manuales, procedimientos, instructivos)
- communication (circulares, avisos, boletines)

Add comments with Spanish examples for each category.

Create documents table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL (display name)
- category document_category NOT NULL
- description TEXT
- current_version_id UUID (FK added after document_versions created)
- is_public BOOLEAN DEFAULT FALSE (visible to all residents)
- required_role user_role (minimum role to view if not public)
- requires_signature BOOLEAN DEFAULT FALSE
- signature_deadline DATE
- tags TEXT[]
- status general_status DEFAULT 'active'
- Standard audit columns

Create document_versions table:
- id UUID PK (generate_uuid_v7)
- document_id UUID FK to documents(id) ON DELETE CASCADE
- version_number INTEGER NOT NULL (auto-incremented per document)
- storage_path TEXT NOT NULL (path in Supabase Storage)
- storage_bucket TEXT DEFAULT 'documents'
- file_name TEXT NOT NULL (original filename)
- file_size_bytes INTEGER
- mime_type TEXT NOT NULL
- checksum TEXT (SHA-256 for integrity verification)
- change_summary TEXT (what changed in this version)
- uploaded_by UUID FK to auth.users(id) NOT NULL
- previous_version_id UUID REFERENCES document_versions(id)
- created_at TIMESTAMPTZ DEFAULT now()
- UNIQUE (document_id, version_number)

Create set_document_version() trigger function:
- BEFORE INSERT on document_versions
- Sets version_number = MAX(version_number) + 1 for document
- Sets previous_version_id to current max version_id

Create update_document_current_version() trigger function:
- AFTER INSERT on document_versions
- Updates documents.current_version_id = NEW.id
- Updates documents.updated_at = now()

Add FK to documents:
- ALTER TABLE documents ADD CONSTRAINT documents_current_version_fk FOREIGN KEY (current_version_id) REFERENCES document_versions(id)

Create upload_document_version() function:
- Parameters: p_document_id UUID, p_storage_path TEXT, p_file_name TEXT, p_file_size INTEGER, p_mime_type TEXT, p_checksum TEXT, p_change_summary TEXT
- Inserts new version with auto-computed version_number
- Returns the new version record

Create get_document_history() function:
- Parameters: p_document_id UUID
- Returns all versions ordered by version_number DESC
- Includes uploader name, created_at, file info

Add RLS policies:
- documents: users view based on is_public, required_role, or document_permissions
- document_versions: same access as parent document

Add indexes:
- documents: community_id + category + status (document list)
- documents: community_id + requires_signature + signature_deadline (pending signatures)
- document_versions: document_id + version_number DESC

Attach audit triggers to documents.
  </action>
  <verify>
Run migration. Create document. Upload first version via INSERT into document_versions. Verify version_number=1, current_version_id updated on document. Upload second version, verify version_number=2, previous_version_id links to v1.
  </verify>
  <done>
document_category enum. documents table with current_version_id pointer. document_versions with auto-incrementing version numbers and version chain. Triggers maintain current version pointer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document permissions</name>
  <files>
    supabase/migrations/TIMESTAMP_document_permissions.sql
  </files>
  <action>
Create document_permissions table:
- id UUID PK (generate_uuid_v7)
- document_id UUID FK to documents(id) ON DELETE CASCADE
- user_id UUID REFERENCES auth.users(id) (grant to specific user)
- unit_id UUID REFERENCES units(id) (grant to all occupants of unit)
- role user_role (grant to all users with this role)
- can_view BOOLEAN DEFAULT TRUE
- can_download BOOLEAN DEFAULT TRUE
- can_edit BOOLEAN DEFAULT FALSE (upload new versions)
- granted_by UUID FK to auth.users(id) NOT NULL
- granted_at TIMESTAMPTZ DEFAULT now()
- expires_at TIMESTAMPTZ
- UNIQUE (document_id, user_id) WHERE user_id IS NOT NULL
- UNIQUE (document_id, unit_id) WHERE unit_id IS NOT NULL
- UNIQUE (document_id, role) WHERE role IS NOT NULL
- CHECK: exactly one of user_id, unit_id, role must be NOT NULL

Create check_document_access() function:
- Parameters: p_document_id UUID, p_user_id UUID, p_permission TEXT DEFAULT 'view'
- RETURNS BOOLEAN
- LANGUAGE plpgsql, STABLE, SECURITY DEFINER
- Check order:
  1. Document is_public = true -> return true for 'view'
  2. Check user's role >= document.required_role
  3. Check document_permissions for user_id match
  4. Check document_permissions for unit_id matching user's units
  5. Check document_permissions for role matching user's role
  6. Check expires_at hasn't passed
- Return appropriate can_view/can_download/can_edit based on p_permission

Create get_accessible_documents() function:
- Parameters: p_user_id UUID
- Returns documents the user can access based on all permission rules
- Used for document list in app

Update documents RLS to use check_document_access():
- SELECT: check_document_access(id, auth.uid(), 'view')
- This allows complex permission logic in a reusable function

Add RLS policies for document_permissions:
- Users can view permissions on documents they can access
- Admins can manage all permissions
- Document owners (uploaded_by of first version) can grant permissions

Add indexes:
- document_permissions: document_id
- document_permissions: user_id
- document_permissions: unit_id
- document_permissions: role

Add comments explaining the permission inheritance model.
  </action>
  <verify>
Run migration. Create document with is_public=false. Create permission for specific user. Test check_document_access() returns true for granted user, false for others. Test unit-based permission. Test role-based permission. Test expiration.
  </verify>
  <done>
document_permissions table with user/unit/role targeting. check_document_access() function for permission evaluation. get_accessible_documents() for filtered document list. RLS uses permission function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create regulation signatures</name>
  <files>
    supabase/migrations/TIMESTAMP_signatures.sql
  </files>
  <action>
Create regulation_signatures table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- document_id UUID FK to documents(id) NOT NULL
- document_version_id UUID FK to document_versions(id) NOT NULL
- resident_id UUID FK to residents(id) NOT NULL
- unit_id UUID REFERENCES units(id)
- signature_type TEXT DEFAULT 'click' ('click', 'draw', 'type')
- signature_data TEXT (Base64 of drawn signature or typed name)
- signed_at TIMESTAMPTZ DEFAULT now()
- ip_address INET NOT NULL
- user_agent TEXT NOT NULL
- device_type TEXT ('mobile', 'tablet', 'desktop')
- browser TEXT
- os TEXT
- screen_resolution TEXT
- device_id TEXT (app-generated unique ID)
- device_model TEXT (e.g., 'iPhone 14 Pro')
- latitude NUMERIC(10,7) (if location consent given)
- longitude NUMERIC(10,7)
- location_accuracy_meters INTEGER
- consent_text TEXT NOT NULL (exact text they agreed to)
- consent_checkbox_id TEXT (DOM element ID for audit)
- signature_hash TEXT NOT NULL (SHA-256 tamper detection)
- created_at TIMESTAMPTZ DEFAULT now()
- NO deleted_at - signatures are permanent

Create compute_signature_hash() function:
- Parameters: p_document_checksum TEXT, p_resident_id UUID, p_signed_at TIMESTAMPTZ, p_ip_address INET
- RETURNS TEXT (SHA-256 hash)
- Computes: encode(sha256((p_document_checksum || p_resident_id || p_signed_at || p_ip_address)::BYTEA), 'hex')

Create set_signature_hash() trigger function:
- BEFORE INSERT on regulation_signatures
- Looks up document_versions.checksum for the version being signed
- Computes and sets NEW.signature_hash using compute_signature_hash()

Create prevent_signature_modification() trigger function:
- BEFORE UPDATE OR DELETE on regulation_signatures
- RAISE EXCEPTION 'Regulation signatures cannot be modified'
- Ensures immutability for legal compliance

Create verify_signature_hash() function:
- Parameters: p_signature_id UUID
- RETURNS BOOLEAN
- Looks up signature and document checksum
- Recomputes expected hash
- Returns true if signature_hash matches
- Used to detect tampering

Create capture_signature() function:
- Parameters: all signature fields
- LANGUAGE plpgsql, SECURITY DEFINER
- Validates resident is signing for their own unit
- Validates document requires_signature = true
- Validates signature_deadline hasn't passed
- Inserts signature record
- Returns signature id

Create get_pending_signatures() function:
- Parameters: p_resident_id UUID
- Returns documents requiring signature that resident hasn't signed
- Checks against signature_deadline

Create get_document_signatures() function:
- Parameters: p_document_id UUID
- Returns all signatures for document with resident info
- For admin signature tracking dashboard

Add RLS policies:
- regulation_signatures: residents can view their own, admins can view all
- No UPDATE/DELETE policies (immutable)
- INSERT via capture_signature() function only

Add indexes:
- regulation_signatures: document_id + document_version_id (who signed what)
- regulation_signatures: resident_id (my signatures)
- regulation_signatures: community_id + signed_at (audit queries)

Create signature_immutable_trigger BEFORE UPDATE OR DELETE.
Create signature_hash_trigger BEFORE INSERT.

Add comments documenting ESIGN/UETA compliance requirements.
  </action>
  <verify>
Run migration. Create document with requires_signature=true. Call capture_signature() with test data. Verify signature_hash is computed. Attempt UPDATE on signature - verify exception raised. Attempt DELETE - verify exception raised. Call verify_signature_hash() - verify returns true.
  </verify>
  <done>
regulation_signatures table with full ESIGN/UETA-compliant metadata. Immutability enforced via trigger. SHA-256 hash for tamper detection. capture_signature() validates and records signatures.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname = 'document_category'
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('documents', 'document_versions', 'document_permissions', 'regulation_signatures')
3. Test: Create document -> Upload version -> Verify version_number=1, current_version_id set
4. Test: Upload second version -> Verify version chain (previous_version_id)
5. Test: Create permission for user -> Verify check_document_access() returns true
6. Test: check_document_access() returns false for unpermitted user
7. Test: capture_signature() creates signature with computed hash
8. Test: UPDATE/DELETE on signature raises exception
9. Test: verify_signature_hash() returns true for valid signature
10. Test: RLS isolates documents by community and permissions
</verification>

<success_criteria>
- document_category enum (5 categories)
- documents table with current_version_id pointer
- document_versions with auto-incrementing versions and checksums
- document_permissions with user/unit/role targeting
- check_document_access() evaluates complex permission rules
- regulation_signatures with full legal metadata
- Signatures are immutable (trigger-enforced)
- SHA-256 hash for tamper detection
- All tables have RLS with appropriate access controls
</success_criteria>

<output>
After completion, create `.planning/phases/06-maintenance-chat-documents-notifications/06-04-SUMMARY.md`
</output>
