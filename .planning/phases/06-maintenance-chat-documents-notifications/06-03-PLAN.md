---
phase: 06-maintenance-chat-documents-notifications
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_chat_enums.sql
  - supabase/migrations/TIMESTAMP_conversations.sql
  - supabase/migrations/TIMESTAMP_messages.sql
autonomous: true

must_haves:
  truths:
    - "Conversations support direct, group, guard_booth, and support types"
    - "Participants have roles (owner, admin, member, guard) with mute settings"
    - "Messages support text, media attachments, replies, and edits"
    - "Read receipts track per-user message read status"
    - "Message reactions use emoji codes with unique constraint per user"
    - "Unread counts are maintained via triggers for efficient queries"
  artifacts:
    - path: "supabase/migrations/*_chat_enums.sql"
      provides: "conversation_type, participant_role enums"
      contains: "CREATE TYPE conversation_type"
    - path: "supabase/migrations/*_conversations.sql"
      provides: "conversations, conversation_participants tables"
      contains: "CREATE TABLE conversations"
    - path: "supabase/migrations/*_messages.sql"
      provides: "messages, message_read_receipts, message_reactions tables"
      contains: "CREATE TABLE messages"
  key_links:
    - from: "conversations"
      to: "communities"
      via: "community_id FK with RLS"
    - from: "messages"
      to: "conversations"
      via: "conversation_id FK"
    - from: "update_conversation_on_message trigger"
      to: "conversation_participants"
      via: "increments unread_count"
---

<objective>
Create real-time chat infrastructure with conversations, participants, messages, read receipts, and reactions for UPOE messaging.

Purpose: Enable communication between residents and guards (guard-booth pattern), direct 1:1 messaging between residents, group conversations, and support channels. The schema is designed for Supabase Realtime Broadcast (ephemeral delivery) with PostgreSQL persistence for message history.

Output:
- conversation_type (4 types) and participant_role (4 roles) enums
- conversations table supporting direct, group, guard_booth, support types
- conversation_participants with roles, mute settings, and unread tracking
- messages table with text, media, replies, edits, and soft delete
- message_read_receipts for per-user read tracking
- message_reactions with emoji support
- quick_responses table for canned guard messages
- Triggers for unread count maintenance and conversation stats
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/03-access-control-security/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat enums and conversations</name>
  <files>
    supabase/migrations/TIMESTAMP_chat_enums.sql
    supabase/migrations/TIMESTAMP_conversations.sql
  </files>
  <action>
Create conversation_type enum with 4 values:
- direct (1:1 between two users)
- group (multi-user named conversation)
- guard_booth (resident <-> guard per shift/gate)
- support (resident <-> admin/management)

Create participant_role enum with 4 values:
- owner (created the conversation, full control)
- admin (can add/remove members)
- member (regular participant)
- guard (guard in guard_booth conversations)

Add comments explaining each type's use case and typical participant patterns.

Create conversations table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- conversation_type conversation_type NOT NULL
- name TEXT (for group chats, NULL for direct)
- description TEXT
- avatar_url TEXT
- access_point_id UUID REFERENCES access_points(id) (for guard_booth: which gate)
- shift_date DATE (for guard_booth: active for one shift)
- is_archived BOOLEAN DEFAULT FALSE
- participant_count INTEGER DEFAULT 0 (denormalized)
- message_count INTEGER DEFAULT 0 (denormalized)
- last_message_at TIMESTAMPTZ
- last_message_preview TEXT (first 100 chars for list display)
- Standard audit columns

Create conversation_participants table:
- id UUID PK (generate_uuid_v7)
- conversation_id UUID FK to conversations(id) ON DELETE CASCADE
- user_id UUID FK to auth.users(id) NOT NULL
- role participant_role DEFAULT 'member'
- joined_at TIMESTAMPTZ DEFAULT now()
- left_at TIMESTAMPTZ (NULL if still in conversation)
- is_muted BOOLEAN DEFAULT FALSE
- muted_until TIMESTAMPTZ (temporary mute)
- last_read_message_id UUID (for efficient unread detection)
- last_read_at TIMESTAMPTZ
- unread_count INTEGER DEFAULT 0 (denormalized for efficient queries)
- UNIQUE (conversation_id, user_id)

Create update_conversation_participant_count() trigger function:
- AFTER INSERT/UPDATE/DELETE on conversation_participants
- Updates conversations.participant_count (COUNT where left_at IS NULL)

Create find_or_create_direct_conversation() function:
- Parameters: p_community_id UUID, p_user_id1 UUID, p_user_id2 UUID
- RETURNS UUID (conversation_id)
- Finds existing direct conversation between the two users
- If not found, creates one and adds both as participants
- Returns the conversation_id

Create get_or_create_guard_booth() function:
- Parameters: p_community_id UUID, p_access_point_id UUID, p_shift_date DATE, p_guard_id UUID
- RETURNS UUID (conversation_id)
- Finds or creates guard_booth conversation for gate+date
- Adds guard as participant with role='guard' if new
- Returns conversation_id

Add RLS policies:
- conversations: users can view conversations they participate in
- conversation_participants: users can view their own participation, admins can manage

Add indexes:
- conversations: community_id + is_archived + last_message_at DESC (conversation list)
- conversations: access_point_id + shift_date (guard booth lookup)
- conversation_participants: user_id + left_at IS NULL (user's active conversations)
- conversation_participants: conversation_id + left_at IS NULL (active participants)

Attach audit triggers to conversations.
  </action>
  <verify>
Run migration. Create direct conversation between two users using find_or_create_direct_conversation(). Verify both participants created. Create guard_booth conversation. Verify participant_count is updated via trigger.
  </verify>
  <done>
conversation_type and participant_role enums. conversations table with type-specific fields. conversation_participants with role and mute settings. Helper functions for direct and guard_booth creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create messages with read receipts and reactions</name>
  <files>
    supabase/migrations/TIMESTAMP_messages.sql
  </files>
  <action>
Create messages table:
- id UUID PK (generate_uuid_v7)
- conversation_id UUID FK to conversations(id) ON DELETE CASCADE
- sender_id UUID FK to auth.users(id) NOT NULL
- content TEXT (NULL for media-only messages)
- media_urls TEXT[] (array of storage URLs)
- media_types TEXT[] (MIME types for each media)
- reply_to_message_id UUID REFERENCES messages(id) (for threaded replies)
- message_type TEXT DEFAULT 'text' ('text', 'image', 'file', 'audio', 'video', 'system')
- system_data JSONB (for 'system' type: {"action": "user_joined", "user_name": "Juan"})
- is_edited BOOLEAN DEFAULT FALSE
- edited_at TIMESTAMPTZ
- original_content TEXT (preserved on edit)
- is_deleted BOOLEAN DEFAULT FALSE (soft delete shows "This message was deleted")
- created_at TIMESTAMPTZ DEFAULT now()

Create message_read_receipts table:
- id UUID PK (generate_uuid_v7)
- message_id UUID FK to messages(id) ON DELETE CASCADE
- user_id UUID FK to auth.users(id) NOT NULL
- read_at TIMESTAMPTZ DEFAULT now()
- UNIQUE (message_id, user_id)

Create message_reactions table:
- id UUID PK (generate_uuid_v7)
- message_id UUID FK to messages(id) ON DELETE CASCADE
- user_id UUID FK to auth.users(id) NOT NULL
- reaction TEXT NOT NULL (emoji code like 'thumbs_up', 'heart', 'laugh')
- created_at TIMESTAMPTZ DEFAULT now()
- UNIQUE (message_id, user_id, reaction)

Create update_conversation_on_message() trigger function:
- AFTER INSERT on messages
- Updates conversations:
  - last_message_at = NEW.created_at
  - last_message_preview = LEFT(NEW.content, 100)
  - message_count = message_count + 1
- Increments unread_count for all participants except sender (WHERE user_id != NEW.sender_id AND left_at IS NULL)

Create mark_messages_read() function:
- Parameters: p_conversation_id UUID, p_user_id UUID, p_up_to_message_id UUID
- Inserts read receipts for all unread messages up to the specified message
- Updates conversation_participants.last_read_message_id and last_read_at
- Resets unread_count to 0
- Uses ON CONFLICT DO NOTHING for idempotency

Create edit_message() function:
- Parameters: p_message_id UUID, p_new_content TEXT
- Validates sender owns message (via auth.uid())
- Preserves original_content if first edit
- Sets is_edited = true, edited_at = now()
- Returns updated message

Create delete_message() function:
- Parameters: p_message_id UUID
- Validates sender owns message OR user is conversation admin
- Sets is_deleted = true, clears content and media
- Returns boolean success

Create quick_responses table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- title TEXT NOT NULL (display name: 'Visitor Arrived')
- content TEXT NOT NULL (message to send)
- category TEXT ('greeting', 'visitor', 'delivery', 'emergency', 'other')
- sort_order INTEGER DEFAULT 0
- is_active BOOLEAN DEFAULT TRUE
- Standard audit columns

Add RLS policies:
- messages: participants can view conversation messages, sender can INSERT
- message_read_receipts: participants can view/INSERT
- message_reactions: participants can view, users can INSERT/DELETE their own
- quick_responses: community users can view, admins can manage

Add indexes:
- messages: conversation_id + created_at (message history)
- messages: conversation_id + is_deleted = false (non-deleted messages)
- message_read_receipts: message_id (for read count)
- message_reactions: message_id (for reaction aggregation)
- messages: reply_to_message_id (for thread queries)

Add comments documenting the edit/delete behavior and real-time integration pattern.
  </action>
  <verify>
Run migration. Create conversation, send message. Verify conversation stats updated (last_message_at, message_count, unread_count). Call mark_messages_read() and verify unread_count reset. Add reaction, verify constraint prevents duplicate. Edit message, verify original preserved.
  </verify>
  <done>
messages table with content, media, replies, edits. message_read_receipts for per-user tracking. message_reactions with emoji codes. Triggers maintain conversation stats and unread counts. quick_responses for guard canned messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create message notification triggers</name>
  <files>
    supabase/migrations/TIMESTAMP_chat_notifications.sql
  </files>
  <action>
Create notify_new_message() trigger function:
- AFTER INSERT on messages
- For each participant (except sender) where is_muted = false:
  - Check if muted_until has passed
  - Call pg_notify('new_message', payload) where payload is JSON:
    {
      "conversation_id": "...",
      "message_id": "...",
      "sender_id": "...",
      "recipient_id": "...",
      "preview": "first 100 chars",
      "conversation_type": "...",
      "sender_name": "..." (lookup from residents or auth.users)
    }

Create notify_typing() function (called from client via RPC):
- Parameters: p_conversation_id UUID
- Validates caller is participant
- Calls pg_notify('typing', payload) with:
  {
    "conversation_id": "...",
    "user_id": "...",
    "user_name": "...",
    "timestamp": now()
  }
- Note: Typing indicators are ephemeral via Presence, not persisted

Create get_unread_conversations_count() function:
- Parameters: p_user_id UUID
- Returns INTEGER count of conversations with unread_count > 0
- Used for badge display in mobile app

Create get_conversation_list() function:
- Parameters: p_user_id UUID, p_limit INTEGER DEFAULT 50, p_offset INTEGER DEFAULT 0
- Returns TABLE with:
  - conversation fields
  - participant's unread_count
  - other participant names (for direct)
  - last message preview
- Ordered by last_message_at DESC
- Only includes conversations where user is active participant

Create search_messages() function:
- Parameters: p_user_id UUID, p_query TEXT, p_limit INTEGER DEFAULT 20
- Searches message content across user's conversations
- Returns messages with conversation context
- Uses to_tsvector/to_tsquery for full-text search

Add text search index:
- CREATE INDEX messages_content_search ON messages USING GIN (to_tsvector('spanish', content))
- Note: 'spanish' dictionary for Mexican Spanish stemming

Add comments documenting the real-time notification pattern:
- Supabase Realtime subscribes to pg_notify channels
- Client receives push via WebSocket
- Presence API used for typing indicators (ephemeral)

Attach notify_new_message trigger to messages table.
  </action>
  <verify>
Run migration. Send message and verify pg_notify is called (check with LISTEN). Call get_conversation_list() and verify results include unread counts. Test search_messages() with Spanish text. Verify get_unread_conversations_count() returns correct count.
  </verify>
  <done>
Real-time notifications via pg_notify for new messages. Helper functions for conversation list, unread count, and message search. Spanish full-text search index. Typing indicator function for client RPC.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('conversation_type', 'participant_role')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('conversations', 'conversation_participants', 'messages', 'message_read_receipts', 'message_reactions', 'quick_responses')
3. Test: Create direct conversation between users, verify both are participants
4. Test: Send message -> Verify last_message_at, message_count, unread_count updated
5. Test: Call mark_messages_read() -> Verify read receipt created, unread_count = 0
6. Test: Add reaction -> Verify unique constraint prevents duplicate
7. Test: Edit message -> Verify original_content preserved, is_edited = true
8. Test: get_conversation_list() returns ordered conversations with unread counts
9. Test: search_messages() finds Spanish text
10. Test: RLS ensures users only see their conversations
</verification>

<success_criteria>
- conversation_type (4 types) and participant_role (4 roles) enums
- conversations table supporting all conversation patterns
- conversation_participants with roles, muting, and unread tracking
- messages with text, media, replies, edits, and soft delete
- message_read_receipts for granular read tracking
- message_reactions with emoji codes
- quick_responses for guard canned messages
- Triggers maintain denormalized counts for performance
- pg_notify for real-time message delivery
- Full-text search with Spanish dictionary
- RLS ensures users only access their conversations
</success_criteria>

<output>
After completion, create `.planning/phases/06-maintenance-chat-documents-notifications/06-03-SUMMARY.md`
</output>
