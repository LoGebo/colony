---
phase: 06-maintenance-chat-documents-notifications
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - supabase/migrations/TIMESTAMP_assets.sql
  - supabase/migrations/TIMESTAMP_preventive_schedules.sql
  - supabase/migrations/TIMESTAMP_escalation_rules.sql
autonomous: true

must_haves:
  truths:
    - "Assets track community infrastructure with status and lifecycle dates"
    - "Asset maintenance history records all work performed with costs"
    - "Preventive schedules use RRULE strings for recurrence patterns"
    - "Scheduled tickets are auto-generated based on next occurrence"
    - "Escalation rules trigger actions when SLA thresholds are crossed"
  artifacts:
    - path: "supabase/migrations/*_assets.sql"
      provides: "asset_status enum, assets table, asset_maintenance_history table"
      contains: "CREATE TABLE assets"
    - path: "supabase/migrations/*_preventive_schedules.sql"
      provides: "preventive_schedules table, generate_preventive_tickets function"
      contains: "CREATE TABLE preventive_schedules"
    - path: "supabase/migrations/*_escalation_rules.sql"
      provides: "escalation_rules table, check_escalation_triggers function"
      contains: "CREATE TABLE escalation_rules"
  key_links:
    - from: "assets"
      to: "tickets"
      via: "asset_id FK (added in this plan)"
    - from: "preventive_schedules"
      to: "tickets"
      via: "auto-generates tickets via function"
    - from: "asset_maintenance_history"
      to: "assets"
      via: "updates last_maintenance_at trigger"
---

<objective>
Create asset registry, preventive maintenance schedules with RRULE recurrence, and escalation rules for UPOE maintenance system.

Purpose: Enable proactive maintenance by tracking community infrastructure (pumps, elevators, generators), scheduling recurring maintenance via iCalendar-standard RRULE strings, and configuring escalation actions when SLA thresholds are crossed. This shifts maintenance from reactive to preventive.

Output:
- asset_status enum (5 states: operational, degraded, maintenance, out_of_service, retired)
- assets table with lifecycle tracking, specifications, and maintenance intervals
- asset_maintenance_history table with cost tracking and ticket references
- preventive_schedules table with RRULE recurrence and ticket templates
- generate_preventive_tickets() function for scheduled ticket creation
- escalation_rules table with threshold-based action triggers
- FK additions: tickets.asset_id and tickets.preventive_schedule_id
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-RESEARCH.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assets and maintenance history</name>
  <files>
    supabase/migrations/TIMESTAMP_assets.sql
  </files>
  <action>
Create asset_status enum with 5 states:
- operational (working normally)
- degraded (working but needs attention)
- maintenance (under active maintenance)
- out_of_service (not working)
- retired (decommissioned)

Create assets table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL (e.g., 'Bomba Principal Torre A')
- asset_tag TEXT (physical tag number)
- serial_number TEXT
- asset_type TEXT NOT NULL ('pump', 'elevator', 'generator', 'hvac', 'gate', 'intercom', 'lighting', 'pool_equipment', 'other')
- manufacturer TEXT
- model TEXT
- location TEXT NOT NULL (e.g., 'Sotano 1, Cuarto de Maquinas')
- building TEXT
- floor TEXT
- purchased_at DATE
- installed_at DATE
- warranty_expires_at DATE
- expected_end_of_life DATE
- purchase_cost NUMERIC(12,2)
- current_value NUMERIC(12,2)
- depreciation_method TEXT ('straight_line', 'declining_balance')
- status asset_status NOT NULL DEFAULT 'operational'
- last_maintenance_at DATE
- next_maintenance_due DATE
- maintenance_interval_days INTEGER
- manual_url TEXT
- photo_urls TEXT[]
- specifications JSONB DEFAULT '{}' (technical specs)
- Standard audit columns
- UNIQUE (community_id, asset_tag) WHERE asset_tag IS NOT NULL

Create asset_maintenance_history table:
- id UUID PK (generate_uuid_v7)
- asset_id UUID FK to assets(id) ON DELETE CASCADE
- maintenance_type TEXT NOT NULL ('preventive', 'corrective', 'emergency')
- description TEXT NOT NULL
- performed_at TIMESTAMPTZ NOT NULL
- duration_hours NUMERIC(5,2)
- performed_by TEXT (name or company)
- verified_by UUID REFERENCES auth.users(id)
- labor_cost NUMERIC(10,2)
- parts_cost NUMERIC(10,2)
- total_cost NUMERIC(10,2) GENERATED ALWAYS AS (COALESCE(labor_cost, 0) + COALESCE(parts_cost, 0)) STORED
- parts_used JSONB DEFAULT '[]' (array of {name, quantity, cost})
- report_url TEXT
- photo_urls TEXT[]
- ticket_id UUID REFERENCES tickets(id) (link to maintenance ticket)
- created_at TIMESTAMPTZ DEFAULT now()

Create update_asset_maintenance_date() trigger function:
- AFTER INSERT on asset_maintenance_history
- Updates assets.last_maintenance_at = performed_at::DATE
- Calculates next_maintenance_due if maintenance_interval_days is set

Add FK to tickets table:
- ALTER TABLE tickets ADD COLUMN asset_id UUID REFERENCES assets(id)
- Add index on asset_id for filtering tickets by asset

Add RLS policies:
- assets: users view community assets, admins manage
- asset_maintenance_history: users view, admins/staff manage

Add indexes:
- assets: community_id + status
- assets: community_id + asset_type
- assets: next_maintenance_due (for upcoming maintenance queries)
- asset_maintenance_history: asset_id + performed_at

Attach audit triggers to assets.
  </action>
  <verify>
Run migration. Create test asset with maintenance_interval_days=90. Insert maintenance history record. Verify last_maintenance_at and next_maintenance_due are updated. Create ticket with asset_id reference.
  </verify>
  <done>
assets table with lifecycle tracking and specifications. asset_maintenance_history with cost tracking and auto-update of next_maintenance_due. tickets.asset_id FK established.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create preventive maintenance schedules</name>
  <files>
    supabase/migrations/TIMESTAMP_preventive_schedules.sql
  </files>
  <action>
Create preventive_schedules table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL (e.g., 'Mantenimiento Mensual Elevadores')
- description TEXT
- rrule TEXT NOT NULL (iCalendar RFC 5545 format):
  Examples in comments:
  - 'FREQ=WEEKLY;BYDAY=MO' (every Monday)
  - 'FREQ=MONTHLY;BYMONTHDAY=1' (first of each month)
  - 'FREQ=YEARLY;BYMONTH=6;BYMONTHDAY=15' (June 15 yearly)
  - 'FREQ=MONTHLY;INTERVAL=3' (every 3 months)
- dtstart TIMESTAMPTZ NOT NULL (start date for recurrence)
- category_id UUID FK to ticket_categories(id) NOT NULL
- priority ticket_priority DEFAULT 'low'
- title_template TEXT NOT NULL (supports {asset_name}, {date} placeholders)
- description_template TEXT
- asset_id UUID REFERENCES assets(id) (optional asset link)
- generate_days_ahead INTEGER DEFAULT 7 (create ticket N days before due)
- auto_assign_to UUID REFERENCES auth.users(id)
- last_generated_at TIMESTAMPTZ
- next_occurrence_at TIMESTAMPTZ
- is_active BOOLEAN DEFAULT TRUE
- Standard audit columns

Create compute_next_rrule_occurrence() function:
- Parameters: p_rrule TEXT, p_dtstart TIMESTAMPTZ, p_after TIMESTAMPTZ
- RETURNS TIMESTAMPTZ
- LANGUAGE plpgsql, IMMUTABLE
- For MVP: Parse simple RRULE patterns (FREQ=WEEKLY/MONTHLY/YEARLY with INTERVAL)
- Use date arithmetic based on FREQ:
  - WEEKLY: Add 7 * INTERVAL days
  - MONTHLY: Add INTERVAL months using (p_after + 'N months'::INTERVAL)
  - YEARLY: Add INTERVAL years
- Note: For full RFC 5545 compliance, consider rrule_plpgsql extension later

Create generate_preventive_tickets() function:
- RETURNS INTEGER (count of tickets created)
- LANGUAGE plpgsql, SECURITY DEFINER
- Loop through active preventive_schedules
- For each schedule:
  - Compute next occurrence after last_generated_at (or dtstart if NULL)
  - If occurrence is within generate_days_ahead window:
    - Build title from title_template (replace {date}, {asset_name})
    - Find a system user or admin to use as reported_by
    - INSERT ticket with:
      - reported_by = system/admin user
      - category_id, priority from schedule
      - title, description from templates
      - asset_id from schedule
      - preventive_schedule_id = schedule.id
    - UPDATE preventive_schedules SET last_generated_at = occurrence, next_occurrence_at = next

Add FK to tickets table:
- ALTER TABLE tickets ADD COLUMN preventive_schedule_id UUID REFERENCES preventive_schedules(id)

Create set_next_occurrence() trigger:
- BEFORE INSERT/UPDATE on preventive_schedules
- Computes next_occurrence_at if rrule or dtstart changed

Add RLS policies:
- preventive_schedules: users view, admins manage

Add indexes:
- is_active + next_occurrence_at (for scheduling queries)
- asset_id (for schedules by asset)

Add comments documenting RRULE format examples.
  </action>
  <verify>
Run migration. Create preventive schedule with FREQ=MONTHLY;BYMONTHDAY=15 and dtstart=today. Verify next_occurrence_at is computed. Call generate_preventive_tickets() and verify ticket is created with preventive_schedule_id populated.
  </verify>
  <done>
preventive_schedules table with RRULE recurrence. generate_preventive_tickets() function creates scheduled tickets. next_occurrence_at auto-computed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create escalation rules</name>
  <files>
    supabase/migrations/TIMESTAMP_escalation_rules.sql
  </files>
  <action>
Create escalation_rules table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL (e.g., 'Urgent Response Escalation')
- description TEXT
- trigger_type TEXT NOT NULL:
  - 'response_warning' (% of response SLA elapsed)
  - 'response_breach' (response SLA exceeded)
  - 'resolution_warning' (% of resolution SLA elapsed)
  - 'resolution_breach' (resolution SLA exceeded)
  - 'status_stuck' (ticket in same status for N hours)
- trigger_threshold INTEGER NOT NULL:
  - For warnings: percentage (e.g., 80 = 80% of SLA)
  - For breach: 0 (triggered on breach)
  - For status_stuck: hours in same status
- applies_to_category_id UUID REFERENCES ticket_categories(id) (NULL = all categories)
- applies_to_priority ticket_priority[] (NULL = all priorities)
- action_type TEXT NOT NULL:
  - 'notify' (send notification)
  - 'reassign' (reassign to escalation contact)
  - 'upgrade_priority' (increase ticket priority)
  - 'notify_and_reassign'
- action_target UUID REFERENCES auth.users(id) (who to notify/reassign to)
- notification_template TEXT (message template for notifications)
- is_active BOOLEAN DEFAULT TRUE
- priority INTEGER DEFAULT 0 (higher = checked first)
- Standard audit columns
- UNIQUE (community_id, name)

Create check_escalation_triggers() function:
- RETURNS TABLE (ticket_id UUID, rule_id UUID, action_type TEXT, action_target UUID)
- LANGUAGE plpgsql
- For each active escalation rule:
  - Find tickets matching rule's category/priority filters
  - Check trigger condition:
    - response_warning: (now() - created_at) > (response_due_at - created_at) * threshold/100
    - response_breach: response_breached = true AND escalation not yet triggered
    - resolution_warning: similar calculation
    - resolution_breach: resolution_breached = true AND escalation not yet triggered
    - status_stuck: (now() - status_changed_at) > threshold hours
  - Return matching tickets with action details

Create ticket_escalations table (audit trail):
- id UUID PK (generate_uuid_v7)
- ticket_id UUID FK to tickets(id) ON DELETE CASCADE
- rule_id UUID FK to escalation_rules(id)
- triggered_at TIMESTAMPTZ DEFAULT now()
- action_taken TEXT
- previous_priority ticket_priority
- new_priority ticket_priority
- previous_assignee UUID
- new_assignee UUID
- notes TEXT

Create execute_escalation() function:
- Parameters: p_ticket_id UUID, p_rule_id UUID
- Looks up rule action
- Executes action (notify via pg_notify, reassign, upgrade priority)
- Inserts record into ticket_escalations
- Inserts system comment into ticket_comments

Add RLS policies:
- escalation_rules: admins manage, users view
- ticket_escalations: read-only for all, insert via function only

Add indexes:
- escalation_rules: community_id + is_active
- ticket_escalations: ticket_id + triggered_at

Add comments explaining the escalation workflow.
  </action>
  <verify>
Run migration. Create escalation rule for response_breach. Create ticket, let it breach (or manually set response_breached=true). Call check_escalation_triggers() and verify ticket is returned. Call execute_escalation() and verify ticket_escalations record created.
  </verify>
  <done>
escalation_rules table with configurable triggers and actions. check_escalation_triggers() identifies actionable tickets. execute_escalation() performs actions with audit trail in ticket_escalations.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname = 'asset_status'
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('assets', 'asset_maintenance_history', 'preventive_schedules', 'escalation_rules', 'ticket_escalations')
3. Test: Create asset -> Insert maintenance history -> Verify last_maintenance_at updated
4. Test: Create preventive schedule -> Call generate_preventive_tickets() -> Verify ticket created
5. Test: Create escalation rule -> Breach ticket SLA -> Call check_escalation_triggers() -> Verify match
6. Test: Call execute_escalation() -> Verify audit record and system comment
7. Test: RLS isolates all tables by community
</verification>

<success_criteria>
- asset_status enum with 5 states
- assets table with lifecycle dates, specifications, maintenance tracking
- asset_maintenance_history with cost tracking and ticket links
- preventive_schedules with RRULE recurrence and ticket generation
- generate_preventive_tickets() creates tickets from schedules
- escalation_rules with configurable triggers and actions
- check_escalation_triggers() identifies escalation candidates
- execute_escalation() performs actions with full audit trail
- All tables have RLS with community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/06-maintenance-chat-documents-notifications/06-02-SUMMARY.md`
</output>
