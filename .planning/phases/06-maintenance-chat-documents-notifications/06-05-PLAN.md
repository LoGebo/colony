---
phase: 06-maintenance-chat-documents-notifications
plan: 05
type: execute
wave: 2
depends_on: [06-01, 06-03]
files_modified:
  - supabase/migrations/TIMESTAMP_notification_enums.sql
  - supabase/migrations/TIMESTAMP_push_tokens.sql
  - supabase/migrations/TIMESTAMP_notifications.sql
autonomous: true

must_haves:
  truths:
    - "Notifications track type, channel, recipient, and delivery status"
    - "Push tokens support FCM Android, FCM iOS, APNs, and web push"
    - "Stale tokens are auto-cleaned after 30 days of inactivity"
    - "User preferences control notification types and channels"
    - "Do-not-disturb settings suppress non-critical notifications"
    - "Notification templates enable localized, customizable messages"
  artifacts:
    - path: "supabase/migrations/*_notification_enums.sql"
      provides: "notification_channel, notification_type, push_platform enums"
      contains: "CREATE TYPE notification_channel"
    - path: "supabase/migrations/*_push_tokens.sql"
      provides: "push_tokens table with staleness tracking"
      contains: "CREATE TABLE push_tokens"
    - path: "supabase/migrations/*_notifications.sql"
      provides: "notifications, notification_deliveries, notification_preferences, notification_templates tables"
      contains: "CREATE TABLE notifications"
  key_links:
    - from: "notifications"
      to: "notification_preferences"
      via: "get_notification_channels function"
    - from: "notification_deliveries"
      to: "notifications"
      via: "notification_id FK for per-channel tracking"
    - from: "push_tokens"
      to: "auth.users"
      via: "user_id FK for device registration"
---

<objective>
Create push token management, notification preferences, and multi-channel notification delivery system for UPOE alerts.

Purpose: Enable reliable notification delivery across push (FCM/APNs), email, SMS, and in-app channels. Users control what notifications they receive and how via preferences. Push tokens are managed with staleness detection to maintain delivery reliability. Notification templates enable localized content.

Output:
- notification_channel (4 channels), notification_type (18 types), push_platform (4 platforms) enums
- push_tokens table with device registration and staleness tracking
- notification_preferences table with JSONB per-type settings
- notifications table with multi-channel delivery tracking
- notification_deliveries table for per-channel status
- notification_templates table for customizable messages
- Helper functions for token management, preference lookup, and notification creation
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-RESEARCH.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-01-PLAN.md
@.planning/phases/06-maintenance-chat-documents-notifications/06-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification enums and push tokens</name>
  <files>
    supabase/migrations/TIMESTAMP_notification_enums.sql
    supabase/migrations/TIMESTAMP_push_tokens.sql
  </files>
  <action>
Create notification_channel enum with 4 values:
- push (mobile push notification)
- email (email delivery)
- sms (SMS text message)
- in_app (in-app notification center)

Create notification_type enum with 18 values covering all domains:
Maintenance:
- ticket_created, ticket_assigned, ticket_status_changed, ticket_comment_added
- sla_warning, sla_breach
Chat:
- new_message, message_reaction, conversation_mention
Documents:
- document_published, signature_required, signature_reminder
General:
- announcement, survey_published, payment_due, payment_received
- visitor_arrived, package_arrived, emergency_alert

Create push_platform enum with 4 values:
- fcm_android (Firebase Cloud Messaging for Android)
- fcm_ios (Firebase Cloud Messaging for iOS)
- apns (Apple Push Notification Service direct)
- web_push (Web Push API)

Add comments explaining each notification type's trigger and typical content.

Create push_tokens table:
- id UUID PK (generate_uuid_v7)
- user_id UUID FK to auth.users(id) ON DELETE CASCADE
- platform push_platform NOT NULL
- token TEXT NOT NULL (the push token from device)
- device_id TEXT (unique device identifier)
- device_name TEXT (user-friendly: "John's iPhone")
- device_model TEXT (hardware model)
- os_version TEXT
- app_version TEXT
- registered_at TIMESTAMPTZ DEFAULT now()
- last_used_at TIMESTAMPTZ DEFAULT now()
- last_refreshed_at TIMESTAMPTZ DEFAULT now()
- is_active BOOLEAN DEFAULT TRUE
- deactivation_reason TEXT ('user_logout', 'token_expired', 'unregistered', 'bounced')
- deactivated_at TIMESTAMPTZ
- success_count INTEGER DEFAULT 0
- failure_count INTEGER DEFAULT 0
- last_failure_at TIMESTAMPTZ
- last_failure_reason TEXT
- UNIQUE (token)
- UNIQUE (user_id, device_id, platform)

Create register_push_token() function:
- Parameters: p_user_id UUID, p_platform push_platform, p_token TEXT, p_device_id TEXT, p_device_name TEXT, p_device_model TEXT, p_app_version TEXT
- RETURNS UUID (token_id)
- UPSERT: ON CONFLICT (user_id, device_id, platform) updates token and reactivates
- Sets last_refreshed_at = now()

Create mark_token_invalid() function:
- Parameters: p_token TEXT, p_reason TEXT
- Sets is_active = false, deactivation_reason, deactivated_at
- Increments failure_count

Create record_push_success() function:
- Parameters: p_token TEXT
- Updates last_used_at = now()
- Increments success_count

Create cleanup_stale_push_tokens() function:
- Parameters: p_stale_days INTEGER DEFAULT 30
- RETURNS INTEGER (count deleted)
- Deletes tokens where is_active = false AND deactivated_at < now() - p_stale_days
- Marks tokens as stale where is_active = true AND last_used_at < now() - p_stale_days

Create get_user_push_tokens() function:
- Parameters: p_user_id UUID
- Returns active push tokens for user
- Used by notification sender

Add RLS policies:
- push_tokens: users can view/manage their own tokens
- No cross-user access

Add indexes:
- push_tokens: user_id + is_active (active tokens for user)
- push_tokens: is_active + deactivated_at (for cleanup query)
- push_tokens: token (for marking invalid)
  </action>
  <verify>
Run migration. Register push token via register_push_token(). Re-register same device with new token - verify token updated. Call mark_token_invalid() - verify is_active=false. Call cleanup_stale_push_tokens() after manipulating timestamps - verify cleanup works.
  </verify>
  <done>
notification_channel (4), notification_type (18), push_platform (4) enums. push_tokens table with registration, staleness tracking, and cleanup. Helper functions for token lifecycle management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notification preferences</name>
  <files>
    supabase/migrations/TIMESTAMP_notification_preferences.sql
  </files>
  <action>
Create notification_preferences table:
- id UUID PK (generate_uuid_v7)
- user_id UUID FK to auth.users(id) ON DELETE CASCADE UNIQUE
- do_not_disturb BOOLEAN DEFAULT FALSE
- dnd_start_time TIME (e.g., '22:00')
- dnd_end_time TIME (e.g., '08:00')
- preferences JSONB DEFAULT '{}' (per-type settings)
  Schema: { "notification_type": { "enabled": true, "channels": ["push", "in_app"] } }
- default_channels notification_channel[] DEFAULT ARRAY['push', 'in_app']
- email_digest_enabled BOOLEAN DEFAULT FALSE
- email_digest_frequency TEXT DEFAULT 'daily' ('daily', 'weekly')
- email_digest_time TIME DEFAULT '09:00'
- created_at TIMESTAMPTZ DEFAULT now()
- updated_at TIMESTAMPTZ DEFAULT now()

Document the JSONB schema with examples:
{
  "ticket_assigned": { "enabled": true, "channels": ["push", "email"] },
  "new_message": { "enabled": true, "channels": ["push"], "sound": "message.wav" },
  "payment_due": { "enabled": false },
  "emergency_alert": { "enabled": true, "channels": ["push", "sms", "in_app"] }
}

Create get_notification_channels() function:
- Parameters: p_user_id UUID, p_notification_type notification_type
- RETURNS notification_channel[]
- LANGUAGE plpgsql, STABLE
- Logic:
  1. Load user preferences (default if not found)
  2. Check DND: if active and current time is in DND window, return ['in_app'] only (except emergency_alert which bypasses DND)
  3. Get type-specific preferences from JSONB
  4. If type not in JSONB, use default_channels
  5. If enabled=false, return empty array
  6. Return configured channels

Create update_notification_preferences() function:
- Parameters: p_user_id UUID, p_notification_type notification_type, p_enabled BOOLEAN, p_channels notification_channel[]
- UPSERT preferences JSONB for the specified type
- Uses jsonb_set for surgical update

Create set_dnd() function:
- Parameters: p_user_id UUID, p_enabled BOOLEAN, p_start TIME, p_end TIME
- Updates DND settings

Create ensure_notification_preferences() function:
- Parameters: p_user_id UUID
- Creates default preferences record if not exists
- Called on user registration or first preference access

Add RLS policies:
- notification_preferences: users can view/update their own

Add GIN index on preferences JSONB for queries like "find all users with ticket_assigned enabled".

Attach updated_at trigger.
  </action>
  <verify>
Run migration. Create user preferences. Set type-specific preference. Call get_notification_channels() - verify returns configured channels. Enable DND - verify non-emergency returns in_app only. Verify emergency_alert bypasses DND.
  </verify>
  <done>
notification_preferences table with JSONB per-type settings. get_notification_channels() evaluates preferences with DND support. Helper functions for preference management.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create notifications and templates</name>
  <files>
    supabase/migrations/TIMESTAMP_notifications.sql
  </files>
  <action>
Create notifications table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- user_id UUID FK to auth.users(id) NOT NULL
- notification_type notification_type NOT NULL
- title TEXT NOT NULL
- body TEXT NOT NULL
- action_type TEXT ('open_ticket', 'open_conversation', 'open_document', 'open_payment')
- action_data JSONB ({"ticket_id": "uuid", "conversation_id": "uuid"})
- source_type TEXT ('ticket', 'message', 'document', 'payment', 'announcement')
- source_id UUID
- channels_requested notification_channel[] NOT NULL
- channels_delivered notification_channel[] DEFAULT ARRAY[]::notification_channel[]
- is_read BOOLEAN DEFAULT FALSE
- read_at TIMESTAMPTZ
- scheduled_for TIMESTAMPTZ (for delayed delivery)
- created_at TIMESTAMPTZ DEFAULT now()
- expires_at TIMESTAMPTZ (auto-cleanup old notifications)

Create notification_deliveries table:
- id UUID PK (generate_uuid_v7)
- notification_id UUID FK to notifications(id) ON DELETE CASCADE
- channel notification_channel NOT NULL
- status TEXT DEFAULT 'pending' ('pending', 'sent', 'delivered', 'failed', 'bounced')
- attempt_count INTEGER DEFAULT 0
- first_attempted_at TIMESTAMPTZ
- last_attempted_at TIMESTAMPTZ
- sent_at TIMESTAMPTZ
- delivered_at TIMESTAMPTZ (confirmed delivery if available)
- failure_reason TEXT
- provider_message_id TEXT (FCM message ID, email ID, etc.)
- UNIQUE (notification_id, channel)

Create notification_templates table:
- id UUID PK (generate_uuid_v7)
- community_id UUID REFERENCES communities(id) (NULL for system templates)
- notification_type notification_type NOT NULL
- channel notification_channel NOT NULL
- locale TEXT DEFAULT 'es-MX'
- title_template TEXT NOT NULL (supports {{variable}} placeholders)
- body_template TEXT NOT NULL
- options JSONB DEFAULT '{}' (channel-specific: {"sound": "default", "badge": true})
- is_active BOOLEAN DEFAULT TRUE
- created_at TIMESTAMPTZ DEFAULT now()
- updated_at TIMESTAMPTZ DEFAULT now()
- UNIQUE (community_id, notification_type, channel, locale)

Insert default Spanish templates for common notifications:
- ticket_created: "Nuevo ticket #{{ticket_number}}" / "{{reporter_name}} reporto: {{ticket_title}}"
- ticket_assigned: "Ticket asignado" / "Se te asigno el ticket #{{ticket_number}}"
- sla_breach: "SLA Vencido" / "El ticket #{{ticket_number}} excedio su tiempo de {{breach_type}}"
- new_message: "Nuevo mensaje" / "{{sender_name}}: {{message_preview}}"
- signature_required: "Firma requerida" / "El documento {{document_name}} requiere tu firma"
- emergency_alert: "ALERTA DE EMERGENCIA" / "{{alert_type}}: {{location}}"

Create render_notification_template() function:
- Parameters: p_template_id UUID, p_variables JSONB
- RETURNS TABLE (title TEXT, body TEXT)
- Replaces {{variable}} placeholders with values from p_variables

Create create_notification() function:
- Parameters: p_community_id UUID, p_user_id UUID, p_notification_type notification_type, p_variables JSONB, p_source_type TEXT, p_source_id UUID, p_action_type TEXT, p_action_data JSONB
- RETURNS UUID (notification_id)
- Gets user's channels via get_notification_channels()
- If empty array (disabled), return NULL
- Finds template for type/channel/locale
- Renders title and body from template
- Inserts notification
- Inserts notification_deliveries for each requested channel
- Calls pg_notify('notification_created', payload) for Edge Function pickup
- Returns notification_id

Create mark_notification_read() function:
- Parameters: p_notification_id UUID
- Sets is_read = true, read_at = now()
- Returns boolean success

Create mark_all_notifications_read() function:
- Parameters: p_user_id UUID
- Updates all unread notifications for user

Create get_unread_notifications() function:
- Parameters: p_user_id UUID, p_limit INTEGER DEFAULT 50
- Returns unread notifications ordered by created_at DESC

Create record_delivery_status() function:
- Parameters: p_notification_id UUID, p_channel notification_channel, p_status TEXT, p_provider_message_id TEXT, p_failure_reason TEXT
- Updates notification_deliveries
- If status = 'delivered' or 'sent', adds channel to notifications.channels_delivered

Add RLS policies:
- notifications: users can view their own
- notification_deliveries: users can view their own notifications' deliveries
- notification_templates: users can view, admins can manage

Add indexes:
- notifications: user_id + is_read + created_at DESC (unread list)
- notifications: community_id + notification_type (analytics)
- notifications: scheduled_for WHERE scheduled_for IS NOT NULL (scheduled delivery)
- notification_deliveries: status = 'pending' (pending delivery queue)
- notification_templates: notification_type + channel + locale (template lookup)

Attach updated_at trigger to notification_templates.
  </action>
  <verify>
Run migration. Create notification via create_notification() - verify notification and deliveries created. Check pg_notify triggered. Mark notification read. Test template rendering with variables. Test RLS isolates notifications per user.
  </verify>
  <done>
notifications table with multi-channel delivery tracking. notification_deliveries for per-channel status. notification_templates with Spanish defaults. create_notification() handles preference lookup, template rendering, and pg_notify.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('notification_channel', 'notification_type', 'push_platform')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('push_tokens', 'notification_preferences', 'notifications', 'notification_deliveries', 'notification_templates')
3. Test: Register push token -> Re-register with new token -> Verify update
4. Test: Set notification preferences -> get_notification_channels() returns correct channels
5. Test: Enable DND -> get_notification_channels() returns in_app only (except emergency)
6. Test: create_notification() with template -> Verify title/body rendered correctly
7. Test: Verify notification_deliveries created for each channel
8. Test: mark_notification_read() updates is_read and read_at
9. Test: cleanup_stale_push_tokens() removes old inactive tokens
10. Test: RLS isolates push_tokens and notifications per user
</verification>

<success_criteria>
- notification_channel (4), notification_type (18), push_platform (4) enums
- push_tokens with registration, staleness tracking, and cleanup
- notification_preferences with JSONB per-type settings and DND
- notifications with multi-channel delivery tracking
- notification_deliveries for per-channel status and retry tracking
- notification_templates with Spanish defaults and variable rendering
- create_notification() integrates preferences, templates, and pg_notify
- All tables have RLS with appropriate user isolation
- Helper functions for preference management and notification lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/06-maintenance-chat-documents-notifications/06-05-SUMMARY.md`
</output>
