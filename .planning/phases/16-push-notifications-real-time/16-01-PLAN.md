---
phase: 16-push-notifications-real-time
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mobile/package.json
  - packages/mobile/app.json
  - packages/mobile/src/services/notifications/NotificationService.ts
  - packages/mobile/src/hooks/useNotifications.ts
  - packages/mobile/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "App requests push notification permission on first authenticated launch"
    - "Push token is stored in push_tokens table after permission grant"
    - "Android notification channels are created before permission request"
    - "Foreground notifications display as banners with type-based sound/priority"
    - "Tapping a notification routes to the correct screen via deep link"
  artifacts:
    - path: "packages/mobile/src/services/notifications/NotificationService.ts"
      provides: "Singleton notification service with registration, handlers, channels"
      min_lines: 120
    - path: "packages/mobile/src/hooks/useNotifications.ts"
      provides: "usePushRegistration hook, useNotificationList hook, useMarkRead mutation"
      exports: ["usePushRegistration", "useNotificationList", "useUnreadCount", "useMarkNotificationRead"]
    - path: "packages/mobile/app/_layout.tsx"
      provides: "Notification initialization on authenticated launch"
      contains: "NotificationService"
  key_links:
    - from: "packages/mobile/src/services/notifications/NotificationService.ts"
      to: "push_tokens table"
      via: "supabase.from('push_tokens').upsert()"
      pattern: "push_tokens.*upsert"
    - from: "packages/mobile/app/_layout.tsx"
      to: "packages/mobile/src/services/notifications/NotificationService.ts"
      via: "initialize() call after session available"
      pattern: "NotificationService.*initialize"
    - from: "packages/mobile/src/services/notifications/NotificationService.ts"
      to: "expo-router navigation"
      via: "addNotificationResponseReceivedListener with router.push"
      pattern: "addNotificationResponseReceivedListener"
---

<objective>
Set up push notification infrastructure: install dependencies, create NotificationService singleton for FCM/APNs registration via Expo, configure Android notification channels, store push tokens in database, handle foreground display and notification tap deep linking, and wire initialization into app root layout.

Purpose: This is the foundation for all push notification delivery. Without token registration and notification handling, no push events can reach users.
Output: Working notification service that registers tokens on login, displays foreground notifications, and routes taps to correct screens. Plus hooks for reading notification list and unread count from the notifications table.
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-push-notifications-real-time/16-RESEARCH.md

Key codebase files:
@packages/mobile/package.json
@packages/mobile/app.json
@packages/mobile/app/_layout.tsx
@packages/mobile/src/lib/supabase.ts
@packages/mobile/src/hooks/useAuth.ts
@packages/mobile/src/providers/SessionProvider.tsx
@packages/shared/src/queries/keys.ts

Database context:
- push_tokens table: id, user_id, platform, token, device_name, is_active, last_used_at, created_at, updated_at
- notifications table: id, user_id, community_id, type (notification_type enum), title, body, data (json), action_url, read_at, dismissed_at, created_at
- notification_type enum values: ticket_created, ticket_assigned, ticket_status_changed, ticket_comment_added, sla_warning, sla_breach, new_message, message_reaction, conversation_mention, document_published, signature_required, signature_reminder, announcement, survey_published, payment_due, payment_received, visitor_arrived, package_arrived, emergency_alert
- mark_notification_read RPC: Args { p_notification_id: string } Returns boolean
- notification_channel enum: push, email, sms, in_app
- residents.notification_preferences: Json | null (per-resident preferences stored as JSON)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure Expo plugins</name>
  <files>
    packages/mobile/package.json
    packages/mobile/app.json
  </files>
  <action>
    1. Install expo-notifications and expo-device into @upoe/mobile:
       Run `npx expo install expo-notifications expo-device` from packages/mobile directory.
       (expo-constants is already installed at ~18.0.13)

    2. Update packages/mobile/app.json to add the expo-notifications plugin:
       Add to the "plugins" array:
       ```json
       ["expo-notifications", {
         "icon": "./assets/icon.png",
         "color": "#2563eb",
         "sounds": []
       }]
       ```
       Keep all existing plugins. The notification plugin configures Android/iOS native notification settings.

    3. Verify package.json now includes expo-notifications and expo-device in dependencies.
  </action>
  <verify>
    Run `cd packages/mobile && npx expo config --type public` and confirm expo-notifications appears in plugins.
    Check package.json contains expo-notifications and expo-device.
  </verify>
  <done>
    expo-notifications and expo-device in package.json dependencies.
    app.json plugins array includes expo-notifications config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationService singleton and hooks</name>
  <files>
    packages/mobile/src/services/notifications/NotificationService.ts
    packages/mobile/src/hooks/useNotifications.ts
    packages/shared/src/queries/keys.ts
  </files>
  <action>
    **A. Create packages/mobile/src/services/notifications/NotificationService.ts**

    Singleton class with the following methods:

    1. `initialize(userId: string)` - Main entry point called after auth:
       - Call `setupNotificationHandler()` (foreground behavior)
       - Call `setupAndroidChannels()` if Platform.OS === 'android'
       - Call `registerForPushNotifications(userId)`
       - Call `setupListeners()`
       - Call `clearBadge()`

    2. `setupNotificationHandler()` - Configure foreground display:
       - Use `Notifications.setNotificationHandler()` from research Pattern 2
       - Emergency alerts: shouldShowAlert=true, shouldPlaySound=true, shouldSetBadge=true, priority=MAX
       - Visitor arrivals (visitor_arrived): shouldShowAlert=true, shouldPlaySound=true, shouldSetBadge=true
       - Default: shouldShowAlert=true, shouldPlaySound=false, shouldSetBadge=true

    3. `setupAndroidChannels()` - Create 3 channels BEFORE permission request:
       - 'visitor-arrivals': importance HIGH, vibration [0, 250, 250, 250]
       - 'emergency': importance MAX, bypassDnd: true, vibration [0, 500, 500, 500]
       - 'default': importance DEFAULT

    4. `registerForPushNotifications(userId: string)`:
       - Check Device.isDevice (return null if emulator)
       - Check existing permissions via getPermissionsAsync()
       - Request if not granted via requestPermissionsAsync()
       - Get token via getExpoPushTokenAsync({ projectId: Constants.expoConfig?.extra?.eas?.projectId })
       - Store token via `storeToken(token, userId)`
       - Return token string or null

    5. `storeToken(token: string, userId: string)`:
       - Import supabase from @/lib/supabase (lazy import pattern -- use dynamic import or import at top with late call)
       - Upsert to push_tokens: { user_id: userId, platform: Platform.OS, token, device_name: Device.deviceName, is_active: true, last_used_at: new Date().toISOString() }
       - Use onConflict: 'user_id,token' (NOT 'user_id,device_name' since research had a different unique constraint -- check actual table; use user_id+token as safest upsert strategy; if that fails, try plain insert with catch for duplicates)
       - IMPORTANT: The push_tokens table may not have a unique constraint on user_id+device_name. Use a select-then-upsert pattern: query existing token for this user_id, if found update it, if not insert new.

    6. `setupListeners()`:
       - addPushTokenListener: on token refresh, call storeToken with new token
       - addNotificationReceivedListener: log to console (foreground receipt)
       - addNotificationResponseReceivedListener: call handleNotificationTap(response)

    7. `handleNotificationTap(response: NotificationResponse)`:
       - Extract data from response.notification.request.content.data
       - Use expo-router's `router.push()` for deep linking based on data.action_type:
         - 'open_visitor' -> /(resident)/visitors/[id] with data.visitor_id
         - 'open_payment' -> /(resident)/payments/ (no detail route, go to list)
         - 'open_ticket' -> /(resident)/maintenance/[id] with data.ticket_id
         - 'open_announcement' -> /(resident)/announcements/[id] with data.announcement_id
         - 'open_package' -> /(resident)/more/packages (list screen)
         - default: navigate to root
       - Fire-and-forget: call supabase.rpc('mark_notification_read', { p_notification_id: data.notification_id }) if data.notification_id exists

    8. `clearBadge()` - Notifications.setBadgeCountAsync(0)
    9. `cleanup()` - Remove all listeners (for sign-out)

    Import strategy: Import supabase at the top of the file. Import router from expo-router. Import Platform from react-native.
    Export: `export default NotificationService.getInstance()` (singleton pattern from research).

    **B. Create packages/mobile/src/hooks/useNotifications.ts**

    1. `usePushRegistration()` hook:
       - Uses useAuth() to get user?.id
       - useEffect: when user.id is available, call NotificationService.initialize(user.id)
       - Cleanup on unmount or sign-out: call NotificationService.cleanup()
       - Return nothing (fire-and-forget registration)

    2. `useNotificationList()` hook:
       - Uses useAuth() to get user.id and communityId
       - useQuery with queryKey: queryKeys.notifications.unread(user.id).queryKey
       - Fetches from notifications table: select('*').eq('user_id', user.id).is('dismissed_at', null).order('created_at', { ascending: false }).limit(50)
       - Returns typed notification array

    3. `useUnreadCount()` hook:
       - useQuery with queryKey: [...queryKeys.notifications.unread(user.id).queryKey, 'count']
       - Fetches count from notifications table: .eq('user_id', user.id).is('read_at', null).is('dismissed_at', null) with { count: 'exact', head: true }
       - Returns number

    4. `useMarkNotificationRead()` mutation:
       - Calls supabase.rpc('mark_notification_read', { p_notification_id })
       - Invalidates notifications queries on success

    **C. Update packages/shared/src/queries/keys.ts**

    The notifications query key factory already exists with `all` and `unread(userId)`. Add:
    - `list: (userId: string) => [{ userId }]` for the notification list query
    - `preferences: (residentId: string) => [{ residentId }]` for future preference management

    Keep existing entries. Add alphabetically in the factory definition.
  </action>
  <verify>
    TypeScript compiles: Run `cd packages/mobile && npx tsc --noEmit` (expect no new errors from these files).
    Verify NotificationService.ts exports a singleton instance.
    Verify useNotifications.ts exports usePushRegistration, useNotificationList, useUnreadCount, useMarkNotificationRead.
    Verify keys.ts has notifications.list and notifications.preferences.
  </verify>
  <done>
    NotificationService singleton handles: Android channel setup, permission request, token registration to push_tokens table, foreground notification display, notification tap deep linking.
    Hooks provide: push registration lifecycle, notification list query, unread count query, mark-read mutation.
    Query keys extended for notification list and preferences.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire notification initialization into app root layout</name>
  <files>
    packages/mobile/app/_layout.tsx
  </files>
  <action>
    Update packages/mobile/app/_layout.tsx to initialize push notifications after authentication:

    1. Import `usePushRegistration` from '@/hooks/useNotifications'

    2. Inside `RootNavigator()` function, after the `useSession()` call and after splashscreen hide logic, add:
       ```
       usePushRegistration();
       ```
       This hook internally checks if user.id exists before initializing. It's safe to call unconditionally -- it no-ops when unauthenticated.

    3. The hook placement must be:
       - After `const { session, isLoading } = useSession();` line
       - Before the `if (isLoading) return null;` check is fine (hooks must be unconditional per rules of hooks)
       - The hook internally guards on user existence

    4. Do NOT move the hook into individual role layouts (resident, guard). Push registration happens once at the root for all roles.

    5. Keep all existing code unchanged: SessionProvider, QueryProvider, Stack.Protected guards, SplashScreen logic.
  </action>
  <verify>
    Read the updated _layout.tsx and confirm usePushRegistration() is called inside RootNavigator.
    Confirm all existing imports and logic remain unchanged.
    Run `cd packages/mobile && npx tsc --noEmit` to verify no type errors.
  </verify>
  <done>
    Root layout calls usePushRegistration() which triggers push token registration on first authenticated app launch.
    Notification handler is set up for foreground display.
    Android channels are created.
    Token is stored in push_tokens table.
    Notification tap deep linking is active.
  </done>
</task>

</tasks>

<verification>
1. NotificationService.ts exists as singleton with initialize/cleanup lifecycle
2. Three Android notification channels defined (visitor-arrivals, emergency, default)
3. Push token registration flow: Device.isDevice check -> getPermissions -> request -> getExpoPushToken -> upsert to push_tokens
4. Foreground handler configured with type-based priority (emergency=MAX, visitor=HIGH+sound, default=banner-only)
5. Notification tap handler routes to correct screens using expo-router
6. usePushRegistration hook called in root layout, initializes on auth, cleans up on sign-out
7. useNotificationList, useUnreadCount, useMarkNotificationRead hooks functional
8. app.json includes expo-notifications plugin
9. TypeScript compiles without errors
</verification>

<success_criteria>
- expo-notifications and expo-device installed in mobile package
- app.json configured with notification plugin
- NotificationService singleton handles full push lifecycle (register, display, route, cleanup)
- Hooks provide notification list, unread count, mark-read, and push registration
- Root layout initializes push on authenticated launch
- All 19 notification_type enum values can be handled (type-based display rules)
- Query keys extended for notification list and preferences
</success_criteria>

<output>
After completion, create `.planning/phases/16-push-notifications-real-time/16-01-SUMMARY.md`
</output>
