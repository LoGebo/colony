---
phase: 16-push-notifications-real-time
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - packages/mobile/src/hooks/useRealtimeSubscription.ts
  - packages/mobile/src/hooks/useVisitors.ts
  - packages/mobile/src/hooks/useGateOps.ts
  - packages/mobile/src/hooks/useNotificationPreferences.ts
  - packages/mobile/src/components/notifications/NotificationPreferences.tsx
  - packages/mobile/app/(resident)/more/notification-settings.tsx
autonomous: true

must_haves:
  truths:
    - "Resident sees visitor status updates in real-time without manually refreshing"
    - "Guard sees new expected visitors appear in their queue in real-time"
    - "Real-time subscriptions clean up properly when navigating away (no memory leaks)"
    - "Resident can toggle notification preferences for each notification type"
    - "Notification preferences persist to the residents table"
  artifacts:
    - path: "packages/mobile/src/hooks/useRealtimeSubscription.ts"
      provides: "Generic reusable Supabase Realtime subscription hook"
      exports: ["useRealtimeSubscription"]
      min_lines: 40
    - path: "packages/mobile/src/hooks/useNotificationPreferences.ts"
      provides: "Hooks for loading and saving notification preferences"
      exports: ["useNotificationPreferences", "useUpdateNotificationPreferences"]
    - path: "packages/mobile/src/components/notifications/NotificationPreferences.tsx"
      provides: "Notification preference settings UI with toggles"
      min_lines: 60
    - path: "packages/mobile/app/(resident)/more/notification-settings.tsx"
      provides: "Route screen for notification settings"
  key_links:
    - from: "packages/mobile/src/hooks/useRealtimeSubscription.ts"
      to: "supabase.channel().on('postgres_changes')"
      via: "Supabase Realtime subscription"
      pattern: "postgres_changes"
    - from: "packages/mobile/src/hooks/useRealtimeSubscription.ts"
      to: "queryClient.invalidateQueries()"
      via: "TanStack Query cache invalidation on realtime event"
      pattern: "invalidateQueries"
    - from: "packages/mobile/src/hooks/useVisitors.ts"
      to: "useRealtimeSubscription"
      via: "Real-time updates for visitor invitations"
      pattern: "useRealtimeSubscription"
    - from: "packages/mobile/src/hooks/useGateOps.ts"
      to: "useRealtimeSubscription"
      via: "Real-time updates for guard expected visitors"
      pattern: "useRealtimeSubscription"
    - from: "packages/mobile/src/hooks/useNotificationPreferences.ts"
      to: "residents.notification_preferences"
      via: "JSON column read/write"
      pattern: "notification_preferences"
---

<objective>
Add real-time data subscriptions for visitor status (resident) and guard expected visitors queue, plus notification preference management so users can control which notification types they receive.

Purpose: Real-time updates eliminate manual refreshing for time-sensitive data (visitor arriving at gate, new visitor in guard queue). Notification preferences give users control over alert noise.
Output: Generic useRealtimeSubscription hook wired into visitor and gate hooks, notification preference screen with per-type toggles.
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-push-notifications-real-time/16-RESEARCH.md
@.planning/phases/16-push-notifications-real-time/16-01-SUMMARY.md

Key codebase files:
@packages/mobile/src/hooks/useVisitors.ts
@packages/mobile/src/hooks/useGateOps.ts
@packages/mobile/src/hooks/useAuth.ts
@packages/mobile/src/lib/supabase.ts
@packages/shared/src/queries/keys.ts

Database context:
- invitations table: id, status, visitor_name, community_id, created_by_resident_id, valid_from, valid_until...
- visitors table: id, status, community_id, invitation_id, check_in_time, check_out_time...
- access_logs table: id, community_id, access_point_id, direction, timestamp...
- residents.notification_preferences: Json | null (stored as jsonb on the residents table)
- notification_type enum values: ticket_created, ticket_assigned, ticket_status_changed, ticket_comment_added, sla_warning, sla_breach, new_message, message_reaction, conversation_mention, document_published, signature_required, signature_reminder, announcement, survey_published, payment_due, payment_received, visitor_arrived, package_arrived, emergency_alert
- Supabase Realtime: postgres_changes event type, respects RLS when using authenticated client
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useRealtimeSubscription hook and wire into visitor/gate hooks</name>
  <files>
    packages/mobile/src/hooks/useRealtimeSubscription.ts
    packages/mobile/src/hooks/useVisitors.ts
    packages/mobile/src/hooks/useGateOps.ts
  </files>
  <action>
    **A. Create packages/mobile/src/hooks/useRealtimeSubscription.ts**

    Generic hook for subscribing to Supabase Realtime postgres_changes with automatic TanStack Query invalidation and proper cleanup.

    Interface:
    ```typescript
    interface UseRealtimeSubscriptionOptions {
      channelName: string;       // Unique channel identifier
      table: string;             // Postgres table to watch
      event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';  // Default: '*'
      filter?: string;           // PostgREST filter e.g., 'status=eq.pending'
      queryKeys: unknown[][];    // Array of query key arrays to invalidate
      enabled?: boolean;         // Whether subscription is active (default: true)
      onEvent?: (payload: any) => void;  // Optional callback for custom logic
    }
    ```

    Implementation:
    1. Import useEffect from 'react', useQueryClient from '@tanstack/react-query', supabase from '@/lib/supabase', type RealtimeChannel from '@supabase/supabase-js'
    2. Inside useEffect (deps: [channelName, table, event, filter, enabled, JSON.stringify(queryKeys)]):
       - If !enabled, return early
       - Create channel: `supabase.channel(channelName)`
       - Subscribe: `.on('postgres_changes', { event: event ?? '*', schema: 'public', table, filter }, (payload) => { ... })`
       - In callback: call onEvent?.(payload), then invalidate ALL provided queryKeys:
         ```
         queryKeys.forEach(qk => queryClient.invalidateQueries({ queryKey: qk }));
         ```
       - Call `.subscribe()` on channel
       - Return cleanup: `() => { channel.unsubscribe(); }`
    3. Export as named export

    IMPORTANT: Use a stable channel name. Avoid Date.now() in channel name (causes re-subscription on every render). The channelName prop should be deterministic based on the data being watched.

    **B. Update packages/mobile/src/hooks/useVisitors.ts**

    Add real-time subscription to the `useActiveInvitations` hook so residents see visitor status changes live.

    1. Import `useRealtimeSubscription` from './useRealtimeSubscription'
    2. Create a NEW hook `useActiveInvitationsRealtime()` that wraps useActiveInvitations with real-time:
       ```typescript
       export function useActiveInvitationsRealtime() {
         const { residentId, communityId } = useAuth();
         const query = useActiveInvitations();

         useRealtimeSubscription({
           channelName: `invitations-${residentId}`,
           table: 'invitations',
           event: '*',
           filter: `created_by_resident_id=eq.${residentId}`,
           queryKeys: [
             queryKeys.visitors.active(communityId!).queryKey,
             queryKeys.visitors._def,
           ],
           enabled: !!residentId && !!communityId,
         });

         return query;
       }
       ```

    3. Also add real-time for visitor CHECK-IN events (when guard checks in a visitor, resident should see update):
       Add a subscription to the `access_logs` table filtered by community:
       ```typescript
       useRealtimeSubscription({
         channelName: `access-logs-${communityId}`,
         table: 'access_logs',
         event: 'INSERT',
         queryKeys: [
           queryKeys.visitors.active(communityId!).queryKey,
           queryKeys.visitors._def,
         ],
         enabled: !!communityId,
       });
       ```

    4. Keep all existing hooks unchanged. The new useActiveInvitationsRealtime is an ADDITION, not a replacement. Screens can opt-in to real-time by using the new hook.

    **C. Update packages/mobile/src/hooks/useGateOps.ts**

    Add real-time subscription for the guard's expected visitors queue.

    1. Import `useRealtimeSubscription` from './useRealtimeSubscription'
    2. Find or create the hook that fetches expected visitors for the guard (likely a query on invitations table with status=approved and today's date range).

    If no such hook exists, create `useExpectedVisitorsRealtime(communityId: string)`:
    ```typescript
    export function useExpectedVisitorsRealtime() {
      const { communityId } = useAuth();

      const query = useQuery({
        queryKey: [...queryKeys.visitors.active(communityId!).queryKey, 'guard-queue'],
        queryFn: async () => {
          const today = new Date().toISOString().split('T')[0];
          const { data, error } = await supabase
            .from('invitations')
            .select('*, units(unit_number), residents!invitations_created_by_resident_id_fkey(first_name, paternal_surname)')
            .eq('community_id', communityId!)
            .in('status', ['approved', 'pending'])
            .is('cancelled_at', null)
            .is('deleted_at', null)
            .gte('valid_until', new Date().toISOString())
            .lte('valid_from', new Date().toISOString())
            .order('valid_from', { ascending: true });

          if (error) throw error;
          return data;
        },
        enabled: !!communityId,
        refetchInterval: 60_000, // Fallback polling every 60s
      });

      // Real-time: new invitations or status changes
      useRealtimeSubscription({
        channelName: `guard-visitor-queue-${communityId}`,
        table: 'invitations',
        event: '*',
        queryKeys: [
          [...queryKeys.visitors.active(communityId!).queryKey, 'guard-queue'],
          queryKeys.visitors._def,
        ],
        enabled: !!communityId,
      });

      // Real-time: access log entries (someone checked in/out)
      useRealtimeSubscription({
        channelName: `guard-access-logs-${communityId}`,
        table: 'access_logs',
        event: 'INSERT',
        queryKeys: [
          [...queryKeys.visitors.active(communityId!).queryKey, 'guard-queue'],
          queryKeys.accessLogs._def,
        ],
        enabled: !!communityId,
      });

      return query;
    }
    ```

    If an expected visitors hook already exists in the file, add the useRealtimeSubscription calls to it instead of creating a new hook. Check the existing useGateOps.ts content first.

    IMPORTANT: Do NOT break existing hooks. Add real-time as new hooks or augment existing ones. Keep existing query functionality as-is.
  </action>
  <verify>
    useRealtimeSubscription.ts exports the generic hook.
    useVisitors.ts exports useActiveInvitationsRealtime (new hook with real-time).
    useGateOps.ts has real-time subscription for guard expected visitors.
    All hooks return cleanup functions (channel.unsubscribe) in useEffect.
    TypeScript compiles: `cd packages/mobile && npx tsc --noEmit`
  </verify>
  <done>
    Generic useRealtimeSubscription hook provides reusable Supabase Realtime integration with TanStack Query invalidation.
    Resident visitor list updates in real-time when invitation status changes or access logs are created.
    Guard expected visitors queue updates in real-time when new invitations are created or visitors check in.
    All subscriptions properly clean up on unmount.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notification preferences screen and hooks</name>
  <files>
    packages/mobile/src/hooks/useNotificationPreferences.ts
    packages/mobile/src/components/notifications/NotificationPreferences.tsx
    packages/mobile/app/(resident)/more/notification-settings.tsx
  </files>
  <action>
    **A. Create packages/mobile/src/hooks/useNotificationPreferences.ts**

    Hooks for reading and writing notification preferences stored as JSON in residents.notification_preferences column.

    Preference schema (TypeScript interface):
    ```typescript
    interface NotificationPreferences {
      // Per-type toggles (true = enabled, false = disabled)
      types: {
        visitor_arrived: boolean;
        payment_due: boolean;
        payment_received: boolean;
        ticket_created: boolean;
        ticket_status_changed: boolean;
        announcement: boolean;
        package_arrived: boolean;
        emergency_alert: boolean;  // Always true, UI shows as disabled toggle
        survey_published: boolean;
        document_published: boolean;
      };
      // Global settings
      push_enabled: boolean;      // Master push toggle
      quiet_hours: {
        enabled: boolean;
        start: string;  // "22:00"
        end: string;    // "08:00"
      };
    }

    const DEFAULT_PREFERENCES: NotificationPreferences = {
      types: {
        visitor_arrived: true,
        payment_due: true,
        payment_received: true,
        ticket_created: true,
        ticket_status_changed: true,
        announcement: true,
        package_arrived: true,
        emergency_alert: true,
        survey_published: true,
        document_published: true,
      },
      push_enabled: true,
      quiet_hours: { enabled: false, start: '22:00', end: '08:00' },
    };
    ```

    1. `useNotificationPreferences()` hook:
       - Uses useAuth() to get residentId
       - useQuery with queryKey: queryKeys.notifications.preferences(residentId!).queryKey
       - Fetches: `supabase.from('residents').select('notification_preferences').eq('id', residentId!).single()`
       - Parse JSON result, merge with DEFAULT_PREFERENCES (for any missing keys)
       - Return parsed NotificationPreferences object
       - enabled: !!residentId

    2. `useUpdateNotificationPreferences()` mutation:
       - Uses useAuth() to get residentId
       - useMutation that updates residents.notification_preferences:
         ```
         supabase.from('residents').update({
           notification_preferences: preferences as unknown as Json
         }).eq('id', residentId!)
         ```
       - Use 'as never' cast if needed for the Json type (consistent with project pattern)
       - Invalidate notifications.preferences query on success

    Export: NotificationPreferences type, DEFAULT_PREFERENCES constant, useNotificationPreferences, useUpdateNotificationPreferences.

    **B. Create packages/mobile/src/components/notifications/NotificationPreferences.tsx**

    Settings screen component with grouped toggle switches.

    Layout:
    1. SafeAreaView + ScrollView with white background
    2. Header: "Preferencias de Notificaciones" (text-xl font-bold)

    3. Section: "General"
       - Master push toggle: "Notificaciones Push" with Switch component
       - When OFF, all type toggles appear disabled/grayed

    4. Section: "Tipos de Notificacion"
       - Each notification type as a row with label + Switch toggle:
         - "Llegada de visitantes" -> visitor_arrived
         - "Pagos pendientes" -> payment_due
         - "Confirmacion de pago" -> payment_received
         - "Tickets de mantenimiento" -> ticket_created
         - "Actualizacion de tickets" -> ticket_status_changed
         - "Anuncios" -> announcement
         - "Paquetes recibidos" -> package_arrived
         - "Alertas de emergencia" -> emergency_alert (Switch disabled, always on, show "(siempre activo)" label)
         - "Encuestas" -> survey_published
         - "Documentos" -> document_published

    5. Section: "Horario Silencioso"
       - Toggle: "Activar horario silencioso" with Switch
       - When ON, show two time inputs (TextInput with placeholder "22:00" and "08:00"):
         - "Inicio:" with value from quiet_hours.start
         - "Fin:" with value from quiet_hours.end
       - Simple text inputs for time (HH:MM format) -- no time picker needed for v1

    6. State management:
       - Load preferences from useNotificationPreferences() into local state
       - On any toggle change, update local state immediately (optimistic)
       - Auto-save: useEffect with debounce (500ms) that calls updatePreferences mutation when local state differs from server state
       - OR: Add a "Guardar" button at the bottom that saves all changes at once (simpler, less error-prone)
       - Recommend: "Guardar" button approach for simplicity

    7. Loading state: show ActivityIndicator while preferences load
    8. Error state: show error message if load fails

    Styling: NativeWind classes. Each toggle row: flex-row justify-between items-center py-3 border-b border-gray-100. Section headers: text-lg font-semibold text-gray-800 mt-6 mb-2. Use Switch from react-native with trackColor and thumbColor.

    **C. Create packages/mobile/app/(resident)/more/notification-settings.tsx**

    Route screen:
    ```tsx
    import { NotificationPreferences } from '@/components/notifications/NotificationPreferences';
    export default function NotificationSettingsScreen() {
      return <NotificationPreferences />;
    }
    ```

    NOTE: This screen is under (resident)/more/ which uses a Stack layout. The existing more/_layout.tsx should already handle stack navigation. If it uses a different pattern, adapt accordingly. Check the existing more/_layout.tsx to confirm it's a Stack navigator, then this file will be auto-discovered.

    GUARD PREFERENCES: Guards use a different table (guards) which may not have notification_preferences column. For v1, notification preferences are resident-only. Guards receive all notifications. This can be extended later by adding a similar JSON column to the guards table.
  </action>
  <verify>
    useNotificationPreferences.ts exports the type, default, and both hooks.
    NotificationPreferences.tsx renders toggle list with all notification types.
    notification-settings.tsx route exists under (resident)/more/.
    Emergency alert toggle is visually present but disabled (always on).
    TypeScript compiles: `cd packages/mobile && npx tsc --noEmit`
  </verify>
  <done>
    Residents can view and update their notification preferences (per-type toggles, master push toggle, quiet hours).
    Preferences persist to residents.notification_preferences JSON column.
    Default preferences enable all notification types.
    Emergency alerts cannot be disabled (forced on).
    Settings accessible from the "More" tab navigation.
  </done>
</task>

</tasks>

<verification>
1. useRealtimeSubscription hook creates Supabase channel, subscribes to postgres_changes, invalidates TanStack queries, and cleans up on unmount
2. Resident visitor list has real-time variant (useActiveInvitationsRealtime) that updates when invitations change
3. Guard expected visitors queue has real-time that updates when new invitations arrive or access logs are created
4. Channel names are deterministic (no Date.now()) to prevent subscription churn
5. All subscriptions return cleanup in useEffect (channel.unsubscribe())
6. Notification preferences load from residents.notification_preferences JSON column
7. Default preferences enable all types, emergency_alert forced on
8. Preferences save via update mutation to residents table
9. Settings screen has per-type toggles, master push toggle, quiet hours section
10. TypeScript compiles without errors
</verification>

<success_criteria>
- Resident sees visitor invitation status changes without manual refresh (real-time via Supabase)
- Guard sees new expected visitors appear in queue without refresh
- Subscriptions clean up properly on navigation (no memory leaks, verified by cleanup in useEffect)
- Resident can toggle individual notification types on/off
- Emergency alert toggle is always on (disabled switch)
- Quiet hours can be enabled with start/end times
- Preferences persist across app restarts (stored in database)
- Guard notification preferences deferred to future iteration
</success_criteria>

<output>
After completion, create `.planning/phases/16-push-notifications-real-time/16-03-SUMMARY.md`
</output>
