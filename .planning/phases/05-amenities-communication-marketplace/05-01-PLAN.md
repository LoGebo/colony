---
phase: 05-amenities-communication-marketplace
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_amenity_enums.sql
  - supabase/migrations/TIMESTAMP_amenities_table.sql
  - supabase/migrations/TIMESTAMP_amenity_rules.sql
autonomous: true

must_haves:
  truths:
    - "Amenity types support pool, gym, salon, rooftop, bbq, court, room, parking, other"
    - "Amenities have schedules with per-day operating hours"
    - "Booking rules enforce quotas, advance windows, duration limits, blackouts"
    - "Rule validation function checks all active rules before allowing reservation"
    - "Each amenity can have multiple rules with priority ordering"
  artifacts:
    - path: "supabase/migrations/*_amenity_enums.sql"
      provides: "amenity_type, rule_type, reservation_status, waitlist_status enums"
      contains: "CREATE TYPE amenity_type"
    - path: "supabase/migrations/*_amenities_table.sql"
      provides: "amenities table with schedules and booking config"
      contains: "CREATE TABLE amenities"
    - path: "supabase/migrations/*_amenity_rules.sql"
      provides: "amenity_rules table and validate_booking_rules function"
      contains: "CREATE FUNCTION validate_booking_rules"
  key_links:
    - from: "amenities"
      to: "communities"
      via: "community_id FK with RLS"
    - from: "amenity_rules"
      to: "amenities"
      via: "amenity_id FK"
    - from: "validate_booking_rules"
      to: "amenity_rules"
      via: "queries rules by amenity_id"
---

<objective>
Create amenity definitions, schedules, and booking rules engine for UPOE community amenities.

Purpose: Establish the foundation for amenity reservations by defining what amenities exist (pools, gyms, salons), when they operate (schedules), and what rules govern their booking (quotas, advance windows, blackout dates). The rules engine is data-driven, allowing administrators to configure restrictions without code changes.

Output:
- amenity_type, rule_type, reservation_status, waitlist_status enums
- amenities table with schedules, capacity, photos, and booking configuration
- amenity_rules table with priority-ordered configurable rules
- validate_booking_rules() function for rule enforcement
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-amenities-communication-marketplace/05-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create amenity and reservation enums</name>
  <files>
    supabase/migrations/TIMESTAMP_amenity_enums.sql
  </files>
  <action>
Create amenity_type enum with 9 values:
- pool, gym, salon (event room), rooftop, bbq, court (tennis/paddle), room (meeting room), parking (guest parking), other

Create rule_type enum with 10 values for booking rule configuration:
- max_per_day (max reservations per unit per day)
- max_per_week (max reservations per unit per week)
- max_per_month (max reservations per unit per month)
- advance_min (minimum hours in advance to book)
- advance_max (maximum days in advance to book)
- duration_min (minimum duration in minutes)
- duration_max (maximum duration in minutes)
- blackout (blocked dates/times)
- require_deposit (requires deposit)
- owner_only (only unit owners can book)

Create reservation_status enum with 5 values:
- pending, confirmed, cancelled, completed, no_show

Create waitlist_status enum with 4 values:
- waiting, promoted, expired, cancelled

Add comments explaining each enum value's purpose and typical rule_value JSONB format for rule_type.
  </action>
  <verify>
Run migration via Supabase MCP. Query pg_type for all 4 enums. Verify each has the expected values.
  </verify>
  <done>
amenity_type (9 values), rule_type (10 values), reservation_status (5 values), waitlist_status (4 values) enums exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create amenities table with schedules</name>
  <files>
    supabase/migrations/TIMESTAMP_amenities_table.sql
  </files>
  <action>
Create amenities table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL
- description TEXT
- amenity_type amenity_type NOT NULL
- location TEXT (e.g., "Building A, Floor 2")
- floor_number INTEGER
- capacity INTEGER (max concurrent users)
- schedule JSONB NOT NULL DEFAULT '{}' for operating hours:
  Example: {"mon": {"open": "06:00", "close": "22:00"}, "sun": {"open": "08:00", "close": "20:00"}}
- requires_reservation BOOLEAN DEFAULT TRUE
- min_advance_hours INTEGER DEFAULT 1
- max_advance_days INTEGER DEFAULT 30
- default_duration_minutes INTEGER DEFAULT 60
- hourly_rate money_amount (nullable, for paid amenities)
- deposit_amount money_amount (nullable, for damage deposits)
- photo_urls TEXT[] (array of storage URLs)
- rules_document_url TEXT (PDF with full rules)
- status general_status NOT NULL DEFAULT 'active'
- maintenance_notes TEXT
- Standard audit columns (created_at, updated_at, deleted_at, created_by)
- UNIQUE (community_id, name)

Add RLS policies:
- super_admin_all_amenities: Platform admins full access
- users_view_amenities: Users can view their community's amenities
- admins_manage_amenities: Admins can INSERT/UPDATE/DELETE

Add indexes:
- community_id + status (for active amenity list)
- amenity_type (for filtering by type)

Attach set_audit_fields trigger.

Add comments documenting the schedule JSONB format and booking configuration fields.
  </action>
  <verify>
Run migration. Query amenities table definition. Test inserting an amenity with schedule JSONB. Verify RLS policies exist.
  </verify>
  <done>
amenities table exists with schedules, capacity, booking config, RLS policies active, audit trigger attached.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create amenity_rules table and validation function</name>
  <files>
    supabase/migrations/TIMESTAMP_amenity_rules.sql
  </files>
  <action>
Create amenity_rules table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- amenity_id UUID FK to amenities(id) ON DELETE CASCADE
- rule_type rule_type NOT NULL
- rule_value JSONB NOT NULL (type-specific configuration):
  - max_per_day: {"limit": 1}
  - advance_max: {"days": 30}
  - blackout: {"start": "2026-12-24", "end": "2026-12-26", "reason": "Holidays"}
  - duration_max: {"minutes": 120}
  - require_deposit: {"amount": 500}
- priority INTEGER NOT NULL DEFAULT 0 (higher = checked first)
- effective_from DATE (nullable, for seasonal rules)
- effective_until DATE (nullable)
- is_active BOOLEAN DEFAULT TRUE
- Standard audit columns
- UNIQUE (amenity_id, rule_type) WHERE effective_from IS NULL (one default per type)

Create validate_booking_rules() function:
- Parameters: p_amenity_id UUID, p_unit_id UUID, p_start_time TIMESTAMPTZ, p_end_time TIMESTAMPTZ
- RETURNS TABLE (is_valid BOOLEAN, violated_rule TEXT, message TEXT)
- LANGUAGE plpgsql, STABLE, SECURITY DEFINER, SET search_path = ''
- Calculates advance_hours, duration_minutes from parameters
- Loops through active rules for amenity ordered by priority DESC
- For each rule_type, validates against rule_value:
  - advance_min: Check advance_hours >= rule_value->>'hours'
  - advance_max: Check advance_hours <= rule_value->>'days' * 24
  - max_per_day: COUNT existing confirmed reservations for unit on that day
  - duration_min: Check duration_minutes >= rule_value->>'minutes'
  - duration_max: Check duration_minutes <= rule_value->>'minutes'
  - blackout: Check start_time::DATE not between start and end dates
  - owner_only: Check occupancy_type = 'owner' for resident
- Returns (false, rule_type, message) on first violation
- Returns (true, NULL, NULL) if all rules pass

Add RLS policies:
- super_admin_all_amenity_rules
- users_view_amenity_rules
- admins_manage_amenity_rules

Add indexes:
- amenity_id + is_active (for rule lookup)
- priority DESC (for ordered evaluation)

Add comments with example rule_value formats for each rule_type.
  </action>
  <verify>
Run migration. Insert test amenity with rules (max_per_day=1, advance_max=30 days). Call validate_booking_rules() with valid params - should return is_valid=true. Call with booking 60 days ahead - should return is_valid=false with advance_max violation.
  </verify>
  <done>
amenity_rules table exists with JSONB configuration, validate_booking_rules() correctly evaluates rules and returns violations.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('amenity_type', 'rule_type', 'reservation_status', 'waitlist_status')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('amenities', 'amenity_rules')
3. Query: SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'amenities'
4. Test: Insert amenity with schedule JSONB, verify stored correctly
5. Test: Insert rules for amenity, call validate_booking_rules() with valid/invalid times
6. Test: Verify RLS isolates amenities by community
</verification>

<success_criteria>
- 4 new enum types created (amenity_type, rule_type, reservation_status, waitlist_status)
- amenities table with schedule JSONB, capacity, booking configuration
- amenity_rules table with type-specific JSONB configuration
- validate_booking_rules() function returns violations correctly
- All tables have RLS with community isolation
- Audit triggers attached
</success_criteria>

<output>
After completion, create `.planning/phases/05-amenities-communication-marketplace/05-01-SUMMARY.md`
</output>
