---
phase: 05-amenities-communication-marketplace
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - supabase/migrations/TIMESTAMP_btree_gist_extension.sql
  - supabase/migrations/TIMESTAMP_reservations_table.sql
  - supabase/migrations/TIMESTAMP_reservation_waitlist.sql
  - supabase/migrations/TIMESTAMP_reservation_fees.sql
autonomous: true

must_haves:
  truths:
    - "btree_gist extension enabled for exclusion constraints"
    - "Reservations use tstzrange with '[)' bounds for slot times"
    - "Exclusion constraint prevents overlapping reservations for same amenity"
    - "Waitlist entries auto-promote via trigger when reservations cancel"
    - "Reservation fees link to transactions for deposit/usage tracking"
    - "Only confirmed, non-deleted reservations trigger exclusion constraint"
  artifacts:
    - path: "supabase/migrations/*_btree_gist_extension.sql"
      provides: "btree_gist extension for exclusion constraints"
      contains: "CREATE EXTENSION IF NOT EXISTS btree_gist"
    - path: "supabase/migrations/*_reservations_table.sql"
      provides: "reservations table with tstzrange and exclusion constraint"
      contains: "EXCLUDE USING GIST"
    - path: "supabase/migrations/*_reservation_waitlist.sql"
      provides: "reservation_waitlist table with auto-promote trigger"
      contains: "CREATE FUNCTION promote_from_waitlist"
    - path: "supabase/migrations/*_reservation_fees.sql"
      provides: "reservation_fees table linking to transactions"
      contains: "CREATE TABLE reservation_fees"
  key_links:
    - from: "reservations"
      to: "amenities"
      via: "amenity_id FK with exclusion constraint"
    - from: "reservations"
      to: "units"
      via: "unit_id FK"
    - from: "reservation_waitlist"
      to: "reservations"
      via: "promoted_to_reservation_id FK on promotion"
    - from: "promote_from_waitlist"
      to: "reservation_waitlist + reservations"
      via: "trigger on reservation cancellation"
---

<objective>
Create reservation system with double-booking prevention and waitlist auto-promotion for UPOE amenities.

Purpose: Enable residents to book amenities with database-enforced prevention of double-booking using PostgreSQL exclusion constraints. When slots become available due to cancellations, waitlist entries auto-promote. Fees are tracked for deposits and usage charges.

Output:
- btree_gist extension for exclusion constraints
- reservations table with tstzrange and EXCLUDE USING GIST constraint
- reservation_waitlist table with FIFO positioning
- promote_from_waitlist() trigger for automatic promotion on cancellation
- reservation_fees table linking to financial transactions
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-amenities-communication-marketplace/05-RESEARCH.md
@.planning/phases/05-amenities-communication-marketplace/05-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-01-SUMMARY.md
@.planning/phases/04-financial-engine/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable btree_gist and create reservations table</name>
  <files>
    supabase/migrations/TIMESTAMP_btree_gist_extension.sql
    supabase/migrations/TIMESTAMP_reservations_table.sql
  </files>
  <action>
Create extension migration:
- CREATE EXTENSION IF NOT EXISTS btree_gist;
- Add comment explaining this enables exclusion constraints combining scalar (UUID) and range (tstzrange) types

Create reservations table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- amenity_id UUID FK to amenities(id) ON DELETE RESTRICT
- unit_id UUID FK to units(id) ON DELETE RESTRICT
- resident_id UUID FK to residents(id) ON DELETE RESTRICT
- reserved_range TSTZRANGE NOT NULL (time slot)
- status reservation_status NOT NULL DEFAULT 'confirmed'
- notes TEXT (guest count, special requests)
- confirmed_at TIMESTAMPTZ DEFAULT now()
- cancelled_at TIMESTAMPTZ
- cancelled_by UUID FK to auth.users(id)
- cancellation_reason TEXT
- completed_at TIMESTAMPTZ
- no_show_at TIMESTAMPTZ
- Standard audit columns
- EXCLUDE USING GIST (amenity_id WITH =, reserved_range WITH &&) WHERE (status = 'confirmed' AND deleted_at IS NULL)

CRITICAL: Use '[)' bounds for tstzrange (inclusive start, exclusive end) so adjacent slots (14:00-15:00, 15:00-16:00) don't conflict.

Create create_reservation() function:
- Parameters: p_amenity_id, p_unit_id, p_resident_id, p_start_time, p_end_time
- RETURNS UUID (reservation_id)
- LANGUAGE plpgsql, SECURITY DEFINER
- First calls validate_booking_rules() - if not valid, raise exception with message
- Then inserts reservation with tstzrange(p_start_time, p_end_time, '[)')
- Returns reservation_id

Add RLS policies:
- super_admin_all_reservations
- users_view_own_reservations: residents see their own
- users_view_community_reservations: admins see all in community
- residents_create_reservations: INSERT for authenticated users
- residents_cancel_own: UPDATE status to cancelled WHERE resident_id = auth.uid()

Add indexes:
- amenity_id + reserved_range (GIST for constraint and queries)
- unit_id + status (for unit history)
- resident_id + status (for resident history)
- status partial WHERE status = 'confirmed' (for availability queries)
  </action>
  <verify>
Run migrations. Verify btree_gist extension active. Insert two non-overlapping reservations - success. Attempt overlapping reservation for same amenity - must fail with exclusion constraint error. Test cancelled reservation doesn't block new booking.
  </verify>
  <done>
btree_gist enabled, reservations table with exclusion constraint prevents double-booking, create_reservation() validates rules before insert.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create waitlist table with auto-promotion trigger</name>
  <files>
    supabase/migrations/TIMESTAMP_reservation_waitlist.sql
  </files>
  <action>
Create reservation_waitlist table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- amenity_id UUID FK to amenities(id) ON DELETE RESTRICT
- unit_id UUID FK to units(id) ON DELETE RESTRICT
- resident_id UUID FK to residents(id) ON DELETE RESTRICT
- requested_range TSTZRANGE NOT NULL (desired time slot)
- position INTEGER NOT NULL (FIFO order per amenity per day)
- status waitlist_status NOT NULL DEFAULT 'waiting'
- promoted_to_reservation_id UUID FK to reservations(id)
- promoted_at TIMESTAMPTZ
- expires_at TIMESTAMPTZ NOT NULL (auto-expire if not promoted)
- Standard audit columns (no deleted_at - use status=cancelled)
- UNIQUE (amenity_id, position, (lower(requested_range)::DATE))

Create get_next_waitlist_position() function:
- Parameters: p_amenity_id, p_date
- Returns next position number for that amenity on that date

Create add_to_waitlist() function:
- Parameters: p_amenity_id, p_unit_id, p_resident_id, p_start_time, p_end_time, p_expires_hours
- Calculates position, sets expires_at = now() + p_expires_hours hours
- Inserts waitlist entry
- Returns waitlist entry id

Create promote_from_waitlist() trigger function:
- LANGUAGE plpgsql, SECURITY DEFINER, SET search_path = ''
- Triggered AFTER UPDATE ON reservations
- Only processes when NEW.status = 'cancelled' AND OLD.status != 'cancelled'
- Finds first waiting entry for same amenity with overlapping requested_range
- Uses FOR UPDATE SKIP LOCKED to prevent race conditions
- If found:
  - Creates new reservation for waitlist entry
  - Updates waitlist entry: status='promoted', promoted_to_reservation_id, promoted_at
  - Calls pg_notify('waitlist_promotion', JSON payload) for real-time UI

Attach trigger: AFTER UPDATE ON reservations FOR EACH ROW WHEN (NEW.status = 'cancelled' AND OLD.status != 'cancelled')

Add RLS policies:
- super_admin_all_waitlist
- users_view_own_waitlist
- residents_manage_own_waitlist

Add indexes:
- amenity_id + status + expires_at (for promotion queries)
- resident_id (for user queries)
  </action>
  <verify>
Run migration. Add entry to waitlist. Cancel a reservation that overlaps - verify waitlist entry auto-promoted to new reservation. Verify pg_notify called. Test expired entries not promoted.
  </verify>
  <done>
reservation_waitlist table exists, add_to_waitlist() calculates position, promote_from_waitlist() trigger auto-creates reservation on cancellation with SKIP LOCKED for concurrency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create reservation fees table</name>
  <files>
    supabase/migrations/TIMESTAMP_reservation_fees.sql
  </files>
  <action>
Create fee_type_reservation enum with 4 values:
- deposit (refundable damage deposit)
- usage (hourly/flat usage fee)
- no_show (penalty for not showing up)
- cancellation (late cancellation fee)

Create reservation_fees table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- reservation_id UUID FK to reservations(id) ON DELETE RESTRICT
- fee_type fee_type_reservation NOT NULL
- amount money_amount NOT NULL
- transaction_id UUID FK to transactions(id) (links to financial engine)
- status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'paid', 'refunded', 'waived'))
- paid_at TIMESTAMPTZ
- refunded_at TIMESTAMPTZ
- refund_transaction_id UUID FK to transactions(id)
- notes TEXT
- Standard audit columns
- UNIQUE (reservation_id, fee_type) for deposit/usage (can have multiple no_show)

Create charge_reservation_deposit() function:
- Parameters: p_reservation_id
- Gets reservation and amenity
- If amenity.deposit_amount IS NOT NULL:
  - Creates reservation_fee record
  - Creates transaction via record_charge() linking to fee
  - Returns fee id
- Returns NULL if no deposit required

Create refund_reservation_deposit() function:
- Parameters: p_reservation_id, p_refund_reason
- Finds deposit fee for reservation
- If status = 'paid':
  - Creates refund transaction
  - Updates fee status to 'refunded'
  - Returns refund transaction id

Add RLS policies:
- super_admin_all_reservation_fees
- users_view_own_fees
- admins_manage_fees

Add indexes:
- reservation_id (for reservation fee lookup)
- status partial WHERE status = 'pending' (for pending fees)
  </action>
  <verify>
Run migration. Create reservation for amenity with deposit. Call charge_reservation_deposit() - verify fee and transaction created. Call refund_reservation_deposit() - verify refund transaction created.
  </verify>
  <done>
fee_type_reservation enum exists, reservation_fees table links to transactions, deposit charge/refund functions work with financial engine.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_extension WHERE extname = 'btree_gist'
2. Query: SELECT conname FROM pg_constraint WHERE conname LIKE '%no_overlap%'
3. Test: Insert two overlapping reservations for same amenity - second must fail
4. Test: Cancel reservation with waitlist entry - entry auto-promoted
5. Test: charge_reservation_deposit() creates linked transaction
6. Test: Exclusion constraint allows overlapping reservations for DIFFERENT amenities
</verification>

<success_criteria>
- btree_gist extension enabled
- reservations table with EXCLUDE USING GIST prevents double-booking
- '[)' bounds allow adjacent slots without conflict
- reservation_waitlist with auto-promotion trigger on cancellation
- FOR UPDATE SKIP LOCKED prevents concurrent promotion races
- reservation_fees integrates with Phase 4 financial engine
- All tables have RLS with community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/05-amenities-communication-marketplace/05-02-SUMMARY.md`
</output>
