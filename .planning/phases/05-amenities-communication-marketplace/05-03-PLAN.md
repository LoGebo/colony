---
phase: 05-amenities-communication-marketplace
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_channel_enums.sql
  - supabase/migrations/TIMESTAMP_channels_table.sql
  - supabase/migrations/TIMESTAMP_posts_table.sql
  - supabase/migrations/TIMESTAMP_comments_reactions.sql
autonomous: true

must_haves:
  truths:
    - "Channels support general, building, committee, announcements, marketplace types"
    - "Posts have content, media, and are linked to channels"
    - "Comments use adjacency list with parent_comment_id for nesting"
    - "Comment depth and root_comment_id auto-set via trigger"
    - "Reactions are unique per user per post with denormalized counters"
    - "Reaction counters on posts auto-update via trigger"
  artifacts:
    - path: "supabase/migrations/*_channel_enums.sql"
      provides: "channel_type, post_type enums"
      contains: "CREATE TYPE channel_type"
    - path: "supabase/migrations/*_channels_table.sql"
      provides: "channels table with access control"
      contains: "CREATE TABLE channels"
    - path: "supabase/migrations/*_posts_table.sql"
      provides: "posts table with reaction_counts JSONB"
      contains: "CREATE TABLE posts"
    - path: "supabase/migrations/*_comments_reactions.sql"
      provides: "post_comments with hierarchy, post_reactions with counters"
      contains: "CREATE TABLE post_reactions"
  key_links:
    - from: "posts"
      to: "channels"
      via: "channel_id FK"
    - from: "post_comments"
      to: "posts"
      via: "post_id FK with CASCADE"
    - from: "post_comments"
      to: "post_comments"
      via: "parent_comment_id FK for nesting"
    - from: "post_reactions"
      to: "posts.reaction_counts"
      via: "trigger updates JSONB counter"
---

<objective>
Create community discussion infrastructure with channels, posts, nested comments, and reactions for UPOE social wall.

Purpose: Enable community engagement through categorized discussion channels. Posts support various content types with media attachments. Comments use adjacency list pattern for efficient nesting. Reactions use denormalized counters for fast display with trigger-maintained integrity.

Output:
- channel_type, post_type enums
- channels table with access control configuration
- posts table with content, media, and reaction_counts JSONB
- post_comments table with adjacency list hierarchy
- post_reactions table with unique constraint and counter triggers
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-amenities-communication-marketplace/05-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md
@.planning/phases/02-identity-crm/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create channel and post enums, channels table</name>
  <files>
    supabase/migrations/TIMESTAMP_channel_enums.sql
    supabase/migrations/TIMESTAMP_channels_table.sql
  </files>
  <action>
Create channel_type enum with 5 values:
- general (open discussion)
- building (building-specific channels)
- committee (committee discussions)
- announcements (admin-only posting)
- marketplace (buy/sell/trade)

Create post_type enum with 4 values:
- discussion (general discussion)
- question (Q&A format)
- event (event announcement)
- poll (simple poll)

Create channels table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL
- description TEXT
- channel_type channel_type NOT NULL DEFAULT 'general'
- is_public BOOLEAN NOT NULL DEFAULT TRUE (visible to all residents)
- allowed_roles user_role[] DEFAULT ARRAY['admin', 'manager', 'resident']::user_role[]
- building TEXT (for building-specific channels)
- anyone_can_post BOOLEAN NOT NULL DEFAULT TRUE
- requires_moderation BOOLEAN NOT NULL DEFAULT FALSE
- icon TEXT (emoji or icon name)
- sort_order INTEGER NOT NULL DEFAULT 0
- status general_status NOT NULL DEFAULT 'active'
- Standard audit columns
- UNIQUE (community_id, name)

Add RLS policies:
- super_admin_all_channels
- users_view_public_channels: WHERE is_public = TRUE OR building matches user's unit
- admins_manage_channels
- users_view_allowed_channels: WHERE user role in allowed_roles

Add indexes:
- community_id + status + sort_order (for channel list)
- channel_type (for filtering)
- building (for building-specific queries)

Create default channels seed function create_default_channels(p_community_id):
- Creates: General, Announcements (announcements type, admin-only post), Marketplace
  </action>
  <verify>
Run migration. Query channels table definition. Insert test channels with different types. Verify RLS restricts based on allowed_roles.
  </verify>
  <done>
channel_type and post_type enums exist, channels table with access control, create_default_channels() function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create posts table with engagement metrics</name>
  <files>
    supabase/migrations/TIMESTAMP_posts_table.sql
  </files>
  <action>
Create posts table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- channel_id UUID FK to channels(id) ON DELETE CASCADE
- author_id UUID FK to residents(id) ON DELETE SET NULL
- post_type post_type NOT NULL DEFAULT 'discussion'
- title TEXT (optional for discussions)
- content TEXT NOT NULL
- media_urls TEXT[] (array of storage URLs)
- poll_options JSONB (for poll type): [{"id": "opt1", "text": "Yes"}, {"id": "opt2", "text": "No"}]
- poll_ends_at TIMESTAMPTZ (for polls)
- poll_results JSONB (computed after poll ends)
- reaction_counts JSONB NOT NULL DEFAULT '{}' (denormalized: {"like": 5, "love": 2})
- comment_count INTEGER NOT NULL DEFAULT 0 (denormalized)
- view_count INTEGER NOT NULL DEFAULT 0
- is_pinned BOOLEAN NOT NULL DEFAULT FALSE
- is_locked BOOLEAN NOT NULL DEFAULT FALSE (no new comments)
- is_hidden BOOLEAN NOT NULL DEFAULT FALSE
- hidden_reason TEXT
- hidden_by UUID FK to auth.users(id)
- Standard audit columns

Add RLS policies:
- super_admin_all_posts
- users_view_posts: view posts in channels they can access, not hidden
- authors_manage_own_posts: UPDATE/DELETE own posts
- admins_moderate_posts: UPDATE is_hidden, is_pinned, is_locked
- users_create_posts: INSERT in channels where anyone_can_post OR user is admin

Create increment_post_view_count() function:
- Parameters: p_post_id
- Increments view_count atomically
- SECURITY DEFINER to bypass RLS for count update

Add indexes:
- channel_id + is_pinned DESC + created_at DESC (for channel feed)
- author_id (for user's posts)
- community_id + created_at DESC (for community feed)
- is_hidden partial WHERE is_hidden = FALSE (for visible posts)
  </action>
  <verify>
Run migration. Insert test posts in channels. Verify media_urls array works. Test increment_post_view_count().
  </verify>
  <done>
posts table with content, media, poll support, denormalized counters, RLS based on channel access.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comments and reactions with triggers</name>
  <files>
    supabase/migrations/TIMESTAMP_comments_reactions.sql
  </files>
  <action>
Create post_comments table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- post_id UUID FK to posts(id) ON DELETE CASCADE
- parent_comment_id UUID FK to post_comments(id) ON DELETE CASCADE (adjacency list)
- depth INTEGER NOT NULL DEFAULT 0 (auto-set by trigger)
- root_comment_id UUID (auto-set: for fetching entire threads)
- author_id UUID FK to residents(id) ON DELETE SET NULL
- content TEXT NOT NULL
- is_hidden BOOLEAN NOT NULL DEFAULT FALSE
- hidden_reason TEXT
- hidden_by UUID FK to auth.users(id)
- Standard audit columns
- CHECK (depth <= 20) to prevent excessive nesting

Create set_comment_hierarchy() trigger function:
- BEFORE INSERT
- If parent_comment_id IS NULL:
  - depth = 0
  - root_comment_id = NEW.id
- Else:
  - Get parent's depth and root_comment_id
  - depth = parent.depth + 1
  - root_comment_id = COALESCE(parent.root_comment_id, parent.id)

Attach trigger BEFORE INSERT ON post_comments

Create update_post_comment_count() trigger function:
- AFTER INSERT: UPDATE posts SET comment_count = comment_count + 1
- AFTER DELETE: UPDATE posts SET comment_count = comment_count - 1

Attach trigger AFTER INSERT OR DELETE ON post_comments

Create post_reactions table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- post_id UUID FK to posts(id) ON DELETE CASCADE
- resident_id UUID FK to residents(id) ON DELETE CASCADE
- reaction_type TEXT NOT NULL (e.g., 'like', 'love', 'laugh', 'sad', 'angry')
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE (post_id, resident_id) - one reaction per user per post

Create update_reaction_counts() trigger function:
- ON INSERT: Increment posts.reaction_counts->{reaction_type} by 1
- ON DELETE: Decrement posts.reaction_counts->{reaction_type} by 1
- ON UPDATE (reaction change): Decrement old type, increment new type
- Use jsonb_set with COALESCE for counter initialization

Attach trigger AFTER INSERT OR UPDATE OR DELETE ON post_reactions

Add RLS policies for both tables:
- super_admin_all
- users_view (same post access rules)
- authors_manage_own (comments and reactions)
- admins_moderate (hide comments)

Add indexes:
- post_comments: post_id + created_at (for comment feed)
- post_comments: parent_comment_id (for replies)
- post_comments: root_comment_id (for thread fetch)
- post_reactions: post_id + reaction_type (for reaction queries)

Create get_comment_thread() function using recursive CTE:
- Parameters: p_post_id
- Returns comments in tree order with path array for sorting
  </action>
  <verify>
Run migration. Insert comment, verify depth=0 and root_comment_id set. Insert reply, verify depth=1 and same root. Insert reaction, verify posts.reaction_counts updated. Delete reaction, verify counter decremented. Test unique constraint prevents double reactions.
  </verify>
  <done>
post_comments with adjacency list and auto-hierarchy trigger, post_reactions with unique per user and counter triggers, comment_count maintained on posts.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('channel_type', 'post_type')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('channels', 'posts', 'post_comments', 'post_reactions')
3. Test: Insert channel, post, comment, reply - verify depth hierarchy correct
4. Test: Insert reaction, check posts.reaction_counts JSONB updated
5. Test: Delete reaction, verify counter decremented
6. Test: Attempt second reaction from same user - must fail with unique constraint
7. Test: Use get_comment_thread() recursive CTE - verify tree order
</verification>

<success_criteria>
- channel_type and post_type enums created
- channels table with access control (allowed_roles, anyone_can_post)
- posts table with media, polls, denormalized counters
- post_comments with adjacency list hierarchy auto-computed via trigger
- post_reactions with unique constraint and counter trigger
- Reaction counters stay synchronized with actual reactions
- All tables have RLS with community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/05-amenities-communication-marketplace/05-03-SUMMARY.md`
</output>
