---
phase: 05-amenities-communication-marketplace
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - supabase/migrations/TIMESTAMP_announcement_enums.sql
  - supabase/migrations/TIMESTAMP_announcements_table.sql
  - supabase/migrations/TIMESTAMP_surveys_table.sql
  - supabase/migrations/TIMESTAMP_service_notifications.sql
autonomous: true

must_haves:
  truths:
    - "Announcements target segments (all, owners, tenants, building, role)"
    - "Recipients fan-out table tracks delivery and read receipts per resident"
    - "Read counts auto-update via trigger when recipients mark as read"
    - "Surveys enforce one-vote-per-unit with UNIQUE constraint"
    - "Vote weight snapshots unit coefficient at vote time"
    - "Service notifications alert residents of visitor/delivery arrivals"
  artifacts:
    - path: "supabase/migrations/*_announcement_enums.sql"
      provides: "announcement_segment enum"
      contains: "CREATE TYPE announcement_segment"
    - path: "supabase/migrations/*_announcements_table.sql"
      provides: "announcements and announcement_recipients tables"
      contains: "CREATE TABLE announcement_recipients"
    - path: "supabase/migrations/*_surveys_table.sql"
      provides: "surveys and survey_votes with one-per-unit constraint"
      contains: "UNIQUE (survey_id, unit_id)"
    - path: "supabase/migrations/*_service_notifications.sql"
      provides: "service_notifications table for arrivals"
      contains: "CREATE TABLE service_notifications"
  key_links:
    - from: "announcement_recipients"
      to: "announcements"
      via: "announcement_id FK with fan-out pattern"
    - from: "announcement_recipients.read_at"
      to: "announcements.read_count"
      via: "trigger updates counter"
    - from: "survey_votes"
      to: "surveys"
      via: "survey_id FK"
    - from: "survey_votes"
      to: "units"
      via: "unit_id with UNIQUE constraint for one-per-unit"
---

<objective>
Create announcements with targeted delivery, surveys with one-vote-per-unit, and service notifications for UPOE communication.

Purpose: Enable administration to send targeted announcements to specific segments (owners, tenants, buildings) with delivery and read tracking. Surveys support weighted voting by unit coefficient for HOA decisions. Service notifications alert residents of visitor/delivery arrivals.

Output:
- announcement_segment enum
- announcements table with targeting configuration
- announcement_recipients fan-out table with read receipts
- surveys table with voting configuration
- survey_votes table with one-per-unit enforcement and coefficient snapshot
- service_notifications table for arrival alerts
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-amenities-communication-marketplace/05-RESEARCH.md
@.planning/phases/05-amenities-communication-marketplace/05-03-SUMMARY.md
@.planning/phases/02-identity-crm/02-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create announcements with segment targeting</name>
  <files>
    supabase/migrations/TIMESTAMP_announcement_enums.sql
    supabase/migrations/TIMESTAMP_announcements_table.sql
  </files>
  <action>
Create announcement_segment enum with 7 values:
- all (everyone in community)
- owners (only owners)
- tenants (only tenants)
- building (specific building(s))
- unit_type (specific unit types)
- delinquent (units with outstanding balance)
- role (specific user roles)

Create announcements table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- title TEXT NOT NULL
- body TEXT NOT NULL
- media_urls TEXT[]
- created_by UUID FK to auth.users(id) NOT NULL
- target_segment announcement_segment NOT NULL DEFAULT 'all'
- target_criteria JSONB (segment-specific config):
  - building: {"buildings": ["Tower A", "Tower B"]}
  - unit_type: {"types": ["departamento"]}
  - delinquent: {"min_balance": 1000}
  - role: {"roles": ["admin", "manager"]}
- publish_at TIMESTAMPTZ NOT NULL DEFAULT now()
- expires_at TIMESTAMPTZ
- is_urgent BOOLEAN NOT NULL DEFAULT FALSE
- requires_acknowledgment BOOLEAN NOT NULL DEFAULT FALSE
- total_recipients INTEGER NOT NULL DEFAULT 0 (denormalized)
- read_count INTEGER NOT NULL DEFAULT 0 (denormalized)
- acknowledged_count INTEGER NOT NULL DEFAULT 0 (denormalized)
- status general_status NOT NULL DEFAULT 'active'
- Standard audit columns

Create announcement_recipients table (fan-out):
- id UUID PK (generate_uuid_v7)
- announcement_id UUID FK to announcements(id) ON DELETE CASCADE
- resident_id UUID FK to residents(id) ON DELETE CASCADE
- unit_id UUID FK to units(id)
- delivered_at TIMESTAMPTZ
- delivery_channel TEXT (push, email, sms, in_app)
- read_at TIMESTAMPTZ
- acknowledged_at TIMESTAMPTZ
- UNIQUE (announcement_id, resident_id)

Create expand_announcement_recipients() function:
- Parameters: p_announcement_id
- SECURITY DEFINER
- Reads announcement segment and criteria
- Inserts into announcement_recipients based on segment:
  - all: all active residents
  - owners: occupancy_type = 'owner'
  - tenants: occupancy_type = 'tenant'
  - building: unit.building IN criteria.buildings
  - unit_type: unit.unit_type IN criteria.types
  - delinquent: unit balance >= criteria.min_balance
  - role: user_role IN criteria.roles
- Updates announcements.total_recipients with count
- Batches inserts (1000 at a time) to avoid memory issues

Create update_announcement_read_count() trigger function:
- On UPDATE of announcement_recipients
- If NEW.read_at IS NOT NULL AND OLD.read_at IS NULL:
  - Increment announcements.read_count
- If NEW.acknowledged_at IS NOT NULL AND OLD.acknowledged_at IS NULL:
  - Increment announcements.acknowledged_count

Attach trigger AFTER UPDATE ON announcement_recipients

Add RLS policies:
- super_admin_all_announcements
- admins_manage_announcements
- users_view_own_announcements: via announcement_recipients

Add indexes:
- announcements: community_id + publish_at DESC (for feed)
- announcement_recipients: announcement_id + read_at (for read status)
- announcement_recipients: resident_id (for user's announcements)
  </action>
  <verify>
Run migration. Create announcement with segment='building' and criteria. Call expand_announcement_recipients() - verify recipients created for matching building only. Mark one as read - verify read_count incremented.
  </verify>
  <done>
announcements with segment targeting, announcement_recipients fan-out with read tracking, expand function handles batching, read count trigger works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create surveys with one-vote-per-unit</name>
  <files>
    supabase/migrations/TIMESTAMP_surveys_table.sql
  </files>
  <action>
Create surveys table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- title TEXT NOT NULL
- description TEXT
- options JSONB NOT NULL: [{"id": "opt1", "text": "Approve"}, {"id": "opt2", "text": "Reject"}]
- voting_method TEXT NOT NULL DEFAULT 'simple' CHECK (voting_method IN ('simple', 'coefficient'))
  - simple: one vote per unit, equal weight
  - coefficient: weighted by unit coefficient (Mexican indiviso)
- quorum_percentage NUMERIC(5,2) (required participation %)
- approval_threshold NUMERIC(5,2) (required approval %, e.g., 66.67 for 2/3)
- starts_at TIMESTAMPTZ NOT NULL
- ends_at TIMESTAMPTZ NOT NULL
- is_closed BOOLEAN NOT NULL DEFAULT FALSE
- results JSONB (computed after close): {"opt1": {"votes": 15, "weight": 65.5}, "opt2": {"votes": 8, "weight": 34.5}}
- created_by UUID FK to auth.users(id) NOT NULL
- Standard audit columns

Create survey_votes table:
- id UUID PK (generate_uuid_v7)
- survey_id UUID FK to surveys(id) ON DELETE CASCADE
- unit_id UUID FK to units(id) ON DELETE RESTRICT
- voted_by UUID FK to residents(id) ON DELETE SET NULL
- option_id TEXT NOT NULL
- vote_weight NUMERIC(7,4) NOT NULL DEFAULT 1 (snapshot of coefficient at vote time)
- voted_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE (survey_id, unit_id) -- ONE VOTE PER UNIT

Create cast_survey_vote() function:
- Parameters: p_survey_id, p_unit_id, p_option_id
- RETURNS TABLE (success BOOLEAN, message TEXT)
- SECURITY DEFINER
- Validates:
  - Survey exists and not deleted
  - Current time between starts_at and ends_at, not is_closed
  - Option exists in survey.options
  - User has owner/authorized occupancy for unit
- Gets vote_weight from unit.coefficient (or 1 for simple method)
- Inserts vote with ON CONFLICT (survey_id, unit_id) DO UPDATE for vote changes
- Returns success message

Create close_survey() function:
- Parameters: p_survey_id
- Computes results JSONB from survey_votes aggregating by option_id
- Sets is_closed = TRUE
- Returns results

Add RLS policies:
- super_admin_all_surveys
- admins_manage_surveys
- users_view_active_surveys: WHERE now() >= starts_at
- authorized_residents_vote: INSERT via cast_survey_vote()

Add indexes:
- surveys: community_id + starts_at DESC (for survey list)
- survey_votes: survey_id + option_id (for result aggregation)
- survey_votes: unit_id (for unit vote lookup)

Add comments explaining Mexican coefficient voting and quorum calculation.
  </action>
  <verify>
Run migration. Create survey with two options. Cast vote for unit - success. Attempt second vote from same unit - should update existing. Attempt vote from unauthorized user - should fail. Close survey - verify results computed.
  </verify>
  <done>
surveys with voting methods, survey_votes with one-per-unit UNIQUE constraint, coefficient snapshot at vote time, cast_survey_vote() validates authorization.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create service notifications for arrivals</name>
  <files>
    supabase/migrations/TIMESTAMP_service_notifications.sql
  </files>
  <action>
Create notification_type_service enum with 5 values:
- visitor_arrival (visitor at gate)
- delivery_arrival (package/delivery arrived)
- service_provider (scheduled service person arrived)
- guest_departure (guest left)
- emergency_alert (forwarded emergency)

Create service_notifications table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- unit_id UUID FK to units(id) ON DELETE RESTRICT
- resident_id UUID FK to residents(id) (target recipient)
- notification_type notification_type_service NOT NULL
- title TEXT NOT NULL
- body TEXT NOT NULL
- related_entity_type TEXT (visitor, invitation, package)
- related_entity_id UUID
- sent_at TIMESTAMPTZ NOT NULL DEFAULT now()
- delivered_at TIMESTAMPTZ
- delivery_channel TEXT (push, sms, in_app)
- read_at TIMESTAMPTZ
- action_taken TEXT (allowed, denied, called_back)
- action_at TIMESTAMPTZ
- expires_at TIMESTAMPTZ (notification relevance window)
- Standard audit columns (no deleted_at - archive pattern)

Create send_service_notification() function:
- Parameters: p_unit_id, p_notification_type, p_title, p_body, p_related_entity_type, p_related_entity_id
- Creates notification for all active residents of unit
- Calls pg_notify('service_notification', JSON payload) for real-time push
- Returns array of notification IDs created

Create mark_notification_read() function:
- Parameters: p_notification_id
- Sets read_at = now() WHERE resident_id matches auth.uid()

Add RLS policies:
- super_admin_all_service_notifications
- users_view_own_notifications: WHERE resident_id = auth.uid()
- guards_create_notifications: INSERT for guard role
- users_mark_read: UPDATE read_at for own notifications

Add indexes:
- resident_id + read_at (for unread notifications)
- unit_id + sent_at DESC (for unit notification history)
- notification_type + sent_at DESC (for type filtering)
- expires_at partial WHERE read_at IS NULL (for cleanup)

Add comments explaining the real-time notification flow (guard app -> pg_notify -> Supabase Realtime -> resident app).
  </action>
  <verify>
Run migration. Call send_service_notification() for a unit with multiple residents - verify one notification per resident created. Check pg_notify called. Mark one as read - verify read_at set.
  </verify>
  <done>
notification_type_service enum exists, service_notifications table with per-resident delivery, send_service_notification() creates for all unit residents, pg_notify for real-time.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('announcement_segment', 'notification_type_service')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('announcements', 'announcement_recipients', 'surveys', 'survey_votes', 'service_notifications')
3. Test: Create announcement with segment='owners', expand recipients - only owners get entries
4. Test: Cast survey vote, attempt duplicate from same unit - unique constraint enforced via UPSERT
5. Test: Send service notification to unit with 2 residents - 2 notifications created
6. Test: Mark announcement as read - read_count incremented
</verification>

<success_criteria>
- announcement_segment enum with 7 targeting options
- announcements with segment criteria and denormalized counters
- announcement_recipients fan-out with read/acknowledgment tracking
- expand_announcement_recipients() handles batching for large communities
- surveys with simple and coefficient voting methods
- survey_votes with UNIQUE (survey_id, unit_id) enforcing one-per-unit
- vote_weight snapshots coefficient at vote time
- service_notifications with per-resident delivery and real-time pg_notify
- All tables have RLS with community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/05-amenities-communication-marketplace/05-04-SUMMARY.md`
</output>
