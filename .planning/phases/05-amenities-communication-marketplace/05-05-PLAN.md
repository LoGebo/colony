---
phase: 05-amenities-communication-marketplace
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_marketplace_enums.sql
  - supabase/migrations/TIMESTAMP_marketplace_listings.sql
  - supabase/migrations/TIMESTAMP_exchange_zones.sql
  - supabase/migrations/TIMESTAMP_moderation_queue.sql
autonomous: true

must_haves:
  truths:
    - "Listings support sale, service, rental, wanted categories"
    - "Moderation status tracks pending, in_review, approved, rejected, flagged"
    - "Exchange zones define safe meeting points within community"
    - "Moderation queue uses FOR UPDATE SKIP LOCKED for concurrent processing"
    - "Claim function assigns items to moderators atomically"
    - "Listings expire after 30 days by default"
  artifacts:
    - path: "supabase/migrations/*_marketplace_enums.sql"
      provides: "listing_category, moderation_status enums"
      contains: "CREATE TYPE listing_category"
    - path: "supabase/migrations/*_marketplace_listings.sql"
      provides: "marketplace_listings table with moderation"
      contains: "CREATE TABLE marketplace_listings"
    - path: "supabase/migrations/*_exchange_zones.sql"
      provides: "exchange_zones and exchange_appointments tables"
      contains: "CREATE TABLE exchange_zones"
    - path: "supabase/migrations/*_moderation_queue.sql"
      provides: "moderation_queue with SKIP LOCKED claim function"
      contains: "FOR UPDATE SKIP LOCKED"
  key_links:
    - from: "marketplace_listings"
      to: "residents"
      via: "seller_id FK"
    - from: "marketplace_listings"
      to: "exchange_zones"
      via: "preferred_exchange_zone_id FK"
    - from: "moderation_queue"
      to: "marketplace_listings"
      via: "polymorphic item_type + item_id"
    - from: "claim_moderation_item"
      to: "moderation_queue"
      via: "FOR UPDATE SKIP LOCKED prevents concurrent claims"
---

<objective>
Create marketplace listings, exchange zones, and moderation queue for UPOE internal marketplace.

Purpose: Enable residents to buy, sell, rent, and offer services within their community. Safe exchange zones provide designated meeting points. The moderation queue ensures content review before publication using PostgreSQL's FOR UPDATE SKIP LOCKED for efficient concurrent moderator processing.

Output:
- listing_category, moderation_status enums
- marketplace_listings table with expiry and moderation status
- exchange_zones table with location and availability
- exchange_appointments table for scheduled meetups
- moderation_queue table with polymorphic references
- claim_moderation_item() and resolve_moderation() functions
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-amenities-communication-marketplace/05-RESEARCH.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create marketplace enums and listings table</name>
  <files>
    supabase/migrations/TIMESTAMP_marketplace_enums.sql
    supabase/migrations/TIMESTAMP_marketplace_listings.sql
  </files>
  <action>
Create listing_category enum with 4 values:
- sale (item for sale)
- service (service offered)
- rental (item for rent)
- wanted (looking for item/service)

Create moderation_status enum with 5 values:
- pending (awaiting review)
- in_review (claimed by moderator)
- approved (published)
- rejected (blocked)
- flagged (reported by users)

Create marketplace_listings table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- seller_id UUID FK to residents(id) ON DELETE CASCADE
- unit_id UUID FK to units(id) (seller's unit for trust)
- category listing_category NOT NULL
- title TEXT NOT NULL CHECK (char_length(title) BETWEEN 5 AND 100)
- description TEXT NOT NULL CHECK (char_length(description) >= 20)
- price money_amount (nullable for service/wanted)
- price_negotiable BOOLEAN NOT NULL DEFAULT FALSE
- image_urls TEXT[] (array of storage URLs)
- preferred_exchange_zone_id UUID FK to exchange_zones(id)
- moderation_status moderation_status NOT NULL DEFAULT 'pending'
- moderated_by UUID FK to auth.users(id)
- moderated_at TIMESTAMPTZ
- rejection_reason TEXT
- auto_flag_reasons TEXT[] (for auto-detected issues)
- view_count INTEGER NOT NULL DEFAULT 0
- inquiry_count INTEGER NOT NULL DEFAULT 0
- expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + interval '30 days')
- is_sold BOOLEAN NOT NULL DEFAULT FALSE
- sold_at TIMESTAMPTZ
- sold_to_resident_id UUID FK to residents(id)
- Standard audit columns

Create queue_listing_for_moderation() trigger function:
- AFTER INSERT on marketplace_listings
- Inserts entry into moderation_queue with item_type='listing'
- Sets priority based on seller's history (new sellers = higher priority)

Attach trigger AFTER INSERT ON marketplace_listings

Add RLS policies:
- super_admin_all_listings
- users_view_approved_listings: WHERE moderation_status = 'approved' AND deleted_at IS NULL
- sellers_view_own_listings: view all own listings regardless of status
- sellers_manage_own_listings: UPDATE/DELETE own listings
- admins_moderate_listings: UPDATE moderation_status, rejection_reason
- users_create_listings: INSERT for authenticated residents

Add indexes:
- community_id + moderation_status + expires_at (for approved listings)
- seller_id (for seller's listings)
- category + price (for filtering)
- expires_at partial WHERE moderation_status = 'approved' (for expiry cleanup)

Create increment_listing_view_count() and increment_listing_inquiry_count() functions.
  </action>
  <verify>
Run migration. Insert listing - verify auto-queued for moderation. Check RLS hides pending listings from other users. Approve listing - verify visible to all.
  </verify>
  <done>
listing_category and moderation_status enums exist, marketplace_listings with moderation workflow, auto-queue trigger, RLS restricts pending listings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create exchange zones and appointments</name>
  <files>
    supabase/migrations/TIMESTAMP_exchange_zones.sql
  </files>
  <action>
Create exchange_zones table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- name TEXT NOT NULL
- description TEXT
- location_instructions TEXT (directions within community)
- latitude NUMERIC(10,7) (for map display)
- longitude NUMERIC(10,7)
- amenity_id UUID FK to amenities(id) (if zone is at amenity)
- available_hours JSONB: {"mon": {"open": "08:00", "close": "20:00"}, "sat": {"open": "09:00", "close": "18:00"}}
- has_video_surveillance BOOLEAN NOT NULL DEFAULT FALSE
- has_lighting BOOLEAN NOT NULL DEFAULT TRUE
- is_indoor BOOLEAN NOT NULL DEFAULT FALSE
- status general_status NOT NULL DEFAULT 'active'
- Standard audit columns
- UNIQUE (community_id, name)

Create exchange_appointments table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- listing_id UUID FK to marketplace_listings(id) ON DELETE CASCADE
- exchange_zone_id UUID FK to exchange_zones(id) ON DELETE RESTRICT
- seller_id UUID FK to residents(id)
- buyer_id UUID FK to residents(id)
- scheduled_at TIMESTAMPTZ NOT NULL
- duration_minutes INTEGER NOT NULL DEFAULT 30
- status approval_status NOT NULL DEFAULT 'pending'
  - pending (proposed)
  - approved (confirmed by both parties)
  - completed
  - cancelled
- seller_confirmed BOOLEAN
- buyer_confirmed BOOLEAN
- completed_at TIMESTAMPTZ
- notes TEXT
- Standard audit columns
- CHECK (seller_id != buyer_id)

Create confirm_exchange_completion() function:
- Parameters: p_appointment_id, p_role ('seller' or 'buyer')
- Sets seller_confirmed or buyer_confirmed = TRUE
- If both confirmed:
  - Sets status = 'completed', completed_at = now()
  - Updates marketplace_listings: is_sold = TRUE, sold_at = now(), sold_to_resident_id

Create seed function create_default_exchange_zones(p_community_id):
- Creates "Lobby Principal", "Caseta de Vigilancia" default zones

Add RLS policies:
- super_admin_all_exchange_zones
- users_view_exchange_zones
- admins_manage_exchange_zones
- super_admin_all_appointments
- participants_view_appointments: WHERE seller_id = auth.uid() OR buyer_id = auth.uid()
- participants_manage_appointments

Add indexes:
- exchange_zones: community_id + status (for active zones)
- exchange_appointments: listing_id (for listing appointments)
- exchange_appointments: scheduled_at (for calendar queries)
- exchange_appointments: status partial WHERE status = 'pending'
  </action>
  <verify>
Run migration. Create exchange zone. Create appointment for listing. Confirm from seller - verify seller_confirmed=TRUE. Confirm from buyer - verify status='completed' and listing marked sold.
  </verify>
  <done>
exchange_zones with location/hours, exchange_appointments with dual confirmation, confirm_exchange_completion() marks listing as sold when both confirm.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create moderation queue with SKIP LOCKED</name>
  <files>
    supabase/migrations/TIMESTAMP_moderation_queue.sql
  </files>
  <action>
Create moderation_queue table:
- id UUID PK (generate_uuid_v7)
- community_id UUID FK to communities(id) ON DELETE RESTRICT
- item_type TEXT NOT NULL CHECK (item_type IN ('listing', 'post', 'comment'))
- item_id UUID NOT NULL
- priority INTEGER NOT NULL DEFAULT 0 (higher = review first)
- queued_at TIMESTAMPTZ NOT NULL DEFAULT now()
- assigned_to UUID FK to auth.users(id)
- assigned_at TIMESTAMPTZ
- resolved_at TIMESTAMPTZ
- resolution TEXT CHECK (resolution IN ('approved', 'rejected'))
- resolution_notes TEXT
- UNIQUE (item_type, item_id)

Create index for efficient queue claiming:
- idx_moderation_queue_pending ON moderation_queue(community_id, priority DESC, queued_at ASC) WHERE assigned_to IS NULL AND resolved_at IS NULL

Create claim_moderation_item() function:
- Parameters: p_community_id
- RETURNS TABLE (queue_id UUID, item_type TEXT, item_id UUID)
- LANGUAGE plpgsql, SECURITY DEFINER
- Uses FOR UPDATE SKIP LOCKED to prevent concurrent claims:
  ```sql
  SELECT * INTO claimed
  FROM moderation_queue
  WHERE community_id = p_community_id
    AND assigned_to IS NULL
    AND resolved_at IS NULL
  ORDER BY priority DESC, queued_at ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED;
  ```
- Updates assigned_to = auth.uid(), assigned_at = now()
- Returns claimed item info

Create resolve_moderation() function:
- Parameters: p_queue_id, p_resolution ('approved' or 'rejected'), p_notes
- RETURNS BOOLEAN
- Validates assigned_to = auth.uid()
- Updates moderation_queue: resolved_at, resolution, resolution_notes
- Updates source item based on item_type:
  - listing: marketplace_listings.moderation_status, moderated_by, moderated_at, rejection_reason
  - post: posts.is_hidden = (resolution = 'rejected')
  - comment: post_comments.is_hidden = (resolution = 'rejected')
- Returns TRUE on success

Create release_stale_claims() function (for cleanup job):
- Finds items WHERE assigned_at < now() - interval '30 minutes' AND resolved_at IS NULL
- Sets assigned_to = NULL, assigned_at = NULL
- Returns count of released items

Add RLS policies:
- super_admin_all_moderation
- moderators_view_queue: WHERE community role is admin or manager
- moderators_claim_items: UPDATE via claim_moderation_item()
- moderators_resolve_items: UPDATE via resolve_moderation()

Add indexes (beyond the partial index above):
- assigned_to + resolved_at partial WHERE resolved_at IS NULL (for moderator's claimed items)
- resolved_at for audit/reporting

Add comments explaining FOR UPDATE SKIP LOCKED pattern and why it prevents moderator conflicts.
  </action>
  <verify>
Run migration. Insert listing (triggers queue entry). Call claim_moderation_item() from two sessions simultaneously - each should get different item. Call resolve_moderation() with 'approved' - verify listing status updated to 'approved'. Test release_stale_claims() releases old claims.
  </verify>
  <done>
moderation_queue with polymorphic references, claim_moderation_item() uses SKIP LOCKED for concurrent moderators, resolve_moderation() updates source items, stale claim cleanup available.
  </done>
</task>

</tasks>

<verification>
1. Query: SELECT * FROM pg_type WHERE typname IN ('listing_category', 'moderation_status')
2. Query: SELECT table_name FROM information_schema.tables WHERE table_name IN ('marketplace_listings', 'exchange_zones', 'exchange_appointments', 'moderation_queue')
3. Test: Insert listing - verify appears in moderation_queue
4. Test: Claim item with concurrent sessions - SKIP LOCKED prevents duplicate claims
5. Test: Resolve as approved - listing visible to all users
6. Test: Create exchange appointment, both parties confirm - listing marked sold
7. Test: release_stale_claims() clears abandoned items
</verification>

<success_criteria>
- listing_category and moderation_status enums created
- marketplace_listings with auto-queue trigger, expiry, sold tracking
- exchange_zones with location, hours, safety features
- exchange_appointments with dual confirmation flow
- moderation_queue with polymorphic item references
- claim_moderation_item() uses FOR UPDATE SKIP LOCKED for concurrency
- resolve_moderation() updates source item status
- RLS restricts pending listings visibility
- All tables have community isolation
</success_criteria>

<output>
After completion, create `.planning/phases/05-amenities-communication-marketplace/05-05-SUMMARY.md`
</output>
