---
phase: 07-operations-compliance
plan: 04
type: execute
wave: 2
depends_on: [07-01, 07-02, 07-03]
files_modified:
  - supabase/migrations/TIMESTAMP_audit_schema.sql
  - supabase/migrations/TIMESTAMP_audit_log_table.sql
  - supabase/migrations/TIMESTAMP_sessions_security_events.sql
autonomous: true

must_haves:
  truths:
    - "Audit log captures entity, action, actor, before/after for all operations"
    - "Audit log is append-only and immutable"
    - "User sessions track device, IP, and location"
    - "Security events log authentication and access failures"
  artifacts:
    - path: "supabase/migrations/*_audit_schema.sql"
      provides: "audit schema, audit.operation enum"
    - path: "supabase/migrations/*_audit_log_table.sql"
      provides: "audit.audit_log table with immutability trigger and enable_tracking function"
    - path: "supabase/migrations/*_sessions_security_events.sql"
      provides: "user_sessions and security_events tables"
  key_links:
    - from: "audit.log_changes trigger function"
      to: "audit.audit_log table"
      via: "trigger on enabled tables"
    - from: "audit.enable_tracking function"
      to: "target tables"
      via: "creates audit trigger dynamically"
    - from: "security_events.session_id"
      to: "user_sessions.id"
      via: "foreign key"
---

<objective>
Create comprehensive audit logging infrastructure using the supa_audit pattern with trigger-based before/after capture, user session tracking with device fingerprint, and security event logging for authentication and access failures.

Purpose: Enable compliance-ready audit trails for sensitive operations, security monitoring for suspicious activity, and session management for multi-device users.

Output: Immutable audit log with dynamic trigger enablement, session tracking, and security event logging.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-operations-compliance/07-RESEARCH.md

# Prior immutability patterns
@.planning/phases/03-access-control-security/03-04-SUMMARY.md (immutable access_logs pattern)
@.planning/phases/04-financial-engine/04-01-SUMMARY.md (immutable ledger_entries pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit schema and operation enum</name>
  <files>supabase/migrations/TIMESTAMP_audit_schema.sql</files>
  <action>
Create migration for audit schema:

```sql
-- Create audit schema to separate audit infrastructure from public tables
CREATE SCHEMA IF NOT EXISTS audit;

-- Operation types for audit entries
CREATE TYPE audit.operation AS ENUM (
  'INSERT',
  'UPDATE',
  'DELETE',
  'TRUNCATE'
);
```

Grant appropriate permissions:
- authenticated role can SELECT from audit schema
- service_role can INSERT (for triggers running as SECURITY DEFINER)

Include standard header comment.
  </action>
  <verify>Run migration, verify schema exists with `\dn audit` and enum with `\dT+ audit.operation`</verify>
  <done>Audit schema and operation enum created</done>
</task>

<task type="auto">
  <name>Task 2: Create audit_log table with immutability and tracking functions</name>
  <files>supabase/migrations/TIMESTAMP_audit_log_table.sql</files>
  <action>
Create migration for audit_log table and helper functions:

**audit.audit_log table:**
- id UUID PK DEFAULT generate_uuid_v7()
- What changed:
  - table_schema TEXT NOT NULL
  - table_name TEXT NOT NULL
  - table_oid OID NOT NULL
- Record identification:
  - record_id UUID (primary key if UUID)
  - record_pk JSONB (for composite keys)
- operation audit.operation NOT NULL
- Data (JSONB for flexibility):
  - old_record JSONB (NULL for INSERT)
  - new_record JSONB (NULL for DELETE)
  - changed_fields TEXT[] (list of changed column names for UPDATE)
- Actor information:
  - actor_id UUID (auth.uid() if available)
  - actor_role TEXT (database role)
  - actor_ip INET
  - actor_user_agent TEXT
- Context:
  - community_id UUID (extracted from record if present)
- Timestamp:
  - logged_at TIMESTAMPTZ NOT NULL DEFAULT now()
- Transaction info:
  - transaction_id BIGINT DEFAULT txid_current()

**Indexes:**
- BRIN index on logged_at for time-series queries: idx_audit_log_timestamp_brin USING BRIN (logged_at) WITH (pages_per_range = 32)
- B-tree indexes:
  - idx_audit_log_table ON (table_name, logged_at DESC)
  - idx_audit_log_record ON (record_id, logged_at DESC) WHERE record_id IS NOT NULL
  - idx_audit_log_actor ON (actor_id, logged_at DESC) WHERE actor_id IS NOT NULL
  - idx_audit_log_community ON (community_id, logged_at DESC) WHERE community_id IS NOT NULL

**audit.prevent_audit_modification() trigger function:**
- BEFORE UPDATE OR DELETE on audit.audit_log
- RAISE EXCEPTION 'audit.audit_log is append-only: % operations are not allowed', TG_OP

Create both UPDATE and DELETE triggers using this function.

**audit.log_changes() trigger function:**
- SECURITY DEFINER, SET search_path = ''
- Extracts actor_id from auth.uid() (with exception handling)
- Tries to get IP and user_agent from request headers (with exception handling)
- For INSERT: captures new_record as JSONB
- For UPDATE: captures old_record, new_record, computes changed_fields array
- For DELETE: captures old_record
- Extracts record_id if record has 'id' field
- Extracts community_id if record has 'community_id' field
- Inserts into audit.audit_log

**audit.enable_tracking(target_table REGCLASS) function:**
- Creates trigger named 'audit_{table_name}' on target table
- AFTER INSERT OR UPDATE OR DELETE FOR EACH ROW
- Executes audit.log_changes()

**audit.disable_tracking(target_table REGCLASS) function:**
- Drops trigger 'audit_{table_name}' on target table

**Enable auditing on critical tables created in this phase:**
```sql
SELECT audit.enable_tracking('public.packages'::regclass);
SELECT audit.enable_tracking('public.providers'::regclass);
SELECT audit.enable_tracking('public.provider_documents'::regclass);
SELECT audit.enable_tracking('public.move_requests'::regclass);
SELECT audit.enable_tracking('public.move_deposits'::regclass);
```

No RLS on audit.audit_log - only service_role should write, admins can read via functions.
  </action>
  <verify>
1. INSERT into packages table
2. SELECT * FROM audit.audit_log WHERE table_name = 'packages' - should have INSERT record with new_record JSONB
3. UPDATE packages SET status = 'stored'
4. Check audit_log for UPDATE record with old_record, new_record, changed_fields
5. Attempt UPDATE on audit.audit_log - should raise exception
  </verify>
  <done>Immutable audit_log with trigger-based capture and dynamic enable_tracking function</done>
</task>

<task type="auto">
  <name>Task 3: Create user sessions and security events tables</name>
  <files>supabase/migrations/TIMESTAMP_sessions_security_events.sql</files>
  <action>
Create migration for session and security tracking:

**user_sessions table:**
- id UUID PK DEFAULT generate_uuid_v7()
- user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- auth_session_id TEXT (Supabase auth session ID)
- Device fingerprint:
  - device_fingerprint TEXT (computed hash)
  - device_id TEXT (app-generated)
- Device details:
  - device_type TEXT CHECK IN ('mobile', 'tablet', 'desktop', 'unknown')
  - device_model TEXT
  - browser TEXT
  - browser_version TEXT
  - os TEXT
  - os_version TEXT
  - screen_resolution TEXT
- Network:
  - ip_address INET NOT NULL
- Location (optional):
  - country TEXT
  - region TEXT
  - city TEXT
  - latitude NUMERIC(10,7)
  - longitude NUMERIC(10,7)
- Session lifecycle:
  - created_at TIMESTAMPTZ NOT NULL DEFAULT now()
  - last_active_at TIMESTAMPTZ NOT NULL DEFAULT now()
  - expires_at TIMESTAMPTZ
  - terminated_at TIMESTAMPTZ
  - termination_reason TEXT ('logout', 'expired', 'admin_revoke', 'security')
- Security flags:
  - is_suspicious BOOLEAN NOT NULL DEFAULT false
  - suspicious_reason TEXT
- App version:
  - app_version TEXT

**Indexes:**
- idx_user_sessions_active ON (user_id, last_active_at DESC) WHERE terminated_at IS NULL
- idx_user_sessions_ip ON (ip_address, created_at DESC)
- idx_user_sessions_fingerprint ON (device_fingerprint) WHERE device_fingerprint IS NOT NULL

**security_event_type enum:**
```sql
CREATE TYPE security_event_type AS ENUM (
  'login_success',
  'login_failed',
  'logout',
  'password_changed',
  'mfa_enabled',
  'mfa_disabled',
  'session_terminated',
  'access_blocked',
  'blacklist_hit',
  'suspicious_activity',
  'permission_denied',
  'data_export'
);
```

**security_events table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID REFERENCES communities(id)
- event_type security_event_type NOT NULL
- Actor:
  - user_id UUID REFERENCES auth.users(id)
  - session_id UUID REFERENCES user_sessions(id)
- Details:
  - description TEXT NOT NULL
  - metadata JSONB DEFAULT '{}'
- Context:
  - ip_address INET
  - user_agent TEXT
- Related entity:
  - entity_type TEXT
  - entity_id UUID
- severity TEXT NOT NULL DEFAULT 'info' CHECK IN ('info', 'warning', 'critical')
- logged_at TIMESTAMPTZ NOT NULL DEFAULT now()

**Indexes:**
- BRIN index: idx_security_events_timestamp_brin USING BRIN (logged_at)
- B-tree indexes:
  - idx_security_events_user ON (user_id, logged_at DESC) WHERE user_id IS NOT NULL
  - idx_security_events_type ON (event_type, logged_at DESC)
  - idx_security_events_severity ON (severity, logged_at DESC) WHERE severity IN ('warning', 'critical')

**Helper functions:**

**create_user_session(p_user_id, p_ip_address, p_device_info JSONB) function:**
- Creates new session record
- Extracts device details from JSONB
- Returns session_id

**update_session_activity(p_session_id) function:**
- Updates last_active_at to now()

**terminate_session(p_session_id, p_reason) function:**
- Sets terminated_at and termination_reason
- Logs security_event with type 'session_terminated'

**log_security_event(p_event_type, p_description, p_user_id, p_session_id, p_metadata, p_severity) function:**
- Inserts into security_events
- Returns event_id

**should_block_login(p_email, p_ip_address, p_max_attempts DEFAULT 5, p_window_minutes DEFAULT 15) function:**
- Counts failed login attempts by email in window
- Counts failed login attempts by IP in window (with 2x threshold)
- Returns BOOLEAN if either exceeds limit

RLS:
- user_sessions: Users can SELECT own sessions, admins can SELECT all
- security_events: Admins only (sensitive security data)
  </action>
  <verify>
1. SELECT create_user_session(auth.uid(), '192.168.1.1', '{"device_type": "mobile", "os": "iOS"}'::JSONB)
2. SELECT * FROM user_sessions WHERE user_id = auth.uid() - should have session
3. SELECT log_security_event('login_success', 'User logged in', auth.uid(), session_id, '{}', 'info')
4. SELECT * FROM security_events WHERE user_id = auth.uid()
5. SELECT terminate_session(session_id, 'logout')
6. Check session has terminated_at set
  </verify>
  <done>Session tracking with device fingerprint and security event logging with rate limiting</done>
</task>

</tasks>

<verification>
-- Test audit trail
UPDATE packages SET description = 'Updated description' WHERE id = '...';
SELECT table_name, operation, changed_fields, old_record->>'description', new_record->>'description'
FROM audit.audit_log
WHERE table_name = 'packages' AND operation = 'UPDATE'
ORDER BY logged_at DESC LIMIT 1;
-- Should show changed_fields = ['description'] and before/after values

-- Test immutability
UPDATE audit.audit_log SET actor_id = NULL WHERE id = '...';
-- Should raise: "audit.audit_log is append-only: UPDATE operations are not allowed"

-- Test session lifecycle
SELECT create_user_session(auth.uid(), '10.0.0.1'::INET, '{"device_type": "desktop", "browser": "Chrome"}'::JSONB);
SELECT terminate_session(session_id, 'logout');
SELECT * FROM security_events WHERE event_type = 'session_terminated';
</verification>

<success_criteria>
- audit schema created with operation enum
- audit.audit_log captures INSERT/UPDATE/DELETE with before/after JSONB
- audit.audit_log is immutable (trigger prevents UPDATE/DELETE)
- audit.enable_tracking() dynamically adds audit triggers to tables
- Critical Phase 7 tables have audit enabled (packages, providers, etc.)
- user_sessions tracks device fingerprint, IP, location
- security_events logs authentication and access events
- should_block_login() provides rate limiting logic
- All tables have appropriate RLS policies
</success_criteria>

<output>
After completion, create `.planning/phases/07-operations-compliance/07-04-SUMMARY.md`
</output>
