---
phase: 01-foundation-multi-tenant-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00001_uuid_v7_function.sql
  - supabase/migrations/00002_audit_infrastructure.sql
autonomous: true

must_haves:
  truths:
    - "UUID v7 function generates time-ordered UUIDs"
    - "Audit trigger auto-populates created_at, updated_at timestamps"
    - "Soft delete function sets deleted_at instead of hard delete"
    - "Helper function extracts community_id from JWT app_metadata"
  artifacts:
    - path: "database function: generate_uuid_v7()"
      provides: "Time-ordered UUID generation for all PKs"
    - path: "database function: set_audit_fields()"
      provides: "Trigger function for created_at/updated_at"
    - path: "database function: get_current_community_id()"
      provides: "RLS helper extracting community_id from JWT"
  key_links:
    - from: "generate_uuid_v7()"
      to: "All tables with UUID PKs"
      via: "DEFAULT clause in column definition"
    - from: "set_audit_fields()"
      to: "All tables with audit columns"
      via: "BEFORE INSERT OR UPDATE trigger"
    - from: "get_current_community_id()"
      to: "All RLS policies"
      via: "USING clause in policy"
---

<objective>
Create the foundational database functions required by all subsequent tables: UUID v7 generation, audit column triggers, and RLS helper functions.

Purpose: These utilities must exist BEFORE creating any tables because tables will reference them in DEFAULT clauses, triggers, and RLS policies. Getting these right prevents cascading changes later.

Output: Two Supabase migrations establishing core database infrastructure.
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md

Key patterns from research:
- UUID v7 is time-ordered, better for B-tree indexes than UUID v4
- Wrap auth.jwt() in SELECT for 99%+ RLS performance improvement
- Use app_metadata (NOT user_metadata) for community_id - users cannot modify app_metadata
- Soft deletes required for offline sync (clients need to know records were deleted)
- SECURITY DEFINER functions with empty search_path for security
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UUID v7 generation function</name>
  <files>supabase/migrations/00001_uuid_v7_function.sql</files>
  <action>
Apply a Supabase migration using mcp__supabase__apply_migration with name "uuid_v7_function" containing:

```sql
-- UUID v7 Generation Function
-- UUID v7 is time-ordered (first 48 bits are millisecond timestamp)
-- Better for B-tree indexes than random UUID v4

CREATE OR REPLACE FUNCTION generate_uuid_v7()
RETURNS UUID
LANGUAGE plpgsql
VOLATILE
PARALLEL SAFE
AS $$
DECLARE
  v_time BIGINT;
  v_random BYTEA;
  v_uuid_bytes BYTEA;
BEGIN
  -- Get current timestamp in milliseconds since Unix epoch
  v_time := (EXTRACT(EPOCH FROM clock_timestamp()) * 1000)::BIGINT;

  -- Get 10 random bytes for the remaining portion
  v_random := gen_random_bytes(10);

  -- Build UUID v7 structure:
  -- Bytes 0-5: 48-bit timestamp (big-endian)
  -- Byte 6: version (7) in high nibble + 4 random bits
  -- Byte 7: random
  -- Byte 8: variant (10xx) in high 2 bits + 6 random bits
  -- Bytes 9-15: random

  v_uuid_bytes :=
    -- Timestamp bytes (48 bits = 6 bytes)
    set_byte(set_byte(set_byte(set_byte(set_byte(set_byte(
      E'\\x000000000000'::BYTEA,
      0, ((v_time >> 40) & 255)::INT),
      1, ((v_time >> 32) & 255)::INT),
      2, ((v_time >> 24) & 255)::INT),
      3, ((v_time >> 16) & 255)::INT),
      4, ((v_time >> 8) & 255)::INT),
      5, (v_time & 255)::INT)
    ||
    -- Version 7 (0111) in high nibble + 4 random bits
    set_byte(E'\\x00'::BYTEA, 0, (112 | (get_byte(v_random, 0) & 15))::INT)
    ||
    -- Next random byte
    get_bytea_to_byte(v_random, 1)
    ||
    -- Variant (10xx xxxx) + 6 random bits
    set_byte(E'\\x00'::BYTEA, 0, (128 | (get_byte(v_random, 2) & 63))::INT)
    ||
    -- Remaining 7 random bytes
    substring(v_random FROM 4 FOR 7);

  RETURN encode(v_uuid_bytes, 'hex')::UUID;
END;
$$;

-- Helper function to extract single byte from bytea
CREATE OR REPLACE FUNCTION get_bytea_to_byte(b BYTEA, pos INT)
RETURNS BYTEA
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
AS $$
  SELECT set_byte(E'\\x00'::BYTEA, 0, get_byte(b, pos));
$$;

-- Add comment for documentation
COMMENT ON FUNCTION generate_uuid_v7() IS
  'Generates a UUID v7 (time-ordered) for use as primary keys.
   First 48 bits are millisecond timestamp for better B-tree index locality.
   Used as DEFAULT for all id columns in UPOE.';
```

IMPORTANT: Do NOT use gen_random_uuid() for primary keys - it creates random UUIDs (v4) with poor index locality. Always use generate_uuid_v7().
  </action>
  <verify>
Execute SQL via mcp__supabase__execute_sql to test UUID v7 generation:

```sql
-- Test 1: Function exists and returns UUID
SELECT generate_uuid_v7();

-- Test 2: Multiple UUIDs are time-ordered (lexicographically sortable)
SELECT
  a.id AS first_uuid,
  b.id AS second_uuid,
  a.id < b.id AS is_ordered
FROM
  (SELECT generate_uuid_v7() AS id) a,
  (SELECT pg_sleep(0.001), generate_uuid_v7() AS id) b;

-- Test 3: UUID format is valid (36 chars with hyphens)
SELECT
  generate_uuid_v7()::TEXT,
  LENGTH(generate_uuid_v7()::TEXT) = 36 AS valid_length;
```

All three tests should return valid results with is_ordered = true.
  </verify>
  <done>
UUID v7 function exists in database and generates time-ordered UUIDs that can be used as DEFAULT for primary key columns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit infrastructure and RLS helpers</name>
  <files>supabase/migrations/00002_audit_infrastructure.sql</files>
  <action>
Apply a Supabase migration using mcp__supabase__apply_migration with name "audit_infrastructure" containing:

```sql
-- ============================================
-- AUDIT COLUMN TRIGGER FUNCTION
-- ============================================
-- Automatically sets created_at on INSERT
-- Automatically sets updated_at on INSERT and UPDATE

CREATE OR REPLACE FUNCTION set_audit_fields()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- On INSERT: set both created_at and updated_at
  IF TG_OP = 'INSERT' THEN
    NEW.created_at := COALESCE(NEW.created_at, now());
    NEW.updated_at := now();
    -- created_by should be set by application, but default to auth.uid() if available
    IF NEW.created_by IS NULL THEN
      NEW.created_by := auth.uid();
    END IF;
  END IF;

  -- On UPDATE: only update updated_at (never change created_at/created_by)
  IF TG_OP = 'UPDATE' THEN
    NEW.updated_at := now();
    -- Preserve original created_at and created_by
    NEW.created_at := OLD.created_at;
    NEW.created_by := OLD.created_by;
  END IF;

  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION set_audit_fields() IS
  'Trigger function to auto-populate audit columns.
   Attach to tables with: CREATE TRIGGER set_audit BEFORE INSERT OR UPDATE ON tablename FOR EACH ROW EXECUTE FUNCTION set_audit_fields();';

-- ============================================
-- SOFT DELETE FUNCTION
-- ============================================
-- Sets deleted_at instead of actually deleting
-- Required for offline sync (clients need deletion records)

CREATE OR REPLACE FUNCTION soft_delete()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Instead of deleting, set deleted_at timestamp
  UPDATE ONLY (TG_RELID::regclass::text)::regclass
  SET deleted_at = now()
  WHERE ctid = OLD.ctid;

  -- Return NULL to prevent the actual DELETE
  RETURN NULL;
END;
$$;

-- Alternative: Generic soft delete function that works with dynamic table names
CREATE OR REPLACE FUNCTION perform_soft_delete(table_name TEXT, record_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  EXECUTE format(
    'UPDATE %I SET deleted_at = now() WHERE id = $1 AND deleted_at IS NULL',
    table_name
  ) USING record_id;

  RETURN FOUND;
END;
$$;

COMMENT ON FUNCTION perform_soft_delete(TEXT, UUID) IS
  'Soft deletes a record by setting deleted_at. Returns true if record was found and updated.
   Usage: SELECT perform_soft_delete(''residents'', ''uuid-here'');';

-- ============================================
-- RLS HELPER: GET CURRENT COMMUNITY ID
-- ============================================
-- Extracts community_id from JWT app_metadata
-- CRITICAL: Uses SELECT wrapper for 99%+ performance improvement

CREATE OR REPLACE FUNCTION get_current_community_id()
RETURNS UUID
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  -- Extract community_id from app_metadata (NOT user_metadata!)
  -- user_metadata is user-editable, app_metadata is server-controlled only
  SELECT (
    (SELECT auth.jwt()) -> 'app_metadata' ->> 'community_id'
  )::UUID;
$$;

COMMENT ON FUNCTION get_current_community_id() IS
  'Returns the community_id from the current user''s JWT app_metadata.
   Used in RLS policies for tenant isolation.
   SECURITY: Uses app_metadata (server-controlled), NOT user_metadata (user-editable).';

-- ============================================
-- RLS HELPER: CHECK IF USER IS SUPER ADMIN
-- ============================================
-- Super admins can access all communities (platform level)

CREATE OR REPLACE FUNCTION is_super_admin()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT COALESCE(
    ((SELECT auth.jwt()) -> 'app_metadata' ->> 'is_super_admin')::BOOLEAN,
    FALSE
  );
$$;

COMMENT ON FUNCTION is_super_admin() IS
  'Returns true if the current user is a platform super admin.
   Super admins bypass community isolation for administrative tasks.';

-- ============================================
-- RLS HELPER: GET USER ROLE
-- ============================================
-- Returns the user's role within their community

CREATE OR REPLACE FUNCTION get_current_user_role()
RETURNS TEXT
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT (
    (SELECT auth.jwt()) -> 'app_metadata' ->> 'role'
  );
$$;

COMMENT ON FUNCTION get_current_user_role() IS
  'Returns the current user''s role (admin, guard, resident, etc.) from JWT.';
```

CRITICAL SECURITY NOTES:
- All functions use SECURITY DEFINER with empty search_path to prevent SQL injection
- community_id comes from app_metadata (server-controlled), NOT user_metadata (user-editable)
- The SELECT wrapper around auth.jwt() caches the result per query for massive performance gains
  </action>
  <verify>
Execute SQL via mcp__supabase__execute_sql to verify functions exist:

```sql
-- Test 1: All functions exist
SELECT
  routine_name,
  routine_type
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_name IN (
    'set_audit_fields',
    'soft_delete',
    'perform_soft_delete',
    'get_current_community_id',
    'is_super_admin',
    'get_current_user_role'
  )
ORDER BY routine_name;

-- Test 2: Functions have correct security settings
SELECT
  proname AS function_name,
  prosecdef AS is_security_definer
FROM pg_proc
WHERE proname IN ('set_audit_fields', 'get_current_community_id', 'is_super_admin')
  AND pronamespace = 'public'::regnamespace;
```

Should return 6 functions, all with SECURITY DEFINER = true.
  </verify>
  <done>
Audit trigger function, soft delete function, and RLS helper functions exist in database. All use SECURITY DEFINER with empty search_path for security.
  </done>
</task>

</tasks>

<verification>
Run comprehensive verification after both tasks:

```sql
-- Verify complete infrastructure
SELECT 'UUID v7 Function' AS component,
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'generate_uuid_v7') AS exists
UNION ALL
SELECT 'Audit Trigger Function',
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'set_audit_fields')
UNION ALL
SELECT 'Soft Delete Function',
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'perform_soft_delete')
UNION ALL
SELECT 'Community ID Helper',
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'get_current_community_id')
UNION ALL
SELECT 'Super Admin Helper',
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'is_super_admin')
UNION ALL
SELECT 'User Role Helper',
       EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'get_current_user_role');
```

All rows should show exists = true.
</verification>

<success_criteria>
- [ ] generate_uuid_v7() function creates time-ordered UUIDs
- [ ] set_audit_fields() trigger function exists with SECURITY DEFINER
- [ ] perform_soft_delete() function exists for soft deletion
- [ ] get_current_community_id() extracts from app_metadata (not user_metadata)
- [ ] is_super_admin() and get_current_user_role() helpers exist
- [ ] All functions have empty search_path for security
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md`
</output>
