---
phase: 01-foundation-multi-tenant-security
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - supabase/migrations/00004_organizations_table.sql
  - supabase/migrations/00005_communities_table.sql
  - supabase/migrations/00006_rls_policies.sql
autonomous: true

must_haves:
  truths:
    - "Organizations table exists with UUID v7 PKs and audit columns"
    - "Communities table exists with settings, timezone, locale, branding"
    - "RLS is ENABLED on both tables"
    - "RLS policies filter by community_id from JWT app_metadata"
    - "Super admins can access all organizations/communities"
    - "Soft delete works (deleted_at instead of hard delete)"
  artifacts:
    - path: "database table: organizations"
      provides: "Platform-level SaaS organization"
      contains: "id, name, slug, status, settings"
    - path: "database table: communities"
      provides: "Individual gated community within organization"
      contains: "id, organization_id, name, timezone, locale, branding, settings"
    - path: "RLS policies on organizations"
      provides: "Super admin and org member access control"
    - path: "RLS policies on communities"
      provides: "Community isolation via JWT app_metadata"
  key_links:
    - from: "communities.organization_id"
      to: "organizations.id"
      via: "FOREIGN KEY"
    - from: "RLS policy"
      to: "get_current_community_id()"
      via: "USING clause for tenant isolation"
    - from: "audit trigger"
      to: "set_audit_fields()"
      via: "BEFORE INSERT OR UPDATE trigger"
---

<objective>
Create the organizations and communities tables with proper RLS policies for multi-tenant isolation. These are the foundation tables that all other tables will reference.

Purpose: Organizations represent platform-level SaaS customers (property management companies). Communities are individual gated communities within an organization. ALL subsequent tables will have a community_id foreign key for RLS isolation.

Output: Three migrations - organizations table, communities table, and comprehensive RLS policies.
</objective>

<execution_context>
@C:\Users\PC\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\PC\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/01-foundation-multi-tenant-security/01-01-SUMMARY.md (after plan 01-01 completes)
@.planning/phases/01-foundation-multi-tenant-security/01-02-SUMMARY.md (after plan 01-02 completes)

Key patterns from research:
- 83% of Supabase breaches involve RLS misconfiguration - enable RLS immediately
- Use (SELECT get_current_community_id()) pattern for cached RLS checks
- Index all community_id columns for RLS performance
- Wrap auth.jwt() in SELECT for 99%+ performance improvement
- JSONB for flexible settings that vary per community
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create organizations table</name>
  <files>supabase/migrations/00004_organizations_table.sql</files>
  <action>
Apply a Supabase migration using mcp__supabase__apply_migration with name "organizations_table" containing:

```sql
-- ============================================
-- ORGANIZATIONS TABLE
-- ============================================
-- Platform-level entity: SaaS customer (property management company)
-- One organization can manage multiple communities

CREATE TABLE organizations (
  -- Primary key using UUID v7 for time-ordering
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),

  -- Core fields
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  description TEXT,

  -- Status
  status general_status NOT NULL DEFAULT 'active',

  -- Contact info
  email TEXT,
  phone phone_number,
  website TEXT,

  -- Address (for billing)
  address JSONB DEFAULT '{}'::JSONB,
  -- Structure: { street, city, state, postal_code, country }

  -- Billing info
  billing_email TEXT,
  tax_id TEXT,  -- RFC in Mexico

  -- Settings (flexible JSONB for org-level config)
  settings JSONB DEFAULT '{}'::JSONB,
  -- Typical: { max_communities, subscription_tier, features_enabled }

  -- Branding
  logo_url TEXT,
  primary_color TEXT,

  -- Audit columns
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,  -- Soft delete
  created_by UUID REFERENCES auth.users(id)
);

-- Index for soft delete queries (exclude deleted)
CREATE INDEX idx_organizations_active
  ON organizations(id)
  WHERE deleted_at IS NULL;

-- Index for slug lookups
CREATE INDEX idx_organizations_slug
  ON organizations(slug)
  WHERE deleted_at IS NULL;

-- Index for status filtering
CREATE INDEX idx_organizations_status
  ON organizations(status)
  WHERE deleted_at IS NULL;

-- Audit trigger
CREATE TRIGGER set_organizations_audit
  BEFORE INSERT OR UPDATE ON organizations
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Enable RLS immediately (CRITICAL - never skip this!)
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;

-- Comments
COMMENT ON TABLE organizations IS
  'Platform-level SaaS customers. Property management companies that operate multiple gated communities.';
COMMENT ON COLUMN organizations.slug IS
  'URL-friendly unique identifier. Used in subdomains or paths.';
COMMENT ON COLUMN organizations.settings IS
  'Flexible JSONB for org-level configuration (subscription tier, feature flags, limits).';
COMMENT ON COLUMN organizations.deleted_at IS
  'Soft delete timestamp. When set, record is considered deleted but preserved for audit.';
```
  </action>
  <verify>
Execute SQL via mcp__supabase__execute_sql:

```sql
-- Verify table exists with correct columns
SELECT
  column_name,
  data_type,
  is_nullable,
  column_default
FROM information_schema.columns
WHERE table_name = 'organizations'
  AND table_schema = 'public'
ORDER BY ordinal_position;

-- Verify RLS is enabled
SELECT
  tablename,
  rowsecurity
FROM pg_tables
WHERE tablename = 'organizations'
  AND schemaname = 'public';

-- Verify trigger exists
SELECT
  trigger_name,
  event_manipulation,
  action_timing
FROM information_schema.triggers
WHERE event_object_table = 'organizations';
```

Should show:
- All columns with correct types
- rowsecurity = true
- set_organizations_audit trigger on INSERT and UPDATE
  </verify>
  <done>
Organizations table exists with UUID v7 PKs, audit columns, soft delete support, and RLS enabled (policies added in Task 3).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create communities table</name>
  <files>supabase/migrations/00005_communities_table.sql</files>
  <action>
Apply a Supabase migration using mcp__supabase__apply_migration with name "communities_table" containing:

```sql
-- ============================================
-- COMMUNITIES TABLE
-- ============================================
-- Individual gated community within an organization
-- This is the primary tenant isolation boundary

CREATE TABLE communities (
  -- Primary key using UUID v7 for time-ordering
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),

  -- Organization relationship
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE RESTRICT,

  -- Core fields
  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,

  -- Status
  status general_status NOT NULL DEFAULT 'active',

  -- Location
  timezone timezone_name NOT NULL DEFAULT 'America/Mexico_City',
  locale locale_code NOT NULL DEFAULT 'es-MX',
  address JSONB DEFAULT '{}'::JSONB,
  -- Structure: { street, neighborhood, city, state, postal_code, country, coordinates: {lat, lng} }

  -- Contact info
  email TEXT,
  phone phone_number,
  emergency_phone phone_number,

  -- Branding (overrides org-level)
  logo_url TEXT,
  cover_image_url TEXT,
  primary_color TEXT,
  secondary_color TEXT,

  -- Settings (community-specific configuration)
  settings JSONB DEFAULT '{}'::JSONB,
  -- Typical settings:
  -- {
  --   operating_hours: { weekday: { open: "06:00", close: "22:00" }, weekend: {...} },
  --   access_rules: { require_photo: true, require_id: true },
  --   notifications: { channels: ["push", "email", "sms"] },
  --   features: { amenities: true, marketplace: true, chat: true },
  --   payment: { currency: "MXN", allow_partial: false },
  --   security: { panic_button: true, patrol_required: true }
  -- }

  -- Community metrics (denormalized for quick access)
  unit_count INTEGER DEFAULT 0,
  resident_count INTEGER DEFAULT 0,

  -- Financial settings
  currency currency_code NOT NULL DEFAULT 'MXN',

  -- Audit columns
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,  -- Soft delete
  created_by UUID REFERENCES auth.users(id),

  -- Unique slug within organization
  CONSTRAINT communities_org_slug_unique UNIQUE (organization_id, slug)
);

-- CRITICAL: Index for RLS performance
-- This index is essential for fast RLS policy evaluation
CREATE INDEX idx_communities_id
  ON communities(id)
  WHERE deleted_at IS NULL;

-- Index for organization lookups
CREATE INDEX idx_communities_organization_id
  ON communities(organization_id)
  WHERE deleted_at IS NULL;

-- Index for status filtering
CREATE INDEX idx_communities_status
  ON communities(status)
  WHERE deleted_at IS NULL;

-- Composite index for org + status queries
CREATE INDEX idx_communities_org_status
  ON communities(organization_id, status)
  WHERE deleted_at IS NULL;

-- Audit trigger
CREATE TRIGGER set_communities_audit
  BEFORE INSERT OR UPDATE ON communities
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Enable RLS immediately (CRITICAL!)
ALTER TABLE communities ENABLE ROW LEVEL SECURITY;

-- Comments
COMMENT ON TABLE communities IS
  'Individual gated communities. Primary tenant isolation boundary - all other tables reference community_id.';
COMMENT ON COLUMN communities.slug IS
  'URL-friendly identifier, unique within organization. Used in URLs.';
COMMENT ON COLUMN communities.settings IS
  'JSONB configuration for community-specific features, rules, and preferences.';
COMMENT ON COLUMN communities.timezone IS
  'IANA timezone (e.g., America/Mexico_City). All community times displayed in this zone.';
COMMENT ON COLUMN communities.locale IS
  'BCP 47 locale for language and formatting (e.g., es-MX).';
COMMENT ON COLUMN communities.unit_count IS
  'Denormalized count of units. Updated by triggers when units change.';
```
  </action>
  <verify>
Execute SQL via mcp__supabase__execute_sql:

```sql
-- Verify table structure
SELECT
  column_name,
  data_type,
  is_nullable
FROM information_schema.columns
WHERE table_name = 'communities'
  AND table_schema = 'public'
ORDER BY ordinal_position;

-- Verify foreign key to organizations
SELECT
  tc.constraint_name,
  tc.table_name,
  kcu.column_name,
  ccu.table_name AS foreign_table_name,
  ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_name = 'communities'
  AND tc.constraint_type = 'FOREIGN KEY';

-- Verify RLS is enabled
SELECT tablename, rowsecurity
FROM pg_tables
WHERE tablename = 'communities';

-- Verify indexes exist
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'communities';
```

Should show communities with organization_id FK and RLS enabled.
  </verify>
  <done>
Communities table exists with organization_id FK, timezone, locale, branding, settings, audit columns, and RLS enabled.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RLS policies for both tables</name>
  <files>supabase/migrations/00006_rls_policies.sql</files>
  <action>
Apply a Supabase migration using mcp__supabase__apply_migration with name "foundation_rls_policies" containing:

```sql
-- ============================================
-- RLS POLICIES FOR ORGANIZATIONS
-- ============================================
-- Organizations are accessible to:
-- 1. Super admins (all orgs)
-- 2. Users whose community belongs to the org

-- Super admins can do everything
CREATE POLICY "super_admin_all_access_organizations"
  ON organizations
  FOR ALL
  TO authenticated
  USING (
    (SELECT is_super_admin())
  )
  WITH CHECK (
    (SELECT is_super_admin())
  );

-- Users can view their own organization
-- (organization_id is derived from their community's parent org)
CREATE POLICY "users_view_own_organization"
  ON organizations
  FOR SELECT
  TO authenticated
  USING (
    id IN (
      SELECT c.organization_id
      FROM communities c
      WHERE c.id = (SELECT get_current_community_id())
        AND c.deleted_at IS NULL
    )
  );

-- Exclude deleted organizations from all queries
CREATE POLICY "exclude_deleted_organizations"
  ON organizations
  FOR SELECT
  TO authenticated
  USING (
    deleted_at IS NULL
  );

-- ============================================
-- RLS POLICIES FOR COMMUNITIES
-- ============================================
-- Communities are accessible to:
-- 1. Super admins (all communities)
-- 2. Users assigned to that specific community (via JWT app_metadata)

-- Super admins can do everything
CREATE POLICY "super_admin_all_access_communities"
  ON communities
  FOR ALL
  TO authenticated
  USING (
    (SELECT is_super_admin())
  )
  WITH CHECK (
    (SELECT is_super_admin())
  );

-- CRITICAL POLICY: Users can only see their own community
-- This is the primary tenant isolation policy
CREATE POLICY "users_view_own_community"
  ON communities
  FOR SELECT
  TO authenticated
  USING (
    -- Use SELECT wrapper for performance (caches JWT extraction)
    id = (SELECT get_current_community_id())
    AND deleted_at IS NULL
  );

-- Community admins can update their community settings
CREATE POLICY "admins_update_own_community"
  ON communities
  FOR UPDATE
  TO authenticated
  USING (
    id = (SELECT get_current_community_id())
    AND deleted_at IS NULL
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    id = (SELECT get_current_community_id())
    AND deleted_at IS NULL
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- ============================================
-- SERVICE ROLE BYPASS NOTE
-- ============================================
-- The service_role key bypasses ALL RLS policies.
-- This is intentional for Edge Functions and admin operations.
-- NEVER expose service_role key to client code!

-- ============================================
-- HELPER FUNCTION FOR COMMUNITY MEMBERSHIP CHECK
-- ============================================
-- Optimized function for checking if user belongs to a community
-- Used in RLS policies across all tables

CREATE OR REPLACE FUNCTION user_has_community_access(target_community_id UUID)
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
  SELECT
    (SELECT is_super_admin())
    OR
    target_community_id = (SELECT get_current_community_id())
$$;

COMMENT ON FUNCTION user_has_community_access(UUID) IS
  'Returns true if current user can access the specified community.
   Super admins can access all communities.
   Regular users can only access their assigned community.';

-- ============================================
-- VERIFY RLS IS WORKING
-- ============================================
-- Test query (should fail without valid JWT)
-- SELECT * FROM communities; -- Would return empty set

COMMENT ON POLICY "users_view_own_community" ON communities IS
  'Primary tenant isolation policy. Users can only see their assigned community from JWT app_metadata.community_id.';
```

CRITICAL SECURITY NOTES:
1. All policies use (SELECT func()) pattern for performance caching
2. Super admin check happens first (fast path)
3. deleted_at IS NULL excludes soft-deleted records
4. Community ID comes from app_metadata (server-controlled), NOT user_metadata
5. service_role bypasses RLS - never expose to clients
  </action>
  <verify>
Execute SQL via mcp__supabase__execute_sql:

```sql
-- Verify all policies exist
SELECT
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual IS NOT NULL AS has_using,
  with_check IS NOT NULL AS has_check
FROM pg_policies
WHERE schemaname = 'public'
  AND tablename IN ('organizations', 'communities')
ORDER BY tablename, policyname;

-- Verify helper function exists
SELECT
  routine_name,
  routine_type
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_name = 'user_has_community_access';

-- Count policies per table
SELECT
  tablename,
  COUNT(*) AS policy_count
FROM pg_policies
WHERE schemaname = 'public'
  AND tablename IN ('organizations', 'communities')
GROUP BY tablename;
```

Should show:
- organizations: 3 policies (super_admin, users_view, exclude_deleted)
- communities: 3 policies (super_admin, users_view, admins_update)
- user_has_community_access function exists
  </verify>
  <done>
RLS policies exist on both tables:
- Super admin full access
- Users can view their own community
- Admins can update their community settings
- Soft-deleted records excluded
- Helper function for community access checks
  </done>
</task>

</tasks>

<verification>
Complete verification of Phase 1 foundation:

```sql
-- 1. Verify both tables exist with RLS
SELECT
  t.tablename,
  t.rowsecurity AS rls_enabled,
  (SELECT COUNT(*) FROM pg_policies p WHERE p.tablename = t.tablename) AS policy_count
FROM pg_tables t
WHERE t.schemaname = 'public'
  AND t.tablename IN ('organizations', 'communities');

-- 2. Verify foreign key relationship
SELECT
  tc.table_name,
  kcu.column_name,
  ccu.table_name AS references_table
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = 'communities';

-- 3. Verify indexes for RLS performance
SELECT tablename, indexname
FROM pg_indexes
WHERE tablename IN ('organizations', 'communities')
ORDER BY tablename, indexname;

-- 4. Test UUID v7 generation in context
INSERT INTO organizations (name, slug, email)
VALUES ('Test Org', 'test-org', 'test@example.com')
RETURNING id, created_at, updated_at;

-- 5. Verify soft delete pattern (deleted_at column exists)
SELECT
  table_name,
  column_name
FROM information_schema.columns
WHERE column_name = 'deleted_at'
  AND table_name IN ('organizations', 'communities');

-- Clean up test data
DELETE FROM organizations WHERE slug = 'test-org';
```
</verification>

<success_criteria>
- [ ] organizations table has: id (UUID v7), name, slug, status, settings, audit columns, deleted_at
- [ ] communities table has: id (UUID v7), organization_id FK, name, timezone, locale, branding, settings, audit columns, deleted_at
- [ ] RLS is ENABLED on both tables (rowsecurity = true)
- [ ] organizations has 3 RLS policies (super_admin, users_view, exclude_deleted)
- [ ] communities has 3 RLS policies (super_admin, users_view, admins_update)
- [ ] RLS policies use (SELECT get_current_community_id()) pattern for performance
- [ ] Foreign key exists: communities.organization_id -> organizations.id
- [ ] Indexes exist on organization_id and community id columns
- [ ] Audit trigger fires on INSERT and UPDATE
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-multi-tenant-security/01-03-SUMMARY.md`
</output>
