---
phase: 02-stripe-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260218120000_stripe_customers_table.sql
  - supabase/migrations/20260218120001_webhook_events_table.sql
  - supabase/migrations/20260218120002_payment_intents_table.sql
autonomous: true

must_haves:
  truths:
    - "stripe_customers table exists with UNIQUE constraint on stripe_customer_id"
    - "webhook_events table exists with UNIQUE constraint on event_id for idempotency"
    - "payment_intents table exists with UNIQUE constraints on stripe_payment_intent_id and idempotency_key"
    - "RLS prevents residents from seeing other units' payment data"
    - "RLS allows admins full SELECT on all 3 tables within their community"
    - "RLS allows service_role full access (Edge Functions bypass RLS, but policies should not block)"
  artifacts:
    - path: "supabase/migrations/20260218120000_stripe_customers_table.sql"
      provides: "stripe_customers table with RLS"
      contains: "CREATE TABLE stripe_customers"
    - path: "supabase/migrations/20260218120001_webhook_events_table.sql"
      provides: "webhook_events table with RLS"
      contains: "CREATE TABLE webhook_events"
    - path: "supabase/migrations/20260218120002_payment_intents_table.sql"
      provides: "payment_intents table with RLS"
      contains: "CREATE TABLE payment_intents"
  key_links:
    - from: "stripe_customers"
      to: "residents, units, communities"
      via: "FOREIGN KEY references"
      pattern: "REFERENCES (residents|units|communities)"
    - from: "payment_intents"
      to: "transactions"
      via: "FK transaction_id for linking Stripe PI to ledger transaction"
      pattern: "REFERENCES transactions"
    - from: "payment_intents RLS"
      to: "occupancies"
      via: "Resident sees own unit's PIs through occupancies join"
      pattern: "occupancies"
---

<objective>
Create the three database tables required for Stripe integration: stripe_customers (maps residents to Stripe Customer IDs), webhook_events (idempotency deduplication), and payment_intents (tracks Stripe PaymentIntents). Each table gets full RLS policies following existing codebase patterns.

Purpose: These tables are the data foundation that both Edge Functions (create-payment-intent and payment-webhook) will read/write. Without them, no Stripe payment processing can occur.
Output: 3 SQL migration files deployed to the live database.
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Reference these existing migrations for patterns:
@supabase/migrations/20260129190101_transactions_table.sql (RLS pattern, FK patterns, immutability triggers)
@supabase/migrations/20260129190200_ledger_entries_table.sql (audit patterns)
@supabase/migrations/20260129105903_occupancies_table.sql (occupancies structure for RLS joins)
@supabase/migrations/20260208123300_fix_admin_rls_role_mismatch.sql (IMPORTANT: admin role = 'admin', 'community_admin', 'manager')
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stripe_customers and webhook_events tables with RLS</name>
  <files>
    supabase/migrations/20260218120000_stripe_customers_table.sql
    supabase/migrations/20260218120001_webhook_events_table.sql
  </files>
  <action>
Create two migration files following existing codebase conventions (header comments, generate_uuid_v7() PK, set_audit_fields trigger, RLS enabled).

CRITICAL: All PLPGSQL functions in these migrations MUST include `SET search_path = ''` per existing convention (see record_payment_charge.sql for reference). This prevents mutable search_path vulnerabilities flagged in MEMORY.md.

**stripe_customers (20260218120000):**
```sql
CREATE TABLE stripe_customers (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,
  resident_id UUID NOT NULL REFERENCES residents(id) ON DELETE RESTRICT,
  unit_id UUID NOT NULL REFERENCES units(id) ON DELETE RESTRICT,
  stripe_customer_id TEXT NOT NULL,
  email TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  CONSTRAINT stripe_customers_stripe_id_unique UNIQUE (stripe_customer_id),
  CONSTRAINT stripe_customers_resident_unit_unique UNIQUE (resident_id, unit_id)
);
```
Indexes: community_id, resident_id, stripe_customer_id (already via UNIQUE).
RLS policies:
- super_admin: FOR ALL using is_super_admin()
- residents SELECT own: `resident_id IN (SELECT r.id FROM residents r WHERE r.user_id = auth.uid() AND r.deleted_at IS NULL)`
- admins SELECT community: `community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'community_admin', 'manager')`
- No client INSERT/UPDATE/DELETE -- Edge Functions use service_role which bypasses RLS.
Add audit trigger: `EXECUTE FUNCTION set_audit_fields();`
Add comments on table and key columns.

If any helper PLPGSQL functions are defined in these migration files (e.g., trigger functions, utility functions), each MUST include `SET search_path = ''` in its declaration. This is a project-wide convention for security. Do NOT omit it.

**webhook_events (20260218120001):**
```sql
CREATE TABLE webhook_events (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  event_id TEXT NOT NULL,
  event_type TEXT NOT NULL,
  payload JSONB NOT NULL DEFAULT '{}',
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  transaction_id UUID REFERENCES transactions(id) ON DELETE RESTRICT,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,
  processed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT webhook_events_event_id_unique UNIQUE (event_id)
);
```
NOTE: No community_id on webhook_events -- Stripe events arrive without community context; the payload contains it. No updated_at (processing is one-directional). No deleted_at (audit trail, never delete).
Indexes: event_id (UNIQUE), status for queue processing, created_at for cleanup.
RLS policies:
- super_admin: FOR ALL using is_super_admin()
- admins SELECT only: `(SELECT get_current_user_role()) IN ('admin', 'community_admin', 'manager')` -- for debugging in admin dashboard. No community_id filter since table has no community_id; admins can see all events (acceptable for debugging; payload contains community info).
- No client INSERT/UPDATE/DELETE.
Add comment on table.

CRITICAL: Do NOT add set_audit_fields trigger to webhook_events -- it has no updated_at column.
  </action>
  <verify>
Run `npx supabase db push --linked` to apply migrations to the live database. Verify no errors.
If supabase CLI is not available, verify SQL syntax by reading the files and checking for:
- All FKs reference existing tables (communities, residents, units, transactions)
- CHECK constraints use correct values
- UNIQUE constraints are present on stripe_customer_id and event_id
- RLS is enabled and policies use correct role names ('admin', 'community_admin', 'manager')
- Any PLPGSQL functions include `SET search_path = ''`
  </verify>
  <done>
stripe_customers and webhook_events tables exist in the database with proper constraints, indexes, RLS policies, comments, and all PLPGSQL functions include SET search_path = ''.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create payment_intents table with RLS</name>
  <files>
    supabase/migrations/20260218120002_payment_intents_table.sql
  </files>
  <action>
Create migration file following existing codebase conventions.

CRITICAL: All PLPGSQL functions in this migration MUST include `SET search_path = ''` per existing convention. This is mandatory for all new PLPGSQL code in the project.

```sql
CREATE TABLE payment_intents (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,
  unit_id UUID NOT NULL REFERENCES units(id) ON DELETE RESTRICT,
  resident_id UUID REFERENCES residents(id) ON DELETE RESTRICT,
  stripe_payment_intent_id TEXT NOT NULL,
  stripe_customer_id TEXT NOT NULL,
  amount NUMERIC(15, 2) NOT NULL,
  currency VARCHAR(3) NOT NULL DEFAULT 'MXN',
  status TEXT NOT NULL DEFAULT 'created' CHECK (status IN (
    'created', 'requires_payment_method', 'requires_confirmation',
    'requires_action', 'processing', 'succeeded', 'failed', 'canceled'
  )),
  payment_method_type TEXT,
  description TEXT,
  idempotency_key TEXT NOT NULL,
  transaction_id UUID REFERENCES transactions(id) ON DELETE RESTRICT,
  metadata JSONB NOT NULL DEFAULT '{}',
  expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,

  CONSTRAINT payment_intents_stripe_pi_unique UNIQUE (stripe_payment_intent_id),
  CONSTRAINT payment_intents_idempotency_unique UNIQUE (idempotency_key),
  CONSTRAINT payment_intents_positive_amount CHECK (amount > 0)
);
```

Indexes:
- community_id + status (filtered queries by community)
- unit_id (unit payment history)
- stripe_payment_intent_id (already via UNIQUE)
- status for queue processing
- expires_at for OXXO voucher cleanup

RLS policies (follow pattern from transactions_table.sql but adapted):
- super_admin: FOR ALL using is_super_admin()
- residents SELECT own unit: `unit_id IN (SELECT o.unit_id FROM occupancies o JOIN residents r ON r.id = o.resident_id WHERE r.user_id = auth.uid() AND o.deleted_at IS NULL AND r.deleted_at IS NULL)` -- mirrors how transaction RLS works but through occupancies -> residents -> auth.uid() chain
- admins SELECT community: `community_id = (SELECT get_current_community_id()) AND (SELECT get_current_user_role()) IN ('admin', 'community_admin', 'manager')`
- No client INSERT/UPDATE/DELETE -- Edge Functions use service_role.

Add audit trigger: `EXECUTE FUNCTION set_audit_fields();`
Add comments on table and key columns (especially status CHECK values, expires_at for OXXO).

IMPORTANT: The resident RLS policy must join through occupancies (not direct resident_id check) because occupancies is the source of truth for "which resident lives in which unit". A resident may have moved out. Use the same pattern as the transactions table resident policy but updated for the occupancies -> residents -> user_id chain.

If any helper PLPGSQL functions are defined in this migration, they MUST include `SET search_path = ''`.
  </action>
  <verify>
Run `npx supabase db push --linked` to apply migration. Verify no errors.
Check SQL for:
- All 8 status CHECK values present
- Both UNIQUE constraints (stripe_payment_intent_id, idempotency_key)
- Positive amount CHECK
- FK to transactions (nullable - linked after payment succeeds)
- RLS policies use occupancies join for resident access
- Admin role check includes 'community_admin'
- Any PLPGSQL functions include `SET search_path = ''`
  </verify>
  <done>
payment_intents table exists with proper status CHECK constraint (8 values), UNIQUE constraints on stripe_payment_intent_id and idempotency_key, FK to transactions, full RLS policies, comments, and all PLPGSQL functions include SET search_path = ''.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. All 3 migration files exist in supabase/migrations/
2. Tables follow existing naming and convention patterns (uuid_v7 PK, audit triggers, RLS enabled)
3. UNIQUE constraints enforce Stripe ID uniqueness (stripe_customer_id, event_id, stripe_payment_intent_id, idempotency_key)
4. RLS policies use correct admin role list: 'admin', 'community_admin', 'manager'
5. No client write policies on any table (Edge Functions use service_role)
6. FK relationships: stripe_customers -> residents/units/communities, payment_intents -> transactions/units/communities/residents, webhook_events -> transactions
7. All PLPGSQL functions in all 3 migrations include SET search_path = ''
</verification>

<success_criteria>
- 3 SQL migration files created and syntactically valid
- stripe_customers has UNIQUE on stripe_customer_id and (resident_id, unit_id)
- webhook_events has UNIQUE on event_id (idempotency key for deduplication)
- payment_intents has UNIQUE on stripe_payment_intent_id and idempotency_key
- payment_intents has CHECK constraint with all 8 Stripe PI status values
- All tables have RLS enabled with policies following existing patterns
- All PLPGSQL functions include SET search_path = '' per project convention
- Migrations can be pushed to live database without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-stripe-infrastructure/02-01-SUMMARY.md`
</output>
