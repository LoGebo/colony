---
phase: 02-stripe-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
# NOTE: 02-02 and 02-03 can execute concurrently after 02-01 completes.
# They modify different files with no overlap.
files_modified:
  - supabase/functions/payment-webhook/index.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Webhook signature verification needs the webhook signing secret"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Select endpoint -> Signing secret (whsec_...)"
    dashboard_config:
      - task: "Create webhook endpoint pointing to https://qbaiviuluiqdbaymgxhq.supabase.co/functions/v1/payment-webhook"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"
      - task: "Subscribe to events: payment_intent.succeeded, payment_intent.payment_failed, payment_intent.canceled, payment_intent.requires_action, charge.refunded"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Select endpoint -> Events"

must_haves:
  truths:
    - "Webhook verifies Stripe signature using timing-safe comparison via jsr:@std/crypto/timing-safe-equal"
    - "Webhook checks timestamp tolerance (rejects events older than 5 minutes)"
    - "Webhook deduplicates events using webhook_events table (idempotency)"
    - "Webhook updates payment_intents.status for all PaymentIntent events"
    - "Webhook calls record_payment() RPC when payment_intent.succeeded fires, passing p_created_by from metadata.resident_id"
    - "record_payment() RPC returns a non-null transaction_id that gets stored in payment_intents"
    - "Webhook handles charge.refunded by creating reversal transactions"
    - "Webhook sends push notification on successful payment"
    - "Webhook returns 200 for all processed events (even duplicates) to prevent Stripe retries"
  artifacts:
    - path: "supabase/functions/payment-webhook/index.ts"
      provides: "Upgraded payment webhook with full Stripe event processing"
      min_lines: 150
  key_links:
    - from: "payment-webhook"
      to: "webhook_events table"
      via: "INSERT event_id for deduplication, UPDATE status on completion"
      pattern: "webhook_events"
    - from: "payment-webhook"
      to: "payment_intents table"
      via: "UPDATE status based on Stripe event type"
      pattern: "payment_intents"
    - from: "payment-webhook"
      to: "record_payment() RPC"
      via: "supabase.rpc('record_payment') on payment_intent.succeeded with p_created_by"
      pattern: "record_payment"
    - from: "payment-webhook"
      to: "Stripe signature verification"
      via: "jsr:@std/crypto timingSafeEqual for HMAC comparison"
      pattern: "timingSafeEqual"
    - from: "payment-webhook"
      to: "send-push Edge Function"
      via: "supabase.functions.invoke('send-push') on succeeded events"
      pattern: "send-push"
---

<objective>
Upgrade the existing payment-webhook Edge Function from a stub to a production-ready webhook handler. Implements timing-safe HMAC signature verification (using Deno standard library), timestamp tolerance check, idempotent event processing via webhook_events table, payment_intents status updates, record_payment() RPC call on succeeded events with full audit trail, refund handling, and push notifications.

Purpose: This is the critical path for payment completion. When a resident pays via Stripe, this webhook is how the system knows the payment succeeded and records it in the double-entry ledger. Without it, payments would process in Stripe but never update the app.
Output: A single Deno Edge Function file that replaces the existing stub.
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stripe-infrastructure/02-01-SUMMARY.md

Reference for record_payment signature (CRITICAL -- read the actual function):
@supabase/migrations/20260129191023_record_payment_charge.sql
- record_payment(p_community_id UUID, p_unit_id UUID, p_amount money_amount, p_payment_date DATE, p_description TEXT, p_payment_method_id UUID DEFAULT NULL, p_created_by UUID DEFAULT NULL) RETURNS UUID
- p_payment_method_id: FK to payment_methods table (can be NULL for Stripe since Stripe is not in payment_methods table yet; pass NULL)
- p_created_by: UUID of the resident who initiated the payment (from metadata.resident_id). MUST be passed for audit trail.
- Returns: transaction_id (UUID) -- MUST be non-null on success

Reference for unit_balances:
@supabase/migrations/20260129192018_unit_balances_view.sql

Reference for send-push Edge Function contract (already deployed):
- The send-push Edge Function is one of 3 deployed Edge Functions (per MEMORY.md)
- It requires JWT auth (Authorization header)
- Expected invocation pattern: supabase.functions.invoke('send-push', { body: { user_id, title, body } })
- Verify actual contract by checking if it accepts these fields; wrap in try/catch since contract is not 100% confirmed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stripe signature verification scaffold and helpers</name>
  <files>supabase/functions/payment-webhook/index.ts</files>
  <action>
Create `supabase/functions/payment-webhook/index.ts` (replaces existing stub).

This task writes the file skeleton: imports, initialization, signature verification function, and the Deno.serve scaffold with routing. Task 2 will add event handler implementations to the same file.

**Section 1 - Imports and initialization:**
```typescript
import { createClient } from "jsr:@supabase/supabase-js@2";
import { timingSafeEqual } from "jsr:@std/crypto/timing-safe-equal";

const STRIPE_WEBHOOK_SECRET = Deno.env.get("STRIPE_WEBHOOK_SECRET")!;
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Service role client for all DB operations (webhook has no user JWT)
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
```
CRITICAL: Import `timingSafeEqual` from `jsr:@std/crypto/timing-safe-equal` -- NOT from `crypto.subtle.timingSafeEqual` which does NOT exist in Deno and will throw a TypeError at runtime.

NOTE: Do NOT import Stripe npm package for webhook -- we only need raw signature verification, not the full SDK. This saves cold start time.

**Section 2 - Timing-safe signature verification function:**
```typescript
async function verifyStripeSignature(
  payload: string,
  sigHeader: string,
  secret: string,
  toleranceSeconds: number = 300 // 5 minutes
): Promise<{ verified: boolean; event?: any; error?: string }> {
  // Parse the Stripe-Signature header: t=timestamp,v1=signature
  const parts = sigHeader.split(",");
  const timestampStr = parts.find(p => p.startsWith("t="))?.slice(2);
  const signature = parts.find(p => p.startsWith("v1="))?.slice(3);

  if (!timestampStr || !signature) {
    return { verified: false, error: "Invalid signature header format" };
  }

  const timestamp = parseInt(timestampStr, 10);
  const now = Math.floor(Date.now() / 1000);

  // Timestamp tolerance check (prevent replay attacks)
  if (Math.abs(now - timestamp) > toleranceSeconds) {
    return { verified: false, error: `Timestamp outside tolerance: ${Math.abs(now - timestamp)}s` };
  }

  // Compute expected signature: HMAC-SHA256(timestamp + "." + payload)
  const signedPayload = `${timestamp}.${payload}`;
  const encoder = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signatureBytes = await crypto.subtle.sign("HMAC", key, encoder.encode(signedPayload));
  const expectedSignature = Array.from(new Uint8Array(signatureBytes))
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");

  // Timing-safe comparison using Deno standard library (prevents timing attacks)
  const expectedBytes = encoder.encode(expectedSignature);
  const receivedBytes = encoder.encode(signature);

  if (expectedBytes.length !== receivedBytes.length) {
    return { verified: false, error: "Signature length mismatch" };
  }

  // Use jsr:@std/crypto timingSafeEqual -- NOT crypto.subtle.timingSafeEqual (does not exist in Deno)
  const isValid = timingSafeEqual(expectedBytes, receivedBytes);

  if (!isValid) {
    return { verified: false, error: "Signature verification failed" };
  }

  // Parse the event payload
  try {
    const event = JSON.parse(payload);
    return { verified: true, event };
  } catch {
    return { verified: false, error: "Invalid JSON payload" };
  }
}
```

**Section 3 - Main handler scaffold (Deno.serve):**
Write the complete Deno.serve handler with:
- POST-only validation (405 for non-POST)
- stripe-signature header extraction (400 if missing)
- Signature verification call
- Idempotency check via webhook_events table (SELECT by event_id, return 200 for duplicates)
- INSERT new event as "processing" with race condition handling (UNIQUE violation 23505 = duplicate, return 200)
- Event type routing switch (payment_intent.succeeded/failed/canceled/requires_action + charge.refunded) calling handler functions (to be implemented in Task 2)
- webhook_events UPDATE with result status after processing
- Always return 200 to Stripe after signature verification passes

CRITICAL: Always return 200 to Stripe after signature verification passes. If we return 500, Stripe will retry, potentially causing duplicate processing before our idempotency check catches it.

IMPORTANT: The function does NOT require JWT (it's a public webhook endpoint). Stripe authenticates via the HMAC signature.
IMPORTANT: Do NOT use `Deno.env.get("SUPABASE_ANON_KEY")` -- there's no user context. Use only service_role for DB operations.

Leave event handler function bodies as stubs (e.g., `async function handlePaymentIntentSucceeded(event: any) { /* Task 2 */ }`) -- Task 2 fills them in.
  </action>
  <verify>
Verify the file:
1. Import uses `jsr:@std/crypto/timing-safe-equal` (NOT crypto.subtle.timingSafeEqual)
2. timingSafeEqual is called as a standalone function, not a method on crypto.subtle
3. No JWT requirement (webhook is public)
4. Stripe signature verification uses crypto.subtle.importKey + crypto.subtle.sign for HMAC
5. Timestamp tolerance check: rejects events >5 minutes old
6. Idempotency: SELECT webhook_events by event_id, skip if exists, INSERT before processing
7. Race condition handling: UNIQUE violation (23505) on INSERT returns 200 (not error)
8. Deno.serve with event type routing switch is present
9. Always returns 200 after signature verification
  </verify>
  <done>
payment-webhook/index.ts exists with correct imports (jsr:@std/crypto/timing-safe-equal), timing-safe HMAC signature verification, 5-minute timestamp tolerance, idempotent event processing scaffold via webhook_events table, and Deno.serve with event routing. Handler function bodies are stubs ready for Task 2.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement event handlers (succeeded, failed, canceled, requires_action, refunded)</name>
  <files>supabase/functions/payment-webhook/index.ts</files>
  <action>
Fill in the event handler function bodies in the file created by Task 1.

**handlePaymentIntentSucceeded(event):**
1. Extract from event.data.object: id (pi_xxx), amount, currency, metadata (community_id, unit_id, resident_id)
2. Update payment_intents table: SET status = 'succeeded', updated_at = now() WHERE stripe_payment_intent_id = pi_id
3. Call record_payment() RPC with ALL required params including audit trail:
   ```typescript
   const { data: transactionId, error: rpcError } = await supabase.rpc('record_payment', {
     p_community_id: metadata.community_id,
     p_unit_id: metadata.unit_id,
     p_amount: amount / 100,  // Stripe centavos -> MXN pesos
     p_payment_date: new Date().toISOString().split('T')[0],
     p_description: 'Pago con tarjeta via Stripe - ' + pi_id,
     p_payment_method_id: null,  // Stripe is not in payment_methods table; pass NULL
     p_created_by: metadata.resident_id  // CRITICAL: audit trail - who initiated this payment
   });
   ```
   CRITICAL: `p_created_by` MUST be set to `metadata.resident_id` for proper audit trail. Without it, the transaction has no creator and audit is broken.
   NOTE: `p_payment_method_id` is NULL because Stripe payments are not tracked in the payment_methods table (that table is for manual payment methods like bank transfer, cash, etc.). Pass NULL explicitly.
4. Verify RPC returned a non-null transaction_id: `if (rpcError || !transactionId) { console.error('record_payment failed:', rpcError); return { success: false, error: rpcError?.message || 'record_payment returned null' }; }`
5. UPDATE payment_intents SET transaction_id = transactionId WHERE stripe_payment_intent_id = pi_id
6. Send push notification via supabase.functions.invoke('send-push', { body: { user_id: resident's user_id, title: 'Pago recibido', body: `Tu pago de $${(amount/100).toFixed(2)} ha sido procesado` } }). Look up user_id from residents table using metadata.resident_id. Wrap the send-push call in try/catch -- if it fails, log the error but do NOT fail the webhook handler (push notification is non-critical). The send-push contract may accept { user_id, title, body } but verify against the actual deployed function; if the schema differs, adjust accordingly.
7. Return { success: true, transaction_id: transactionId }

**handlePaymentIntentFailed(event):**
1. Extract pi_id from event.data.object
2. Update payment_intents: SET status = 'failed'
3. Optionally send push notification about failure
4. Return { success: true }

**handlePaymentIntentCanceled(event):**
1. Update payment_intents: SET status = 'canceled'
2. Return { success: true }

**handlePaymentIntentRequiresAction(event):**
1. Update payment_intents: SET status = 'requires_action'
2. Return { success: true }

**handleChargeRefunded(event):**
1. Extract charge from event.data.object
2. Find payment_intent_id from charge.payment_intent
3. Look up payment_intents record to get transaction_id
4. If transaction_id exists, create a reversal: This is complex -- for now, just log and update payment_intents status to 'canceled'. Full reversal (calling a record_reversal function) is Phase 07 scope. Add a TODO comment.
5. Return { success: true }
  </action>
  <verify>
Verify the file:
1. handlePaymentIntentSucceeded calls supabase.rpc('record_payment') with BOTH p_created_by (metadata.resident_id) AND p_payment_method_id (null)
2. record_payment RPC result is checked for non-null transactionId: `if (rpcError || !transactionId)` with error handling
3. transaction_id is stored in payment_intents table after successful RPC
4. Amount conversion: Stripe centavos / 100 = MXN pesos for record_payment
5. payment_intents table status updated for ALL event types (succeeded, failed, canceled, requires_action)
6. Push notification on succeeded wrapped in try/catch (non-critical)
7. send-push invocation uses supabase.functions.invoke with { body: { user_id, title, body } }
8. charge.refunded handler updates status and logs TODO for Phase 07 reversal
9. All handlers return { success: boolean } with optional transaction_id
10. webhook_events updated with status, error_message, transaction_id, processed_at (in Deno.serve handler from Task 1)
  </verify>
  <done>
payment-webhook Edge Function fully implemented with: all 5 event handlers filled in, record_payment() RPC call includes p_created_by (metadata.resident_id) and p_payment_method_id (null) with non-null transaction_id verification, push notification on succeeded (wrapped in try/catch), payment_intents status sync for all event types, charge.refunded with TODO for full reversal. File is complete and ready for deployment.
  </done>
</task>

</tasks>

<verification>
1. File exists: supabase/functions/payment-webhook/index.ts
2. Import: `import { timingSafeEqual } from "jsr:@std/crypto/timing-safe-equal"` (NOT crypto.subtle.timingSafeEqual)
3. Signature verification: HMAC-SHA256 with timing-safe comparison via imported timingSafeEqual
4. Timestamp tolerance: +-5 minutes (300 seconds)
5. Idempotency: webhook_events table deduplication with race condition handling
6. Event routing: payment_intent.succeeded/failed/canceled/requires_action + charge.refunded
7. Record payment: supabase.rpc('record_payment') with amount/100 conversion, p_created_by = metadata.resident_id, p_payment_method_id = null
8. Transaction ID: Verified non-null from RPC, stored in payment_intents.transaction_id
9. Status sync: payment_intents.status updated on every event
10. Push notification: send-push invoked on succeeded, wrapped in try/catch
11. Response: Always 200 after valid signature (even on processing errors)
12. No JWT required (public webhook endpoint)
</verification>

<success_criteria>
- payment-webhook/index.ts exists with >150 lines of implementation
- Uses jsr:@std/crypto/timing-safe-equal for timing-safe comparison (NOT crypto.subtle.timingSafeEqual)
- Uses Deno crypto.subtle for HMAC key import and signing
- Timestamp tolerance rejects events >5 min old
- webhook_events INSERT before processing, UPDATE after
- UNIQUE violation (23505) treated as duplicate, returns 200
- record_payment() called with correct params: p_community_id, p_unit_id, p_amount (amount/100), p_payment_date, p_description, p_payment_method_id (null), p_created_by (metadata.resident_id)
- RPC result verified non-null; transaction_id stored in payment_intents
- payment_intents.status updated for all 5 handled event types
- send-push invocation wrapped in try/catch
- Returns 200 to Stripe for all post-verification requests
</success_criteria>

<output>
After completion, create `.planning/phases/02-stripe-infrastructure/02-03-SUMMARY.md`
</output>
