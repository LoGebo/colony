---
phase: 02-stripe-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - supabase/functions/payment-webhook/index.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Webhook signature verification needs the webhook signing secret"
    env_vars:
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Select endpoint -> Signing secret (whsec_...)"
    dashboard_config:
      - task: "Create webhook endpoint pointing to https://qbaiviuluiqdbaymgxhq.supabase.co/functions/v1/payment-webhook"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"
      - task: "Subscribe to events: payment_intent.succeeded, payment_intent.payment_failed, payment_intent.canceled, payment_intent.requires_action, charge.refunded"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Select endpoint -> Events"

must_haves:
  truths:
    - "Webhook verifies Stripe signature using timing-safe comparison"
    - "Webhook checks timestamp tolerance (rejects events older than 5 minutes)"
    - "Webhook deduplicates events using webhook_events table (idempotency)"
    - "Webhook updates payment_intents.status for all PaymentIntent events"
    - "Webhook calls record_payment() RPC when payment_intent.succeeded fires"
    - "Webhook handles charge.refunded by creating reversal transactions"
    - "Webhook sends push notification on successful payment"
    - "Webhook returns 200 for all processed events (even duplicates) to prevent Stripe retries"
  artifacts:
    - path: "supabase/functions/payment-webhook/index.ts"
      provides: "Upgraded payment webhook with full Stripe event processing"
      min_lines: 150
  key_links:
    - from: "payment-webhook"
      to: "webhook_events table"
      via: "INSERT event_id for deduplication, UPDATE status on completion"
      pattern: "webhook_events"
    - from: "payment-webhook"
      to: "payment_intents table"
      via: "UPDATE status based on Stripe event type"
      pattern: "payment_intents"
    - from: "payment-webhook"
      to: "record_payment() RPC"
      via: "supabase.rpc('record_payment') on payment_intent.succeeded"
      pattern: "record_payment"
    - from: "payment-webhook"
      to: "Stripe signature verification"
      via: "crypto.subtle.timingSafeEqual for HMAC comparison"
      pattern: "timingSafeEqual"
---

<objective>
Upgrade the existing payment-webhook Edge Function from a stub to a production-ready webhook handler. Implements timing-safe HMAC signature verification, timestamp tolerance check, idempotent event processing via webhook_events table, payment_intents status updates, record_payment() RPC call on succeeded events, refund handling, and push notifications.

Purpose: This is the critical path for payment completion. When a resident pays via Stripe, this webhook is how the system knows the payment succeeded and records it in the double-entry ledger. Without it, payments would process in Stripe but never update the app.
Output: A single Deno Edge Function file that replaces the existing stub.
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stripe-infrastructure/02-01-SUMMARY.md

Reference for record_payment signature:
@supabase/migrations/20260129191023_record_payment_charge.sql
- record_payment(p_community_id UUID, p_unit_id UUID, p_amount money_amount, p_payment_date DATE, p_description TEXT, p_payment_method_id UUID DEFAULT NULL, p_created_by UUID DEFAULT NULL) RETURNS UUID

Reference for unit_balances:
@supabase/migrations/20260129192018_unit_balances_view.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stripe signature verification with timing-safe comparison</name>
  <files>supabase/functions/payment-webhook/index.ts</files>
  <action>
Create `supabase/functions/payment-webhook/index.ts` (replaces existing stub).

This task writes the COMPLETE file. The function is structured in sections:

**Section 1 - Imports and initialization:**
```typescript
import { createClient } from "jsr:@supabase/supabase-js@2";

const STRIPE_WEBHOOK_SECRET = Deno.env.get("STRIPE_WEBHOOK_SECRET")!;
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

// Service role client for all DB operations (webhook has no user JWT)
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
```
NOTE: Do NOT import Stripe npm package for webhook -- we only need raw signature verification, not the full SDK. This saves cold start time.

**Section 2 - Timing-safe signature verification function:**
```typescript
async function verifyStripeSignature(
  payload: string,
  sigHeader: string,
  secret: string,
  toleranceSeconds: number = 300 // 5 minutes
): Promise<{ verified: boolean; event?: any; error?: string }> {
  // Parse the Stripe-Signature header: t=timestamp,v1=signature
  const parts = sigHeader.split(",");
  const timestampStr = parts.find(p => p.startsWith("t="))?.slice(2);
  const signature = parts.find(p => p.startsWith("v1="))?.slice(3);

  if (!timestampStr || !signature) {
    return { verified: false, error: "Invalid signature header format" };
  }

  const timestamp = parseInt(timestampStr, 10);
  const now = Math.floor(Date.now() / 1000);

  // Timestamp tolerance check (prevent replay attacks)
  if (Math.abs(now - timestamp) > toleranceSeconds) {
    return { verified: false, error: `Timestamp outside tolerance: ${Math.abs(now - timestamp)}s` };
  }

  // Compute expected signature: HMAC-SHA256(timestamp + "." + payload)
  const signedPayload = `${timestamp}.${payload}`;
  const encoder = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signatureBytes = await crypto.subtle.sign("HMAC", key, encoder.encode(signedPayload));
  const expectedSignature = Array.from(new Uint8Array(signatureBytes))
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");

  // Timing-safe comparison (prevent timing attacks)
  const expectedBytes = encoder.encode(expectedSignature);
  const receivedBytes = encoder.encode(signature);

  if (expectedBytes.length !== receivedBytes.length) {
    return { verified: false, error: "Signature length mismatch" };
  }

  // crypto.subtle.timingSafeEqual is available in Deno
  const isValid = crypto.subtle.timingSafeEqual(expectedBytes, receivedBytes);

  if (!isValid) {
    return { verified: false, error: "Signature verification failed" };
  }

  // Parse the event payload
  try {
    const event = JSON.parse(payload);
    return { verified: true, event };
  } catch {
    return { verified: false, error: "Invalid JSON payload" };
  }
}
```

**Section 3 - Event handlers (separate functions for each event type):**

`handlePaymentIntentSucceeded(event)`:
1. Extract from event.data.object: id (pi_xxx), amount, currency, metadata (community_id, unit_id, resident_id)
2. Update payment_intents table: SET status = 'succeeded', updated_at = now() WHERE stripe_payment_intent_id = pi_id
3. Call record_payment() RPC: `supabase.rpc('record_payment', { p_community_id: metadata.community_id, p_unit_id: metadata.unit_id, p_amount: amount / 100, p_payment_date: new Date().toISOString().split('T')[0], p_description: 'Pago con tarjeta via Stripe - ' + pi_id })`. Amount divided by 100 because Stripe uses centavos.
4. If RPC returns transaction_id, UPDATE payment_intents SET transaction_id = transaction_id WHERE stripe_payment_intent_id = pi_id
5. Send push notification via supabase.functions.invoke('send-push', { body: { user_id: resident's user_id, title: 'Pago recibido', body: 'Tu pago de $X.XX ha sido procesado' } }). Look up user_id from residents table using metadata.resident_id.
6. Return { success: true, transaction_id }

`handlePaymentIntentFailed(event)`:
1. Extract pi_id from event.data.object
2. Update payment_intents: SET status = 'failed'
3. Optionally send push notification about failure
4. Return { success: true }

`handlePaymentIntentCanceled(event)`:
1. Update payment_intents: SET status = 'canceled'
2. Return { success: true }

`handlePaymentIntentRequiresAction(event)`:
1. Update payment_intents: SET status = 'requires_action'
2. Return { success: true }

`handleChargeRefunded(event)`:
1. Extract charge from event.data.object
2. Find payment_intent_id from charge.payment_intent
3. Look up payment_intents record to get transaction_id
4. If transaction_id exists, create a reversal: This is complex -- for now, just log and update payment_intents status to 'canceled'. Full reversal (calling a record_reversal function) is Phase 07 scope. Add a TODO comment.
5. Return { success: true }

**Section 4 - Main handler (Deno.serve):**
```typescript
Deno.serve(async (req: Request) => {
  // Only accept POST
  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), { status: 405 });
  }

  const body = await req.text();
  const sigHeader = req.headers.get("stripe-signature");

  if (!sigHeader) {
    return new Response(JSON.stringify({ error: "Missing stripe-signature header" }), { status: 400 });
  }

  // 1. Verify signature (timing-safe)
  const { verified, event, error: verifyError } = await verifyStripeSignature(body, sigHeader, STRIPE_WEBHOOK_SECRET);
  if (!verified) {
    console.error("Webhook signature verification failed:", verifyError);
    return new Response(JSON.stringify({ error: "Invalid signature" }), { status: 401 });
  }

  // 2. Idempotency check via webhook_events table
  const { data: existing } = await supabase
    .from("webhook_events")
    .select("id, status")
    .eq("event_id", event.id)
    .maybeSingle();

  if (existing) {
    // Already processed or processing -- return 200 to prevent Stripe retry
    console.log(`Duplicate event ${event.id}, status: ${existing.status}`);
    return new Response(JSON.stringify({ received: true, duplicate: true }), { status: 200 });
  }

  // 3. Insert event as "processing"
  const { error: insertError } = await supabase
    .from("webhook_events")
    .insert({
      event_id: event.id,
      event_type: event.type,
      payload: event,
      status: "processing",
    });

  if (insertError) {
    // If UNIQUE violation, another instance already processing (race condition)
    if (insertError.code === "23505") {
      return new Response(JSON.stringify({ received: true, duplicate: true }), { status: 200 });
    }
    console.error("Failed to insert webhook event:", insertError);
    return new Response(JSON.stringify({ error: "Internal error" }), { status: 500 });
  }

  // 4. Route to handler based on event type
  let result: { success: boolean; error?: string; transaction_id?: string } = { success: false };

  try {
    switch (event.type) {
      case "payment_intent.succeeded":
        result = await handlePaymentIntentSucceeded(event);
        break;
      case "payment_intent.payment_failed":
        result = await handlePaymentIntentFailed(event);
        break;
      case "payment_intent.canceled":
        result = await handlePaymentIntentCanceled(event);
        break;
      case "payment_intent.requires_action":
        result = await handlePaymentIntentRequiresAction(event);
        break;
      case "charge.refunded":
        result = await handleChargeRefunded(event);
        break;
      default:
        // Unhandled event type -- mark as completed (don't want retries)
        console.log(`Unhandled event type: ${event.type}`);
        result = { success: true };
    }
  } catch (err) {
    console.error(`Error processing event ${event.id}:`, err);
    result = { success: false, error: String(err) };
  }

  // 5. Update webhook_events with result
  await supabase
    .from("webhook_events")
    .update({
      status: result.success ? "completed" : "failed",
      error_message: result.error || null,
      transaction_id: result.transaction_id || null,
      processed_at: new Date().toISOString(),
    })
    .eq("event_id", event.id);

  // 6. Always return 200 to Stripe (even on processing errors)
  // Stripe will retry on non-2xx, which would create duplicate processing attempts
  return new Response(JSON.stringify({ received: true, success: result.success }), { status: 200 });
});
```

CRITICAL: Always return 200 to Stripe after signature verification passes. If we return 500, Stripe will retry, potentially causing duplicate processing before our idempotency check catches it. Better to log the error and handle it manually.

IMPORTANT: The function does NOT require JWT (it's a public webhook endpoint). Stripe authenticates via the HMAC signature.

IMPORTANT: Do NOT use `Deno.env.get("SUPABASE_ANON_KEY")` -- there's no user context. Use only service_role for DB operations.
  </action>
  <verify>
Verify the file:
1. No JWT requirement (webhook is public)
2. Stripe signature verification uses crypto.subtle.importKey + crypto.subtle.sign + crypto.subtle.timingSafeEqual
3. Timestamp tolerance check: rejects events >5 minutes old
4. Idempotency: SELECT webhook_events by event_id, skip if exists, INSERT before processing
5. Race condition handling: UNIQUE violation (23505) on INSERT returns 200 (not error)
6. payment_intent.succeeded handler calls supabase.rpc('record_payment') with correct params
7. Amount conversion: Stripe centavos / 100 = MXN pesos for record_payment
8. payment_intents table status updated for ALL event types
9. Push notification sent on succeeded via supabase.functions.invoke('send-push')
10. Always returns 200 after signature verification (prevents Stripe retries)
11. webhook_events updated with status, error_message, processed_at
  </verify>
  <done>
payment-webhook Edge Function fully implemented with timing-safe HMAC signature verification, 5-minute timestamp tolerance, idempotent event processing via webhook_events table, payment_intents status updates for all event types, record_payment() RPC call on succeeded events with correct centavos-to-pesos conversion, push notification on success, and always-200 response pattern. charge.refunded logged with TODO for full reversal in Phase 07.
  </done>
</task>

</tasks>

<verification>
1. File exists: supabase/functions/payment-webhook/index.ts
2. Signature verification: HMAC-SHA256 with timing-safe comparison
3. Timestamp tolerance: +-5 minutes (300 seconds)
4. Idempotency: webhook_events table deduplication with race condition handling
5. Event routing: payment_intent.succeeded/failed/canceled/requires_action + charge.refunded
6. Record payment: supabase.rpc('record_payment') with amount/100 conversion
7. Status sync: payment_intents.status updated on every event
8. Push notification: send-push invoked on succeeded
9. Response: Always 200 after valid signature (even on processing errors)
10. No JWT required (public webhook endpoint)
</verification>

<success_criteria>
- payment-webhook/index.ts exists with >150 lines of implementation
- Uses Deno crypto.subtle for HMAC (not Stripe npm verify helper -- lighter cold start)
- Timing-safe comparison via crypto.subtle.timingSafeEqual
- Timestamp tolerance rejects events >5 min old
- webhook_events INSERT before processing, UPDATE after
- UNIQUE violation (23505) treated as duplicate, returns 200
- record_payment() called with correct params (amount/100, date, community_id, unit_id)
- payment_intents.status updated for all 5 handled event types
- Returns 200 to Stripe for all post-verification requests
</success_criteria>

<output>
After completion, create `.planning/phases/02-stripe-infrastructure/02-03-SUMMARY.md`
</output>
