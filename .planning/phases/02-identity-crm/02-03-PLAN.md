---
phase: 02-identity-crm
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - supabase/migrations/*_resident_documents_table.sql
  - supabase/migrations/*_resident_documents_storage.sql
autonomous: true

must_haves:
  truths:
    - "Resident documents can be uploaded with type categorization"
    - "Documents have verification workflow (pending -> approved/rejected)"
    - "Documents track expiration dates"
    - "Storage bucket exists with RLS for document isolation"
    - "Users can only access their own documents or community docs (if admin)"
  artifacts:
    - path: "supabase/migrations/*_resident_documents_table.sql"
      provides: "resident_documents table with verification workflow"
      contains: "verification_status approval_status"
    - path: "supabase/migrations/*_resident_documents_storage.sql"
      provides: "storage bucket and RLS policies"
      contains: "storage.buckets"
  key_links:
    - from: "resident_documents.resident_id"
      to: "residents.id"
      via: "FOREIGN KEY"
      pattern: "REFERENCES residents\\(id\\)"
    - from: "resident_documents.storage_path"
      to: "storage.objects"
      via: "path reference"
      pattern: "storage_path TEXT NOT NULL"
    - from: "storage RLS policy"
      to: "get_current_community_id()"
      via: "folder path check"
      pattern: "foldername\\(name\\)"
---

<objective>
Create the resident documents table and Supabase Storage bucket with RLS policies for secure document management.

Purpose: Documents are needed for KYC verification (INE, proof of address), lease contracts, and other compliance requirements. This plan completes the CRM foundation.

Output:
- resident_documents table (metadata, verification workflow, expiration tracking)
- Supabase Storage bucket with RLS policies for isolation
</objective>

<execution_context>
@C:\Users\PC\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\PC\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-identity-crm/02-RESEARCH.md
@.planning/phases/02-identity-crm/02-01-SUMMARY.md
@.planning/phases/02-identity-crm/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resident_documents table with verification workflow</name>
  <files>supabase/migrations/*_resident_documents_table.sql</files>
  <action>
Create the resident_documents table for document metadata:

```sql
-- Resident documents: metadata for files in Supabase Storage
CREATE TABLE resident_documents (
  id UUID PRIMARY KEY DEFAULT generate_uuid_v7(),
  community_id UUID NOT NULL REFERENCES communities(id) ON DELETE RESTRICT,
  resident_id UUID NOT NULL REFERENCES residents(id) ON DELETE CASCADE,

  -- Document metadata
  document_type document_type NOT NULL,
  name TEXT NOT NULL,                  -- User-friendly name
  description TEXT,

  -- Storage reference
  -- Path format: {community_id}/{resident_id}/{document_type}/{filename}
  storage_path TEXT NOT NULL,
  storage_bucket TEXT NOT NULL DEFAULT 'resident-documents',

  -- File metadata
  file_name TEXT NOT NULL,
  file_size_bytes INTEGER,
  mime_type TEXT,

  -- Validity
  issued_at DATE,
  expires_at DATE,

  -- Verification workflow
  verification_status approval_status NOT NULL DEFAULT 'pending',
  verified_at TIMESTAMPTZ,
  verified_by UUID REFERENCES auth.users(id),
  rejection_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,
  created_by UUID REFERENCES auth.users(id)
);

-- Enable RLS
ALTER TABLE resident_documents ENABLE ROW LEVEL SECURITY;

-- Audit trigger
CREATE TRIGGER set_resident_documents_audit
  BEFORE INSERT OR UPDATE ON resident_documents
  FOR EACH ROW
  EXECUTE FUNCTION set_audit_fields();

-- Indexes
CREATE INDEX idx_resident_documents_resident ON resident_documents(resident_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_resident_documents_community ON resident_documents(community_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_resident_documents_type ON resident_documents(resident_id, document_type) WHERE deleted_at IS NULL;
CREATE INDEX idx_resident_documents_verification ON resident_documents(community_id, verification_status)
  WHERE deleted_at IS NULL;

-- Index for expiring documents (useful for reminders)
CREATE INDEX idx_resident_documents_expiring
  ON resident_documents(expires_at, document_type)
  WHERE deleted_at IS NULL AND expires_at IS NOT NULL;

-- Partial unique index: prevent duplicate active documents of same type per resident
-- (allows re-uploading after rejection or deletion)
CREATE UNIQUE INDEX idx_resident_documents_unique_active_type
  ON resident_documents(resident_id, document_type)
  WHERE deleted_at IS NULL AND verification_status != 'rejected';

-- RLS Policies

-- Super admins full access
CREATE POLICY "super_admins_full_access_documents"
  ON resident_documents
  FOR ALL
  TO authenticated
  USING ((SELECT is_super_admin()));

-- Users can view their own documents
CREATE POLICY "users_view_own_documents"
  ON resident_documents
  FOR SELECT
  TO authenticated
  USING (
    resident_id = auth.uid()
    AND deleted_at IS NULL
  );

-- Users can upload their own documents
CREATE POLICY "users_upload_own_documents"
  ON resident_documents
  FOR INSERT
  TO authenticated
  WITH CHECK (
    resident_id = auth.uid()
    AND community_id = (SELECT get_current_community_id())
  );

-- Users can update their own pending documents (before verification)
CREATE POLICY "users_update_own_pending_documents"
  ON resident_documents
  FOR UPDATE
  TO authenticated
  USING (
    resident_id = auth.uid()
    AND verification_status = 'pending'
    AND deleted_at IS NULL
  )
  WITH CHECK (
    resident_id = auth.uid()
    AND verification_status = 'pending'
  );

-- Admins can view all community documents
CREATE POLICY "admins_view_community_documents"
  ON resident_documents
  FOR SELECT
  TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Admins can manage all community documents (verify, reject)
CREATE POLICY "admins_manage_community_documents"
  ON resident_documents
  FOR ALL
  TO authenticated
  USING (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  )
  WITH CHECK (
    community_id = (SELECT get_current_community_id())
    AND (SELECT get_current_user_role()) IN ('admin', 'manager')
  );

-- Comments
COMMENT ON TABLE resident_documents IS 'Document metadata with verification workflow, files stored in Supabase Storage';
COMMENT ON COLUMN resident_documents.storage_path IS 'Path format: {community_id}/{resident_id}/{document_type}/{filename}';
COMMENT ON COLUMN resident_documents.verification_status IS 'Workflow: pending -> approved or rejected';
```

Apply using mcp__supabase__apply_migration tool.
  </action>
  <verify>
Use mcp__supabase__execute_sql:
1. Table exists: `SELECT column_name FROM information_schema.columns WHERE table_name = 'resident_documents' AND column_name IN ('verification_status', 'storage_path', 'expires_at');`
2. RLS enabled: `SELECT relrowsecurity FROM pg_class WHERE relname = 'resident_documents';`
3. Policies: `SELECT policyname FROM pg_policies WHERE tablename = 'resident_documents';`
4. Unique index: `SELECT indexname FROM pg_indexes WHERE tablename = 'resident_documents' AND indexname LIKE '%unique%';`
  </verify>
  <done>resident_documents table exists with verification_status, storage_path, expiration tracking, partial unique index, RLS enabled with 6 policies</done>
</task>

<task type="auto">
  <name>Task 2: Create storage bucket with RLS policies for documents</name>
  <files>supabase/migrations/*_resident_documents_storage.sql</files>
  <action>
Create the Supabase Storage bucket and RLS policies:

```sql
-- Create the storage bucket for resident documents
-- Note: This requires the storage schema to exist (part of Supabase)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'resident-documents',
  'resident-documents',
  false,  -- Private bucket (requires RLS for access)
  10485760,  -- 10MB limit per file
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
)
ON CONFLICT (id) DO UPDATE SET
  public = EXCLUDED.public,
  file_size_limit = EXCLUDED.file_size_limit,
  allowed_mime_types = EXCLUDED.allowed_mime_types;

-- RLS policy: Users can upload to their own folder
-- Path structure: {community_id}/{resident_id}/{document_type}/{filename}
CREATE POLICY "users_upload_own_documents"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[1] = (SELECT get_current_community_id())::TEXT
  AND (storage.foldername(name))[2] = auth.uid()::TEXT
);

-- RLS policy: Users can view their own documents
CREATE POLICY "users_view_own_documents"
ON storage.objects
FOR SELECT
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[2] = auth.uid()::TEXT
);

-- RLS policy: Users can update their own documents
CREATE POLICY "users_update_own_documents"
ON storage.objects
FOR UPDATE
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[2] = auth.uid()::TEXT
)
WITH CHECK (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[2] = auth.uid()::TEXT
);

-- RLS policy: Users can delete their own documents
CREATE POLICY "users_delete_own_documents"
ON storage.objects
FOR DELETE
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[2] = auth.uid()::TEXT
);

-- RLS policy: Admins can view all community documents
CREATE POLICY "admins_view_community_documents"
ON storage.objects
FOR SELECT
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[1] = (SELECT get_current_community_id())::TEXT
  AND (SELECT get_current_user_role()) IN ('admin', 'manager')
);

-- RLS policy: Admins can manage all community documents
CREATE POLICY "admins_manage_community_documents"
ON storage.objects
FOR ALL
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (storage.foldername(name))[1] = (SELECT get_current_community_id())::TEXT
  AND (SELECT get_current_user_role()) IN ('admin', 'manager')
);

-- Super admins full access
CREATE POLICY "super_admins_full_access_storage"
ON storage.objects
FOR ALL
TO authenticated
USING (
  bucket_id = 'resident-documents'
  AND (SELECT is_super_admin())
);

-- Comments (on bucket via separate query since buckets don't support COMMENT)
-- Document the expected path structure
COMMENT ON TABLE storage.objects IS 'Files stored with path: {community_id}/{resident_id}/{document_type}/{filename}';
```

Apply using mcp__supabase__apply_migration tool.

NOTE: If the storage policies already exist, the migration may fail. In that case, use DROP POLICY IF EXISTS before CREATE POLICY, or check if policies exist first.
  </action>
  <verify>
Use mcp__supabase__execute_sql:
1. Bucket exists: `SELECT id, name, public FROM storage.buckets WHERE id = 'resident-documents';`
2. Storage policies exist: `SELECT policyname FROM pg_policies WHERE tablename = 'objects' AND schemaname = 'storage' AND policyname LIKE '%documents%';`
  </verify>
  <done>resident-documents bucket exists (private, 10MB limit, image/pdf types), storage RLS policies created for user isolation and admin access</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify resident_documents table:
```sql
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'resident_documents'
ORDER BY ordinal_position;
```

2. Verify storage bucket:
```sql
SELECT id, name, public, file_size_limit, allowed_mime_types
FROM storage.buckets
WHERE id = 'resident-documents';
```

3. Verify RLS on both:
```sql
SELECT 'resident_documents' as table_name, COUNT(*) as policy_count
FROM pg_policies WHERE tablename = 'resident_documents'
UNION ALL
SELECT 'storage.objects', COUNT(*)
FROM pg_policies WHERE tablename = 'objects' AND schemaname = 'storage';
```

4. Verify FK to residents:
```sql
SELECT conname, confrelid::regclass
FROM pg_constraint
WHERE conrelid = 'resident_documents'::regclass
AND contype = 'f';
```
</verification>

<success_criteria>
- resident_documents table: has document_type, verification_status, storage_path, expires_at, RLS with 6 policies
- Partial unique index prevents duplicate active documents of same type
- Storage bucket: resident-documents, private, 10MB limit, accepts image/pdf
- Storage RLS: 7 policies (user CRUD on own folder, admin access to community, super_admin)
- FK constraint to residents (ON DELETE CASCADE)
- Audit trigger attached
- Migration files committed
</success_criteria>

<output>
After completion, create `.planning/phases/02-identity-crm/02-03-SUMMARY.md` following the summary template.
</output>
