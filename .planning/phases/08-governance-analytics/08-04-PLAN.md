---
phase: 08-governance-analytics
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_parking_enums.sql
  - supabase/migrations/TIMESTAMP_parking_tables.sql
  - supabase/migrations/TIMESTAMP_parking_reservations.sql
autonomous: true

must_haves:
  truths:
    - "Parking spots are inventoried by type (assigned, visitor, disabled, etc.)"
    - "Parking assignments link spots to units with validity periods"
    - "Visitor reservations prevent overlapping via exclusion constraint"
    - "Parking violations capture evidence and link to vehicles"
  artifacts:
    - path: "supabase/migrations/*_parking_enums.sql"
      provides: "parking_spot_type, parking_spot_status enums"
    - path: "supabase/migrations/*_parking_tables.sql"
      provides: "parking_spots, parking_assignments tables"
    - path: "supabase/migrations/*_parking_reservations.sql"
      provides: "parking_reservations, parking_violations tables with exclusion constraint"
  key_links:
    - from: "parking_assignments.parking_spot_id"
      to: "parking_spots.id"
      via: "links assignment to spot"
    - from: "parking_reservations exclusion constraint"
      to: "time slot overlap prevention"
      via: "EXCLUDE USING gist with tstzrange"
    - from: "parking_violations.vehicle_id"
      to: "vehicles.id"
      via: "links violation to known vehicle"
---

<objective>
Create the parking management schema with spot inventory, unit assignments, visitor reservations with time-slot exclusion constraints, and violation tracking.

Purpose: Enable communities to manage parking infrastructure including assigned spots, visitor parking with reservations, and violation documentation.

Output: Parking inventory, assignment, reservation, and violation tables with proper constraints.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-governance-analytics/08-RESEARCH.md

# Prior infrastructure
@.planning/phases/02-identity-crm/02-01-SUMMARY.md (units)
@.planning/phases/02-identity-crm/02-02-SUMMARY.md (residents, vehicles)
@.planning/phases/05-amenities/05-02-SUMMARY.md (exclusion constraint pattern with btree_gist)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parking enum types</name>
  <files>supabase/migrations/TIMESTAMP_parking_enums.sql</files>
  <action>
Create migration with parking-related enum types:

```sql
-- Parking spot types
CREATE TYPE parking_spot_type AS ENUM (
  'assigned',    -- Belongs to specific unit
  'visitor',     -- For guests, first-come or reservation
  'commercial',  -- For commercial units/businesses
  'disabled',    -- Accessible parking
  'loading',     -- Loading/unloading zone
  'reserved'     -- Reserved for specific purpose (admin, emergency)
);

-- Parking spot operational status
CREATE TYPE parking_spot_status AS ENUM (
  'available',   -- Ready for use
  'occupied',    -- Currently in use
  'reserved',    -- Reserved for upcoming use
  'maintenance', -- Under maintenance
  'blocked'      -- Temporarily blocked
);
```

Include standard header comment with phase reference.
  </action>
  <verify>Run `supabase db reset` and check enum types exist with `\dT+ parking_*`</verify>
  <done>Two parking enums created: parking_spot_type, parking_spot_status</done>
</task>

<task type="auto">
  <name>Task 2: Create parking spots and assignments tables</name>
  <files>supabase/migrations/TIMESTAMP_parking_tables.sql</files>
  <action>
Create migration with parking inventory tables:

**parking_spots table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- Identification: spot_number TEXT NOT NULL (e.g., "A-01", "V-05")
- spot_type parking_spot_type NOT NULL
- Location: area TEXT (e.g., "Building A", "Outdoor", "Basement 1"), level TEXT, section TEXT
- Physical: is_covered BOOLEAN NOT NULL DEFAULT false, is_electric_vehicle BOOLEAN NOT NULL DEFAULT false, width_meters NUMERIC(4,2), length_meters NUMERIC(4,2)
- status parking_spot_status NOT NULL DEFAULT 'available'
- For assigned spots: assigned_unit_id UUID REFERENCES units(id) -- Denormalized for quick lookup
- Fees: monthly_fee money_amount DEFAULT 0
- Standard audit columns with soft delete
- UNIQUE (community_id, spot_number)

**parking_assignments table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- parking_spot_id UUID NOT NULL REFERENCES parking_spots(id)
- unit_id UUID NOT NULL REFERENCES units(id)
- vehicle_id UUID REFERENCES vehicles(id) -- Optional, spot assigned but vehicle unknown
- Validity: assigned_from DATE NOT NULL DEFAULT CURRENT_DATE, assigned_until DATE (NULL = permanent)
- assignment_type TEXT NOT NULL DEFAULT 'ownership' CHECK IN ('ownership', 'rental', 'temporary')
- monthly_rate money_amount -- For rentals
- is_active BOOLEAN NOT NULL DEFAULT true
- created_at, created_by audit columns

**Partial unique index for one active assignment per spot:**
CREATE UNIQUE INDEX parking_assignments_one_active
ON parking_assignments(parking_spot_id)
WHERE is_active = true;

**Trigger to update parking_spots.assigned_unit_id:**
- AFTER INSERT/UPDATE/DELETE on parking_assignments
- Updates parking_spots.assigned_unit_id based on active assignment

**Indexes:**
- idx_parking_spots_community_type ON parking_spots(community_id, spot_type)
- idx_parking_spots_status ON parking_spots(community_id, status)
- idx_parking_assignments_unit ON parking_assignments(unit_id) WHERE is_active = true

RLS policies:
- parking_spots: Community members can SELECT, staff can full CRUD
- parking_assignments: Community members can SELECT their own, staff can full CRUD
  </action>
  <verify>Run migration. Create spots, create assignment. Verify partial unique prevents duplicate active assignments.</verify>
  <done>Parking inventory and assignment tables with proper constraints</done>
</task>

<task type="auto">
  <name>Task 3: Create parking reservations and violations tables</name>
  <files>supabase/migrations/TIMESTAMP_parking_reservations.sql</files>
  <action>
Create migration with visitor parking and violations:

**parking_reservations table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- parking_spot_id UUID NOT NULL REFERENCES parking_spots(id)
- Reserving: unit_id UUID NOT NULL REFERENCES units(id), resident_id UUID NOT NULL REFERENCES residents(id)
- Visitor info: visitor_name TEXT NOT NULL, visitor_phone TEXT, visitor_vehicle_plates TEXT, visitor_vehicle_description TEXT
- Time slot: reservation_date DATE NOT NULL, start_time TIME NOT NULL, end_time TIME NOT NULL
- status TEXT NOT NULL DEFAULT 'confirmed' CHECK IN ('pending', 'confirmed', 'cancelled', 'completed', 'no_show')
- Actual usage: checked_in_at TIMESTAMPTZ, checked_out_at TIMESTAMPTZ
- notes TEXT
- Audit: created_at, cancelled_at TIMESTAMPTZ, cancelled_by UUID

**Exclusion constraint for non-overlapping reservations:**
Requires btree_gist extension (already enabled from Phase 5)

```sql
ALTER TABLE parking_reservations
ADD CONSTRAINT parking_reservations_no_overlap
EXCLUDE USING gist (
  parking_spot_id WITH =,
  tstzrange(
    (reservation_date + start_time) AT TIME ZONE 'America/Mexico_City',
    (reservation_date + end_time) AT TIME ZONE 'America/Mexico_City',
    '[)'
  ) WITH &&
) WHERE (status IN ('pending', 'confirmed'));
```

**parking_violations table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- Location: parking_spot_id UUID REFERENCES parking_spots(id), location_description TEXT
- Violator: vehicle_id UUID REFERENCES vehicles(id), vehicle_plates TEXT, vehicle_description TEXT
- violation_type TEXT NOT NULL CHECK IN ('unauthorized_parking', 'double_parking', 'blocking', 'overstay', 'wrong_spot', 'other')
- description TEXT NOT NULL
- Evidence: photo_urls TEXT[]
- observed_at TIMESTAMPTZ NOT NULL DEFAULT now()
- reported_by UUID REFERENCES auth.users(id)
- status TEXT NOT NULL DEFAULT 'reported' CHECK IN ('reported', 'warned', 'fined', 'resolved', 'dismissed')
- Resolution: resolved_at TIMESTAMPTZ, resolution_notes TEXT
- violation_record_id UUID -- Will reference violations table from 08-07 plan
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()

**Function to check reservation availability:**
```sql
CREATE OR REPLACE FUNCTION is_parking_available(
  p_spot_id UUID,
  p_date DATE,
  p_start TIME,
  p_end TIME
) RETURNS BOOLEAN
```
- Returns true if no conflicting reservations exist

**Indexes:**
- idx_parking_reservations_spot_date ON parking_reservations(parking_spot_id, reservation_date)
- idx_parking_reservations_unit ON parking_reservations(unit_id, reservation_date)
- idx_parking_violations_spot ON parking_violations(parking_spot_id) WHERE parking_spot_id IS NOT NULL
- idx_parking_violations_vehicle ON parking_violations(vehicle_id) WHERE vehicle_id IS NOT NULL

RLS policies:
- parking_reservations: Residents can full CRUD their own, staff can full CRUD all
- parking_violations: Residents can SELECT, staff can full CRUD
  </action>
  <verify>
Test flow:
1. Create visitor parking spot
2. Create reservation 10:00-12:00 - should succeed
3. Create overlapping reservation 11:00-13:00 - should fail (exclusion constraint)
4. Create adjacent reservation 12:00-14:00 - should succeed (no overlap with '[)' bounds)
5. Create parking violation with photos
6. is_parking_available check for various time slots
  </verify>
  <done>Visitor parking reservations with exclusion constraint and violations tracking</done>
</task>

</tasks>

<verification>
-- Create parking spots
INSERT INTO parking_spots (community_id, spot_number, spot_type, area)
VALUES
  ('...', 'A-01', 'assigned', 'Building A'),
  ('...', 'V-01', 'visitor', 'Main Entrance'),
  ('...', 'D-01', 'disabled', 'Building A');

-- Create assignment
INSERT INTO parking_assignments (community_id, parking_spot_id, unit_id, assignment_type)
VALUES ('...', 'spot-a-01-id', 'unit-101-id', 'ownership');
-- Verify parking_spots.assigned_unit_id updated

-- Attempt duplicate assignment
INSERT INTO parking_assignments (community_id, parking_spot_id, unit_id, assignment_type)
VALUES ('...', 'spot-a-01-id', 'unit-102-id', 'ownership');
-- Should fail: unique constraint violation

-- Create visitor reservation
INSERT INTO parking_reservations (
  community_id, parking_spot_id, unit_id, resident_id,
  visitor_name, reservation_date, start_time, end_time
) VALUES (
  '...', 'spot-v-01-id', 'unit-id', 'resident-id',
  'Juan Garcia', '2026-03-15', '10:00', '12:00'
);

-- Overlapping reservation should fail
INSERT INTO parking_reservations (..., start_time, end_time)
VALUES (..., '11:00', '13:00');
-- Should fail: exclusion constraint violation

-- Adjacent reservation should succeed
INSERT INTO parking_reservations (..., start_time, end_time)
VALUES (..., '12:00', '14:00');
-- Should succeed (no overlap with '[)' bounds)

-- Create parking violation
INSERT INTO parking_violations (
  community_id, parking_spot_id, vehicle_plates,
  violation_type, description, photo_urls
) VALUES (
  '...', 'spot-a-01-id', 'ABC-123',
  'unauthorized_parking', 'Unknown vehicle parked in assigned spot',
  ARRAY['violations/2026/03/15/photo1.jpg']
);
</verification>

<success_criteria>
- Parking enum types created (spot_type, spot_status)
- parking_spots table with inventory by type and location
- parking_assignments with partial unique for one active per spot
- Denormalized assigned_unit_id updated via trigger
- parking_reservations with exclusion constraint preventing overlap
- '[)' bounds allow adjacent time slots (10:00-12:00, 12:00-14:00)
- parking_violations capture evidence and link to vehicles
- is_parking_available function for availability checks
- All tables have proper RLS policies
</success_criteria>

<output>
After completion, create `.planning/phases/08-governance-analytics/08-04-SUMMARY.md`
</output>
