---
phase: 08-governance-analytics
plan: 09
type: execute
wave: 2
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_webhook_tables.sql
  - supabase/migrations/TIMESTAMP_webhook_functions.sql
  - supabase/migrations/TIMESTAMP_api_keys_integrations.sql
autonomous: true

must_haves:
  truths:
    - "Webhook endpoints store URL, secret, and subscribed event types"
    - "Webhook deliveries queue with exponential backoff retry (1m, 5m, 15m, 1h, 4h, 24h)"
    - "Dead letter queue captures exhausted retries after 6 attempts"
    - "API keys store prefix + SHA-256 hash only (never plaintext)"
    - "API key scopes control granular access permissions"
    - "Integration configs store connection details with sync status"
  artifacts:
    - path: "supabase/migrations/*_webhook_tables.sql"
      provides: "webhook_endpoints, webhook_deliveries tables with retry queue"
    - path: "supabase/migrations/*_webhook_functions.sql"
      provides: "queue_webhook(), calculate_next_retry(), record_webhook_result() functions"
    - path: "supabase/migrations/*_api_keys_integrations.sql"
      provides: "api_keys, api_key_usage, integration_configs, integration_sync_logs tables"
  key_links:
    - from: "webhook_deliveries.next_attempt_at"
      to: "calculate_next_retry()"
      via: "exponential backoff calculation"
    - from: "api_keys.key_hash"
      to: "SHA-256(api_key)"
      via: "secure storage, never stored in plaintext"
    - from: "validate_api_key()"
      to: "api_keys"
      via: "hash comparison for authentication"
---

<objective>
Create the external integrations schema with webhook delivery queue using exponential backoff, API key management with secure hashing, and integration configuration storage.

Purpose: Enable third-party systems to integrate with UPOE via webhooks for event notifications and API keys for programmatic access, with proper security and reliability patterns.

Output: Webhook delivery system, API key management, and integration configuration tables.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-governance-analytics/08-RESEARCH.md

# Prior infrastructure
@.planning/phases/03-access-control-security/03-04-SUMMARY.md (HMAC-SHA256 pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook endpoint and delivery tables</name>
  <files>supabase/migrations/TIMESTAMP_webhook_tables.sql</files>
  <action>
Create migration with webhook infrastructure:

**webhook_status enum:**
```sql
CREATE TYPE webhook_status AS ENUM (
  'pending',
  'sending',
  'delivered',
  'failed',
  'retrying',
  'dead_letter'  -- Exhausted all retries
);
```

**webhook_endpoints table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- name TEXT NOT NULL
- url TEXT NOT NULL
- secret TEXT NOT NULL -- For HMAC signature verification
- event_types TEXT[] NOT NULL -- ['access.entry', 'incident.created', 'payment.received', etc.]
- is_active BOOLEAN NOT NULL DEFAULT true
- Health tracking: consecutive_failures INTEGER NOT NULL DEFAULT 0, last_success_at TIMESTAMPTZ, last_failure_at TIMESTAMPTZ, last_failure_reason TEXT
- auto_disabled_at TIMESTAMPTZ -- Auto-disable after 10 consecutive failures
- custom_headers JSONB DEFAULT '{}'
- max_retries INTEGER NOT NULL DEFAULT 5
- Standard audit columns with created_by

**webhook_deliveries table:**
- id UUID PK DEFAULT generate_uuid_v7()
- endpoint_id UUID NOT NULL REFERENCES webhook_endpoints(id) ON DELETE CASCADE
- community_id UUID NOT NULL REFERENCES communities(id)
- Event: event_type TEXT NOT NULL, event_id UUID NOT NULL, payload JSONB NOT NULL
- Delivery: status webhook_status NOT NULL DEFAULT 'pending'
- Retry tracking: attempt_count INTEGER NOT NULL DEFAULT 0, max_attempts INTEGER NOT NULL DEFAULT 6, next_attempt_at TIMESTAMPTZ
- Last attempt: last_attempt_at TIMESTAMPTZ, last_response_code INTEGER, last_response_body TEXT, last_error TEXT
- Success: delivered_at TIMESTAMPTZ
- signature TEXT -- HMAC-SHA256 of payload
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()

**Indexes:**
- idx_webhook_endpoints_community ON webhook_endpoints(community_id) WHERE is_active = true
- idx_webhook_deliveries_pending ON webhook_deliveries(next_attempt_at) WHERE status IN ('pending', 'retrying')
- idx_webhook_deliveries_endpoint ON webhook_deliveries(endpoint_id, created_at DESC)

RLS policies:
- webhook_endpoints: Admins can full CRUD
- webhook_deliveries: Admins can SELECT, system can full CRUD
  </action>
  <verify>Run migration. Create endpoint with event types. Verify indexes created.</verify>
  <done>Webhook endpoint and delivery tables with retry queue support</done>
</task>

<task type="auto">
  <name>Task 2: Create webhook queue and delivery functions</name>
  <files>supabase/migrations/TIMESTAMP_webhook_functions.sql</files>
  <action>
Create migration with webhook processing functions:

**calculate_next_retry(p_attempt INTEGER) function:**
- Returns INTERVAL
- IMMUTABLE (pure function)
- Exponential backoff schedule:
  - Attempt 1: 1 minute
  - Attempt 2: 5 minutes
  - Attempt 3: 15 minutes
  - Attempt 4: 1 hour
  - Attempt 5: 4 hours
  - Attempt 6+: 24 hours

**queue_webhook(p_community_id, p_event_type, p_event_id, p_payload JSONB) function:**
- Returns SETOF UUID (delivery IDs created)
- Finds all active endpoints subscribed to event_type
- For each endpoint:
  - Generate HMAC-SHA256 signature using endpoint.secret
  - Create webhook_deliveries record with immediate next_attempt_at
  - Return delivery ID

**process_webhook_delivery(p_delivery_id UUID) function:**
- Returns BOOLEAN
- Locks delivery record with FOR UPDATE SKIP LOCKED
- Validates status IN ('pending', 'retrying')
- Updates status to 'sending', increments attempt_count
- Returns true if ready for HTTP call (actual call done by Edge Function)

**record_webhook_result(p_delivery_id, p_success BOOLEAN, p_response_code, p_response_body, p_error) function:**
- Returns VOID
- If success:
  - Update delivery: status = 'delivered', delivered_at = now()
  - Update endpoint: consecutive_failures = 0, last_success_at = now()
- If failure:
  - If attempt_count >= max_attempts: status = 'dead_letter'
  - Else: status = 'retrying', next_attempt_at = now() + calculate_next_retry(attempt_count)
  - Update endpoint: consecutive_failures++, last_failure_at, last_failure_reason
  - If consecutive_failures >= 10: auto_disabled_at = now()

**get_pending_webhooks(p_limit INTEGER DEFAULT 100) function:**
- Returns TABLE(delivery_id, endpoint_url, payload, signature, custom_headers)
- Selects deliveries WHERE status IN ('pending', 'retrying') AND next_attempt_at <= now()
- Joins to endpoint for URL and headers
- Ordered by next_attempt_at ASC
- Limited to p_limit for batch processing

**retry_dead_letter(p_delivery_id UUID) function:**
- Resets delivery for manual retry
- Sets status = 'retrying', attempt_count = 0, max_attempts = 3, next_attempt_at = now()
- Used when endpoint issue is fixed
  </action>
  <verify>
Test webhook flow:
1. Create endpoint subscribed to 'payment.received'
2. queue_webhook with payment event - verify delivery created
3. process_webhook_delivery - verify status = 'sending'
4. record_webhook_result(success) - verify delivered_at set
5. record_webhook_result(failure) - verify retry scheduled
6. Exhaust retries - verify dead_letter status
7. retry_dead_letter - verify reset for retry
  </verify>
  <done>Webhook queue functions with exponential backoff and dead letter handling</done>
</task>

<task type="auto">
  <name>Task 3: Create API keys and integration configuration tables</name>
  <files>supabase/migrations/TIMESTAMP_api_keys_integrations.sql</files>
  <action>
Create migration with API key and integration management:

**api_keys table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- name TEXT NOT NULL, description TEXT
- Key storage: key_prefix TEXT NOT NULL (first 16 chars: "upoe_sk_abc123..."), key_hash TEXT NOT NULL (SHA-256)
- scopes TEXT[] NOT NULL -- ['access_logs:read', 'residents:read', 'payments:write']
- Restrictions: allowed_ips INET[], rate_limit_per_minute INTEGER DEFAULT 60
- expires_at TIMESTAMPTZ
- Status: is_active BOOLEAN NOT NULL DEFAULT true, revoked_at TIMESTAMPTZ, revoked_by UUID REFERENCES auth.users(id), revoke_reason TEXT
- Usage: last_used_at TIMESTAMPTZ, last_used_ip INET, total_requests INTEGER DEFAULT 0
- Standard audit columns
- UNIQUE (community_id, key_prefix)

**api_key_usage table (for rate limiting and auditing):**
- id UUID PK DEFAULT generate_uuid_v7()
- api_key_id UUID NOT NULL REFERENCES api_keys(id)
- endpoint TEXT NOT NULL, method TEXT NOT NULL
- ip_address INET NOT NULL, user_agent TEXT
- response_code INTEGER, response_time_ms INTEGER
- requested_at TIMESTAMPTZ NOT NULL DEFAULT now()

**Indexes:**
- idx_api_key_usage_key_time ON api_key_usage(api_key_id, requested_at DESC)
- idx_api_key_usage_time_brin ON api_key_usage USING BRIN(requested_at)

**generate_api_key(p_community_id, p_name, p_scopes TEXT[], p_expires_in_days INTEGER) function:**
- Returns TABLE(key_id UUID, api_key TEXT, prefix TEXT, expires_at TIMESTAMPTZ)
- CRITICAL: api_key is returned ONLY ONCE on creation
- Generates: 'upoe_sk_' + base64(gen_random_bytes(24))
- URL-safe: replace +/= with alphanumeric
- Stores prefix (first 16 chars) + SHA-256 hash
- Never stores full key

**validate_api_key(p_key TEXT, p_required_scope TEXT) function:**
- Returns TABLE(is_valid BOOLEAN, key_id UUID, community_id UUID, scopes TEXT[], error_message TEXT)
- Hashes provided key, looks up by hash
- Validates: active, not expired, scope present
- Updates: last_used_at, total_requests
- Returns error_message for specific failures (invalid/revoked/expired/insufficient_scope)

**revoke_api_key(p_key_id UUID, p_reason TEXT) function:**
- Sets is_active = false, revoked_at = now(), revoked_by, revoke_reason
- Idempotent (safe to call multiple times)

**integration_configs table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- integration_type TEXT NOT NULL -- 'bank_feed', 'lpr', 'cctv', 'access_control', 'payment_gateway'
- name TEXT NOT NULL
- provider TEXT NOT NULL -- 'banamex', 'hikvision', 'stripe'
- config JSONB NOT NULL DEFAULT '{}' -- Non-sensitive config
- vault_secret_id TEXT -- Reference to Supabase Vault for credentials
- Status: status TEXT NOT NULL DEFAULT 'pending' CHECK IN ('pending', 'active', 'error', 'disabled')
- Health: last_sync_at TIMESTAMPTZ, last_sync_status TEXT, last_error TEXT
- sync_interval_minutes INTEGER DEFAULT 60
- Standard audit columns
- UNIQUE (community_id, integration_type, name)

**integration_sync_logs table:**
- id UUID PK DEFAULT generate_uuid_v7()
- integration_id UUID NOT NULL REFERENCES integration_configs(id) ON DELETE CASCADE
- started_at TIMESTAMPTZ NOT NULL DEFAULT now()
- completed_at TIMESTAMPTZ
- status TEXT NOT NULL DEFAULT 'running' CHECK IN ('running', 'success', 'partial', 'failed')
- Records: records_processed INTEGER DEFAULT 0, records_created INTEGER DEFAULT 0, records_updated INTEGER DEFAULT 0, records_failed INTEGER DEFAULT 0
- Errors: error_message TEXT, error_details JSONB
- sync_type TEXT -- 'full', 'incremental', 'manual'
- triggered_by UUID REFERENCES auth.users(id)

**Indexes:**
- idx_integration_sync_logs_integration ON integration_sync_logs(integration_id, started_at DESC)

RLS policies:
- api_keys: Admins can full CRUD, key_hash never exposed in SELECT
- api_key_usage: Platform admins only
- integration_configs: Admins can full CRUD
- integration_sync_logs: Admins can SELECT
  </action>
  <verify>
Test API key flow:
1. generate_api_key - returns full key ONCE
2. validate_api_key with correct key - returns is_valid = true
3. validate_api_key with wrong key - returns is_valid = false
4. validate_api_key with missing scope - returns error_message
5. revoke_api_key - verify key validation fails after revoke
6. Create integration config, verify vault_secret_id reference pattern
  </verify>
  <done>API key management with secure hashing and integration configuration</done>
</task>

</tasks>

<verification>
-- Create webhook endpoint
INSERT INTO webhook_endpoints (
  community_id, name, url, secret, event_types
) VALUES (
  '...', 'Payment Notifications', 'https://erp.example.com/webhooks/payments',
  'webhook_secret_123', ARRAY['payment.received', 'payment.failed']
);

-- Queue webhook delivery
SELECT * FROM queue_webhook(
  'community-id',
  'payment.received',
  'transaction-uuid',
  '{"amount": 5000, "unit": "101"}'::JSONB
);
-- Returns delivery_id, signature generated

-- Check pending webhooks
SELECT * FROM get_pending_webhooks(10);
-- Returns delivery ready for processing

-- Simulate failure and retry
SELECT process_webhook_delivery('delivery-id');
SELECT record_webhook_result('delivery-id', false, 500, 'Internal Server Error', NULL);
-- Verify next_attempt_at is 1 minute from now

-- Generate API key
SELECT * FROM generate_api_key(
  'community-id',
  'ERP Integration',
  ARRAY['access_logs:read', 'residents:read'],
  365
);
-- Returns: key_id, api_key (SAVE THIS - only shown once), prefix, expires_at

-- Validate API key
SELECT * FROM validate_api_key('upoe_sk_...full_key...', 'access_logs:read');
-- Returns: is_valid = true, key_id, community_id, scopes

-- Invalid scope
SELECT * FROM validate_api_key('upoe_sk_...full_key...', 'payments:write');
-- Returns: is_valid = false, error_message = 'Insufficient scope'

-- Revoke key
SELECT revoke_api_key('key-id', 'Suspected compromise');
SELECT * FROM validate_api_key('upoe_sk_...full_key...', NULL);
-- Returns: is_valid = false, error_message = 'API key is revoked'

-- Create integration config
INSERT INTO integration_configs (
  community_id, integration_type, name, provider, config
) VALUES (
  '...', 'payment_gateway', 'Stripe Production', 'stripe',
  '{"webhook_endpoint": "https://api.upoe.mx/webhooks/stripe"}'
);
</verification>

<success_criteria>
- webhook_endpoints store URL, secret, and subscribed events
- webhook_deliveries queue with status tracking
- calculate_next_retry implements exponential backoff (1m->5m->15m->1h->4h->24h)
- Dead letter status after 6 failed attempts
- Auto-disable endpoint after 10 consecutive failures
- queue_webhook creates deliveries with HMAC signature
- get_pending_webhooks enables batch processing
- api_keys store prefix + SHA-256 hash ONLY (never plaintext)
- generate_api_key returns full key ONLY ONCE
- validate_api_key hashes input and compares
- Scope-based access control with error messages
- revoke_api_key immediately invalidates key
- integration_configs with vault_secret_id for credentials
- integration_sync_logs track sync history
</success_criteria>

<output>
After completion, create `.planning/phases/08-governance-analytics/08-09-SUMMARY.md`
</output>
