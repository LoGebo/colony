---
phase: 08-governance-analytics
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/TIMESTAMP_access_device_enums.sql
  - supabase/migrations/TIMESTAMP_access_devices_tables.sql
  - supabase/migrations/TIMESTAMP_access_device_lifecycle.sql
autonomous: true

must_haves:
  truths:
    - "Access device types define categories with deposit and replacement fees"
    - "Access devices have serial numbers and track inventory status"
    - "Device assignments record who has what device with deposit tracking"
    - "Lost device reports trigger proper status updates and fee charges"
    - "Device events provide complete audit history"
  artifacts:
    - path: "supabase/migrations/*_access_device_enums.sql"
      provides: "device_type, device_status enums"
    - path: "supabase/migrations/*_access_devices_tables.sql"
      provides: "access_device_types, access_devices, access_device_assignments tables"
    - path: "supabase/migrations/*_access_device_lifecycle.sql"
      provides: "access_device_events, report_device_lost(), assign_device() functions"
  key_links:
    - from: "access_devices.device_type_id"
      to: "access_device_types.id"
      via: "defines device category and fees"
    - from: "access_device_assignments trigger"
      to: "access_devices.status"
      via: "updates device status on assignment/return"
    - from: "access_device_events"
      to: "access_devices"
      via: "audit trail for device lifecycle"
---

<objective>
Create the access device management schema with device type definitions, inventory tracking with serial numbers, assignment workflow, and complete lifecycle event logging.

Purpose: Enable communities to manage physical access credentials (tags, remotes, keys, cards) with full audit trail for assignment, return, lost reports, and replacements.

Output: Access device inventory, assignment, and event tables with lifecycle management functions.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-governance-analytics/08-RESEARCH.md

# Prior infrastructure
@.planning/phases/02-identity-crm/02-01-SUMMARY.md (units)
@.planning/phases/02-identity-crm/02-02-SUMMARY.md (residents)
@.planning/phases/03-access-control-security/03-01-SUMMARY.md (guards)
@.planning/phases/07-operations-compliance/07-02-SUMMARY.md (provider_personnel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create access device enum types</name>
  <files>supabase/migrations/TIMESTAMP_access_device_enums.sql</files>
  <action>
Create migration with access device enum types:

```sql
-- Device types
CREATE TYPE device_type AS ENUM (
  'rfid_tag',     -- Proximity tag/fob
  'rfid_card',    -- Proximity card
  'remote',       -- Gate remote control
  'physical_key', -- Traditional key
  'transponder',  -- Vehicle transponder
  'biometric'     -- Biometric enrollment (fingerprint, etc.)
);

-- Device status in lifecycle
CREATE TYPE device_status AS ENUM (
  'in_inventory',  -- Available for assignment
  'assigned',      -- Currently assigned to someone
  'lost',          -- Reported lost
  'damaged',       -- Damaged, needs replacement
  'deactivated',   -- Intentionally disabled
  'retired'        -- Permanently out of service
);
```

Include standard header comment with phase reference.
  </action>
  <verify>Run `supabase db reset` and check enum types exist with `\dT+ device_*`</verify>
  <done>Two device enums created: device_type, device_status</done>
</task>

<task type="auto">
  <name>Task 2: Create access device types, inventory, and assignments tables</name>
  <files>supabase/migrations/TIMESTAMP_access_devices_tables.sql</files>
  <action>
Create migration with device management tables:

**access_device_types table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- device_type device_type NOT NULL
- name TEXT NOT NULL (e.g., "Main Gate Remote", "Building A Tag")
- description TEXT
- access_point_ids UUID[] -- Which access points this type can open (NULL = all)
- Fees: deposit_amount money_amount DEFAULT 0, replacement_fee money_amount DEFAULT 0
- is_active BOOLEAN NOT NULL DEFAULT true
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE (community_id, name)

**access_devices table:**
- id UUID PK DEFAULT generate_uuid_v7()
- community_id UUID NOT NULL REFERENCES communities(id)
- device_type_id UUID NOT NULL REFERENCES access_device_types(id)
- Identification: serial_number TEXT NOT NULL, internal_code TEXT (RFID code, key number)
- Batch info: batch_number TEXT, purchased_at DATE, vendor TEXT
- Status: status device_status NOT NULL DEFAULT 'in_inventory', status_changed_at TIMESTAMPTZ NOT NULL DEFAULT now()
- current_assignment_id UUID -- Denormalized for quick lookup
- Lost tracking: lost_reported_at TIMESTAMPTZ, lost_reported_by UUID REFERENCES auth.users(id)
- Damage tracking: damaged_reported_at TIMESTAMPTZ, damage_notes TEXT
- Deactivation: deactivated_at TIMESTAMPTZ, deactivated_by UUID REFERENCES auth.users(id), deactivation_reason TEXT
- Standard audit columns
- UNIQUE (community_id, serial_number)

**access_device_assignments table:**
- id UUID PK DEFAULT generate_uuid_v7()
- access_device_id UUID NOT NULL REFERENCES access_devices(id)
- community_id UUID NOT NULL REFERENCES communities(id)
- Assignee (one of): unit_id UUID REFERENCES units(id), resident_id UUID REFERENCES residents(id), guard_id UUID REFERENCES guards(id), provider_personnel_id UUID REFERENCES provider_personnel(id)
- Assignment period: assigned_at TIMESTAMPTZ NOT NULL DEFAULT now(), assigned_by UUID REFERENCES auth.users(id), returned_at TIMESTAMPTZ, returned_to UUID REFERENCES auth.users(id)
- Deposit: deposit_collected BOOLEAN NOT NULL DEFAULT false, deposit_amount money_amount, deposit_returned_at TIMESTAMPTZ
- Return condition: return_condition TEXT CHECK IN ('good', 'damaged', 'lost', 'not_returned'), condition_notes TEXT
- replacement_fee_charged BOOLEAN DEFAULT false
- is_active BOOLEAN NOT NULL DEFAULT true

**Partial unique for one active assignment per device:**
CREATE UNIQUE INDEX access_device_assignments_one_active
ON access_device_assignments(access_device_id)
WHERE is_active = true;

**CHECK constraint for assignee (exactly one must be set):**
```sql
CHECK (
  (unit_id IS NOT NULL)::INT +
  (resident_id IS NOT NULL)::INT +
  (guard_id IS NOT NULL)::INT +
  (provider_personnel_id IS NOT NULL)::INT = 1
)
```

**Indexes:**
- idx_access_devices_community_status ON access_devices(community_id, status)
- idx_access_devices_serial ON access_devices(community_id, serial_number)
- idx_access_device_assignments_device ON access_device_assignments(access_device_id)
- idx_access_device_assignments_resident ON access_device_assignments(resident_id) WHERE resident_id IS NOT NULL

RLS policies:
- access_device_types: Community members can SELECT, admins can full CRUD
- access_devices: Staff can full CRUD, residents can SELECT
- access_device_assignments: Staff can full CRUD, residents can SELECT their own
  </action>
  <verify>Run migration. Create device type, create device, create assignment. Verify constraints.</verify>
  <done>Access device inventory and assignment tables with proper constraints</done>
</task>

<task type="auto">
  <name>Task 3: Create device lifecycle functions and event logging</name>
  <files>supabase/migrations/TIMESTAMP_access_device_lifecycle.sql</files>
  <action>
Create migration with device lifecycle management:

**access_device_events table:**
- id UUID PK DEFAULT generate_uuid_v7()
- access_device_id UUID NOT NULL REFERENCES access_devices(id)
- event_type TEXT NOT NULL CHECK IN ('created', 'assigned', 'returned', 'lost', 'found', 'damaged', 'deactivated', 'reactivated', 'retired')
- description TEXT NOT NULL
- metadata JSONB DEFAULT '{}'
- performed_by UUID REFERENCES auth.users(id)
- occurred_at TIMESTAMPTZ NOT NULL DEFAULT now()

**update_device_on_assignment() trigger function:**
- AFTER INSERT OR UPDATE on access_device_assignments
- On INSERT:
  - Update access_devices: status = 'assigned', current_assignment_id = NEW.id
  - Log 'assigned' event
- On UPDATE when returned_at becomes NOT NULL:
  - Update access_devices status based on return_condition:
    - 'good' -> 'in_inventory'
    - 'damaged' -> 'damaged'
    - 'lost' -> 'lost'
  - Clear current_assignment_id
  - Set NEW.is_active = false
  - Log appropriate event

**assign_device(p_device_id, p_unit_id, p_resident_id, p_guard_id, p_provider_personnel_id, p_collect_deposit BOOLEAN) function:**
- Returns UUID (assignment_id)
- Validates device status = 'in_inventory'
- Looks up deposit_amount from device_type
- Creates assignment record
- Device status updated via trigger

**return_device(p_assignment_id, p_condition, p_notes) function:**
- Returns VOID
- Validates assignment is active
- Updates assignment: returned_at, return_condition, condition_notes, returned_to
- If condition = 'good' and deposit was collected, sets deposit_returned_at
- If condition = 'damaged' or 'lost', sets replacement_fee_charged based on device_type
- Device status updated via trigger

**report_device_lost(p_device_id, p_notes) function:**
- Returns VOID
- Gets current active assignment
- Calls return_device with condition = 'lost'
- Additionally updates access_devices.lost_reported_at, lost_reported_by
- Logs 'lost' event with notes

**deactivate_device(p_device_id, p_reason) function:**
- Returns VOID
- Validates device exists
- If device is assigned, must be unassigned first
- Updates device: status = 'deactivated', deactivated_at, deactivated_by, deactivation_reason
- Logs 'deactivated' event

**reactivate_device(p_device_id) function:**
- Returns VOID
- Validates device status IN ('deactivated', 'lost', 'damaged')
- Updates device: status = 'in_inventory', clears deactivation fields
- Logs 'reactivated' event

**Create trigger:** access_device_assignment_status AFTER INSERT OR UPDATE ON access_device_assignments

**Index for events:**
- idx_access_device_events_device ON access_device_events(access_device_id, occurred_at DESC)
  </action>
  <verify>
Test lifecycle:
1. Create device type with deposit = 500
2. Create device in inventory
3. assign_device to unit - verify status = 'assigned', event logged
4. return_device with condition = 'good' - verify status = 'in_inventory', deposit_returned_at set
5. assign_device again
6. report_device_lost - verify status = 'lost', replacement_fee_charged = true, event logged
7. reactivate_device - verify status = 'in_inventory'
8. deactivate_device - verify status = 'deactivated'
  </verify>
  <done>Complete device lifecycle with assignment, return, lost report, and audit trail</done>
</task>

</tasks>

<verification>
-- Create device type
INSERT INTO access_device_types (community_id, device_type, name, deposit_amount, replacement_fee)
VALUES ('...', 'remote', 'Main Gate Remote', 500.00, 800.00);

-- Create device
INSERT INTO access_devices (community_id, device_type_id, serial_number, internal_code)
VALUES ('...', 'device-type-id', 'RMT-2026-00001', 'RF-ABC123');
-- Verify status = 'in_inventory'

-- Assign to unit
SELECT assign_device('device-id', 'unit-id', NULL, NULL, NULL, true);
-- Verify:
--   access_devices.status = 'assigned'
--   access_devices.current_assignment_id is set
--   access_device_events has 'assigned' event
--   assignment.deposit_collected = true, deposit_amount = 500

-- Return in good condition
SELECT return_device('assignment-id', 'good', 'Device in perfect condition');
-- Verify:
--   access_devices.status = 'in_inventory'
--   assignment.deposit_returned_at is set
--   access_device_events has 'returned' event

-- Assign again and report lost
SELECT assign_device('device-id', NULL, 'resident-id', NULL, NULL, true);
SELECT report_device_lost('device-id', 'Resident claims it was stolen from car');
-- Verify:
--   access_devices.status = 'lost'
--   access_devices.lost_reported_at is set
--   assignment.return_condition = 'lost'
--   assignment.replacement_fee_charged = true
--   access_device_events has 'lost' event

-- Reactivate (device found or replaced)
SELECT reactivate_device('device-id');
-- Verify: status = 'in_inventory'

-- Deactivate
SELECT deactivate_device('device-id', 'Security upgrade - replacing all remotes');
-- Verify: status = 'deactivated', deactivation_reason set
</verification>

<success_criteria>
- Device enum types created (device_type, device_status)
- access_device_types define categories with deposit/replacement fees
- access_devices inventory with serial numbers and status tracking
- access_device_assignments with polymorphic assignee (unit, resident, guard, provider)
- Partial unique ensures one active assignment per device
- Trigger updates device status on assignment/return
- access_device_events provides complete audit trail
- assign_device() validates availability, collects deposit info
- return_device() handles condition-based status updates
- report_device_lost() triggers lost status and replacement fees
- deactivate/reactivate_device() for security management
</success_criteria>

<output>
After completion, create `.planning/phases/08-governance-analytics/08-05-SUMMARY.md`
</output>
